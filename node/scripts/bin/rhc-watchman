#!/usr/bin/env ruby

#
# rhc-watchman - restart an application that has been killed by cgroups
# Runs as a daemon and monitors /var/log/messags for notifications of cgroups killing applications 

require 'pathname'
require 'date'
require 'syslog'

##
# Monitor syslog files for messages from cgroups killing off applications 
class Watchman
  attr_accessor :epoch, :period_seconds, :message_file

  ##
  # monitor +message_file+ every +period+ seconds for cgroups kill messages
  def initialize(message_file = '/var/log/messages', period = 10, daemon=true, epoch = DateTime.now, libra_var_lib = '/var/lib/libra')
    @message_file = message_file
    @period_seconds = period
    @daemon = daemon
    @var_lib = libra_var_lib

    # Once the SDK has finer control over whether an application should be running or not this could be lifted.
    # Don't process any errors that occurred before we were started.
    # Maybe use application status to get around this issue
    @epoch = epoch

    daemon() if daemon

    @incidents = {}

    Syslog.open(File.basename($0), Syslog::LOG_PID, Syslog::LOG_DAEMON) unless Syslog.opened?
    Syslog.info('Starting rhc-watchman')
  end

  def run()
    begin
      sleep @period_seconds

      # pull in all environments to find new applications and incorporate any changes...
      # todo add last_run logic to only read files when needed
      app_env = {}
      Dir[@var_lib + '/*'].each {|app_path|
        app_uuid = File.basename(app_path)
        app_env[app_uuid] = read_env(app_path) if app_uuid =~ /^[a-f0-9]{32}$/ 
      }
      next if app_env.empty?

      # Read current message_file and troll for killed applications
      # todo dump incidents if message_file has rolled?
      File.open(@message_file).grep(/ killed as a result of limit of /).each {|msg|
        # timezones are just a PITA. Syslog message doesn't include timezone so inject timezone from epoch
        ts = DateTime.strptime(msg, '%b %d %T')
        timestamp = DateTime.civil(ts.year, ts.month, ts.day, ts.hour, ts.min, ts.sec, epoch.zone)

        uuid = msg.scan(/[a-f0-9]{32}/).first

        # Skip any messages that occurred before we were started.
        # Assume those have been dealt with manually or on a previous run. 
        # We don't want to restart any application that may already be running.
        next if epoch > timestamp 

        cache_incident(uuid, timestamp, app_env)
      }

      app_env.keys.each {|uuid|
        if app_env[uuid][:OPENSHIFT_APP_TYPE].start_with?('jboss')
          File.open("#{app_env[uuid][:OPENSHIFT_LOG_DIR]}/server.log").grep(/ java.lang.OutOfMemoryError/) {|msg|
            # timezones are just a PITA. server.log message doesn't include timezone or date so inject both from today
            ts = DateTime.strptime(msg, '%T')
            today = now()
            timestamp = DateTime.civil(today.year, today.month, today.day, ts.hour, ts.min, ts.sec, today.zone)
            next if epoch > timestamp 

            cache_incident(uuid, timestamp, app_env)
          }
        end
      }
    end while @daemon
  end
  
  # Exposed to be overridden by unit tests
  def now() DateTime.now end

  # Don't restart if application has been marked down
  def restart(uuid, env) 
    stop_lock = "#{env[uuid][:OPENSHIFT_APP_DIR]}run/stop_lock"
    if not File.exists?(stop_lock) 
      `service libra restartuser #{uuid}`
      Syslog.info("watchman restarted user #{uuid}: application #{env[uuid][:OPENSHIFT_APP_NAME]}") 
    end
  end

  private

  def cache_incident(uuid, timestamp, env)
    if @incidents.has_key?(uuid) 
      if @incidents[uuid][:last_updated] < timestamp
        # Repeat death. Should there be an additional delay here?
        restart(uuid, env)
        @incidents[uuid] = {:last_updated => timestamp}
      end
    else
      # First death. Restart and move on...
      restart(uuid, env)
      @incidents[uuid] = {:last_updated => timestamp}
    end
  end

  # Load environment variables into a hash
  def read_env(path)
    env = {}
    Dir["#{path}/.env/*"].each { |f|
      contents = nil
      File.open(f) {|input|
        contents = input.read.chomp
        index = contents.index('=')
        contents = contents[(index + 1)..-1]
        contents = contents[/'(.*)'/, 1] if contents.start_with?("'")
        contents = contents[/"(.*)"/, 1] if contents.start_with?('"')
      }
      env[File.basename(f).intern] =  contents
    }
    env
  end

  # Make current process a daemon
  def daemon()
    if '1.9' <= RUBY_VERSION
      Process.daemon
    else
      Syslog.warning('Fork from parent process failed') if (pid = fork) == -1
      exit unless pid.nil?

      Process.setsid
      Syslog.warning('Fork from process leader failed') if (pid = fork) == -1
      exit unless pid.nil?

      Dir.chdir '/'
      File.umask 0000

      STDIN.reopen '/dev/null'
      STDOUT.reopen '/dev/null', 'a'
      STDERR.reopen STDOUT
    end

    File.open("/var/run/#{File.basename($0)}.pid", 'w') {|f| f.puts(Process.pid)}
  end
end

if __FILE__ == $0
  raise 'Must run as root' if Process.euid != 0
  Watchman.new().run
end

