#!/usr/bin/env ruby

#
# rhc-watchman - restart an application that has been killed by cgroups
# Runs as a daemon and monitors /var/log/messags for notifications of cgroups killing applications 

require 'pathname'
require 'date'
require 'syslog'

##
# Monitor syslog files for messages from cgroups killing off applications 
class Watchman
  attr_accessor :epoch, :period_seconds, :message_file, :retries

  ##
  # monitor +message_file+ every +period+ seconds for cgroups kill messages
  def initialize(message_file = '/var/log/messages', period = 10, daemon=true, epoch = DateTime.now, libra_var_lib = '/var/lib/stickshift')
    @message_file = message_file
    @period_seconds = period
    @daemon = daemon
    @var_lib = libra_var_lib
    @retries = 10

    # Once the SDK has finer control over whether an application should be running or not this could be lifted.
    # Don't process any errors that occurred before we were started.
    # Maybe use application status to get around this issue
    @epoch = epoch

    daemon() if daemon

    @incidents = {}

    Syslog.open(File.basename($0), Syslog::LOG_PID, Syslog::LOG_DAEMON) unless Syslog.opened?
    Syslog.info('Starting rhc-watchman')
  end

  def run()
    begin
      sleep @period_seconds

      # pull in all environments to find new applications and incorporate any changes...
      # todo add last_run logic to only read files when needed
      app_env = {}
      Dir[@var_lib + '/*'].each {|app_path|
        app_uuid = File.basename(app_path)
        app_env[app_uuid] = read_env(app_path) if app_uuid =~ /^[a-f0-9]{32}$/ 
      }
      next if app_env.empty?
	
      # Read current message_file and troll for killed applications
      # todo dump incidents if message_file has rolled?
      File.open(@message_file).grep(/ killed as a result of limit of /).each {|msg|
        # timezones are just a PITA. Syslog message doesn't include timezone so inject timezone from epoch
        ts = DateTime.strptime(msg, '%b %d %T')
        timestamp = DateTime.civil(ts.year, ts.month, ts.day, ts.hour, ts.min, ts.sec, epoch.zone)

        uuid = msg.scan(/[a-f0-9]{32}/).first

        # Skip any messages that occurred before we were started.
        # Assume those have been dealt with manually or on a previous run. 
        # We don't want to restart any application that may already be running.
        next if epoch > timestamp 

        cache_incident(uuid, timestamp, app_env)
      }

      app_env.keys.each {|uuid|
        if app_env[uuid][:OPENSHIFT_GEAR_TYPE].nil?
          Syslog.warning("watchman unable to determine application type of user #{uuid}. OPENSHIFT_HOMEDIR/.env/OPENSHIFT_GEAR_TYPE missing.")
          next
        end

        if app_env[uuid][:OPENSHIFT_GEAR_TYPE].start_with?('jboss')
          if app_env[uuid][:OPENSHIFT_LOG_DIR].nil?
            Syslog.warning("watchman unable to determine log directory for user #{uuid}. OPENSHIFT_HOMEDIR/.env/OPENSHIFT_LOG_DIR missing.")
            next
          end

          # skip missing log files as jboss may be comming up. 
          server_log = File.join(app_env[uuid][:OPENSHIFT_LOG_DIR], 'server.log')
          next if not File.exists?(server_log)

          File.open(server_log).grep(/ java.lang.OutOfMemoryError/) {|msg|
            # timezones are just a PITA. server.log message doesn't include timezone or date so inject both from today
            ts = DateTime.strptime(msg, '%Y/%m/%d %T')
            timestamp = DateTime.civil(ts.year, ts.month, ts.day, ts.hour, ts.min, ts.sec, epoch.zone)
            next if epoch > timestamp 

            cache_incident(uuid, timestamp, app_env)
          }
        end
      }
    rescue Exception => e
      @retries -= 1
      Syslog.warning("watchman caught #{e.inspect}: #{e.message}. Retries left: #{@retries}")
      retry if @daemon and 0 < @retries
      raise
    end while @daemon
  end
  
  # Exposed to be overridden by unit tests
  def now() DateTime.now end

  # Don't restart if application has been marked down
  def restart(uuid, env) 
    if env[uuid][:OPENSHIFT_GEAR_DIR].nil?
      Syslog.warning("watchman unable to determine application home directory. OPENSHIFT_GEAR_DIR/.env/OPENSHIFT_GEAR_DIR missing. User #{uuid}: application #{env[uuid][:OPENSHIFT_GEAR_NAME]} will not be restarted as it should be.")
      return
    end

    state_file = File.join(env[uuid][:OPENSHIFT_HOMEDIR], 'app', '.state')
    if File.exists?(state_file)
      state = File.read(state_file)
      if 'idle' != state && 'stopped' != state
        `service libra restartuser #{uuid}`
        Syslog.info("watchman restarted user #{uuid}: application #{env[uuid][:OPENSHIFT_GEAR_NAME]}") 
      end
    else
      stop_lock = File.join(env[uuid][:OPENSHIFT_GEAR_DIR], 'run', 'stop_lock')
      if not File.exists?(stop_lock) 
        `service libra restartuser #{uuid}`
        Syslog.info("watchman restarted user #{uuid}: application #{env[uuid][:OPENSHIFT_GEAR_NAME]}") 
      end
    end
  end

  private
  def cache_incident(uuid, timestamp, env)
    if @incidents.has_key?(uuid) 
      if @incidents[uuid][:last_updated] < timestamp
        # Repeat death. Should there be an additional delay here?
        restart(uuid, env)
        @incidents[uuid] = {:last_updated => timestamp}
      end
    else
      # First death. Restart and move on...
      restart(uuid, env)
      @incidents[uuid] = {:last_updated => timestamp}
    end
  end

  # Load environment variables into a hash
  def read_env(path)
    env = {}
    Dir["#{path}/.env/*"].each { |f|
      contents = nil
      File.open(f) {|input|
        contents = input.read.chomp
        index = contents.index('=')
        contents = contents[(index + 1)..-1]
        contents = contents[/'(.*)'/, 1] if contents.start_with?("'")
        contents = contents[/"(.*)"/, 1] if contents.start_with?('"')
      }
      env[File.basename(f).intern] =  contents
    }
    env
  end

  # Make current process a daemon
  def daemon()
    if '1.9' <= RUBY_VERSION
      Process.daemon
    else
      Syslog.warning('Fork from parent process failed') if (pid = fork) == -1
      exit unless pid.nil?

      Process.setsid
      Syslog.warning('Fork from process leader failed') if (pid = fork) == -1
      exit unless pid.nil?

      Dir.chdir '/'
      File.umask 0000

      STDIN.reopen '/dev/null'
      STDOUT.reopen '/dev/null', 'a'
      STDERR.reopen STDOUT
    end

    File.open("/var/run/#{File.basename($0)}.pid", 'w') {|f| f.puts(Process.pid)}
  end
end

if __FILE__ == $0
  raise 'Must run as root' if Process.euid != 0
  Watchman.new().run
end

