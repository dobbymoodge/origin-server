#!/usr/bin/python -tt

import sys, os
import syslog
import pwd
import syslog
import glob
import base64

commands = {
    "git-receive-pack": "/usr/bin/git-receive-pack",
    "git-upload-pack": "/usr/bin/git-upload-pack",
    "snapshot": "snapshot.sh",
    "restore": "restore.sh",
    "tail": "/usr/bin/tail",
    "rhcsh": "/bin/bash",
    "true": "/bin/true",
    "java": "/bin/bash",
    "scp": "/bin/bash",
    "cd": "/bin/bash",
    "set": "/bin/bash",
    "mkdir": "/bin/bash",
    "test": "/bin/bash",
    "rsync": "/bin/bash"
}

#
# Read in environment variables
#
def read_env_vars():
#    os.putenv
    for env in os.listdir(os.path.expanduser('~/.env/')):
        fp = open(os.path.expanduser('~/.env/') + env, 'r')
        env_var = fp.readlines()[0].strip().split('=')[1].strip('\'"')
        fp.close()
        os.putenv(env, env_var)

def openshift_mcs_level(uid):
    setsize=1023
    ord = uid
    tier = setsize
    while ord > tier:
        ord -= tier
        tier -= 1
    tier = setsize - tier
    return "c%d,c%d" % (tier, ord + tier)

#
# Join the user's cgroup if available
#
def join_cgroup():
    """
    Determine a user's cgroup and join it if possible
    """

    username = pwd.getpwuid(os.getuid())[0]
    pid = os.getpid()

    cgroup_root = "/cgroup/all/libra"
    cgroup_user = os.path.join(cgroup_root, username)
    cgroup_tasks = os.path.join(cgroup_user, "tasks")

    syslog.syslog("user %s: putting process %d in cgroup %s" % (username, pid, cgroup_root))

    if not os.path.isdir(cgroup_root):
        # raise an exception
        return

    if not os.path.isdir(cgroup_user):
        # raise an exception
        return

    if not os.path.isfile(cgroup_tasks):
        # raise an exception
        return 

    # try:
    taskfile = open(cgroup_tasks, 'w')
    taskfile.write(str(pid) + "\n")
    taskfile.flush()
    taskfile.close()
    # except IOError, e:
    #    write "can't join cgroup" message

if __name__ == '__main__':
    # first self-apply restrictions
    join_cgroup()
    read_env_vars()

    orig_cmd = os.environ.get('SSH_ORIGINAL_COMMAND')
    syslog.syslog(orig_cmd)
    if not orig_cmd:
        print "Need a command"
        sys.exit(1)
    allargs = orig_cmd.split()
    try:
        basecmd = os.path.basename(allargs[0])
        cmd = commands[basecmd]
    except:
        syslog.syslog("Invalid command %s" % orig_cmd)
        sys.stderr.write("Invalid command %s" % orig_cmd)
        sys.exit(2)
    if basecmd in ('snapshot',):
        # This gets called with "snapshot"
        allargs = []
    if basecmd in ('restore',):
        # This gets called with "restore <INCLUDE_GIT>"
        include_git = False
        if len(allargs) > 1 and allargs[1] == 'INCLUDE_GIT':
            include_git = True

        allargs = [] 
        if include_git:
            allargs.append('INCLUDE_GIT')
    elif basecmd in ('rhcsh',):
        os.environ["PS1"] = "rhcsh> "
        allargs = ['--init-file', '/usr/local/bin/rhcsh', '-i']
    elif basecmd in ('java','set','scp', 'cd', 'test', 'mkdir', 'rsync'):
        str = ' '.join(allargs)
        allargs = ['-c', str]
    elif basecmd in ('tail',):
        files = []
        
        files_start_index = 1
        args = []
        add_follow = True
        if allargs[1] == '--opts':
            files_start_index = 3
            args_str = base64.standard_b64decode(allargs[2])
            args = args_str.split()
            for arg in args:
                if arg.startswith(('..', '/')):
                    print "All paths must be relative: " + arg
                    sys.exit(88)
                elif arg == '-f' or arg == '-F' or arg.startswith('--follow'):
                    add_follow = False

        for glob_list in allargs[files_start_index:]:
            for f in glob.glob(glob_list):
                try:
                    if f.find('..') != -1 or f.startswith('/'):
                        print "invalid character"
                        sys.exit(91)
                    elif os.path.islink(f):
                        print "Links not supported"
                        sys.exit(94)
                    elif os.getuid() != os.stat(f).st_uid:
                        print "Not your file"
                        sys.exit(87)
                    else:
                        files.append(f)
                except OSError, e:
                    print "Error: %s" % e.strerror
                    sys.exit(91)
        if len(files) == 0:
            print "Could not find any files matching glob"
            sys.exit(32)
        allargs = []
        allargs.extend(args)
        if add_follow:
            allargs.append('-f')
        allargs.extend(files)
    elif basecmd in ('git-receive-pack', 'git-upload-pack'):
        # git repositories need to be parsed specially
        thearg = ' '.join(allargs[1:])
        if thearg[0] == "'" and thearg[-1] == "'":
            thearg = thearg.replace("'","")
        thearg = thearg.replace("\\'", "")
        thearg = thearg.replace("//", "/")

        # replace leading tilde (~) with user's home path
        realpath = os.path.expanduser(thearg)
        if not realpath.startswith('/var/lib/libra/'):
            syslog.syslog("Invalid repository: not in libra_root - %s: (%s)" % 
                          (thearg, realpath))
            print "Invalid repository %s: not in libra_root" % thearg
            sys.exit(3)

        if not os.path.isdir(realpath):
            syslog.syslog("Invalid repository %s (%s)" % 
                          (thearg, realpath))
            print "Invalid repository %s: not a directory" % thearg
            sys.exit(3)


        allargs = [thearg]
    runcon = '/usr/bin/runcon'
    mcs_level = openshift_mcs_level(os.getuid())

    context = 'unconfined_u:system_r:libra_t:s0:%s' % mcs_level
    os.execv(runcon, [runcon, context, cmd] + allargs)
    sys.exit(1)

