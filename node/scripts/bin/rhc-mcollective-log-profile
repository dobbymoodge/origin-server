#!/usr/bin/env ruby

#
# Read mcollective log on stdin, measure calls and report back a
# calling profile.
#
# Stderr will show each call as its processed (time in ms)
#
# Stdout will show the profile summary
#
# ex: Follow the log through a single transaction
# tail -f /var/log/mcollective.log | rhc-mcollective-log-profile
# (and hit ctrl-c when done)
#
# ex: Parse a whole log
# rhc-mcollective-log-profile < /var/log/mcollective.log
#

require 'rubygems'
require 'date'
require 'optparse'

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: rhc-mcollective-log-profile [options] < mcollective.log"

  options[:verbose] = false
  opts.on( '-v', '--[no-]verbose', 'Output per call measurements' ) do |v|
    options[:verbose] = true
  end


  options[:start] = false
  opts.on( '-s', '--start TIME', 'Parse events starting no earlier than this time' ) do |ts|
    options[:start]=DateTime.parse(ts)
  end

  options[:end] = false
  opts.on( '-e', '--end TIME', 'Parse events ending no later than this time' ) do |ts|
    options[:end]=DateTime.parse(ts)
  end

  opts.on_tail( '-h', '--help', 'Show help text' ) do
    puts opts
    exit
  end
end.parse!


profile={}
ncalls={}

start_time=nil
action_type=nil
action_call=[]
action_cart=[]
nactions=0

begin
  while line=STDIN.gets do
    if line =~ /^D, \[(.*) \#\d+\] DEBUG .* (\w+) call \/ request =/
      start_time=DateTime.parse(Regexp.last_match[1]).strftime('%Q').to_i
      if start_time < options[:start]
        action_type=Regexp.last_match[2]
      else
        start_time = nil
      end
      action_call=[]
      action_cart=[]
      nactions=0
    elsif line =~ /:action=>"(.*)"/
      action_call << Regexp.last_match[1]
      nactions = nactions + 1
    elsif line =~ /:cartridge=>"(.*)"/
      action_cart << Regexp.last_match[1]
    elsif line =~ /^D, \[(.*) \#\d+\] DEBUG .* (\w+) (?: ERROR )*\(\d+\)/
      end_time=DateTime.parse(Regexp.last_match[1]).strftime('%Q').to_i
      end_action_type=Regexp.last_match[2]
      nactions = nactions - 1

      if nactions == 0
        if not start_time.nil?
          duration = (end_time - start_time)/action_cart.length.to_f

          while action_cart.length > 0
            profname = "#{action_cart.pop} #{action_call.pop}"

            if profile[profname].nil?
              profile[profname]=duration
            else
              profile[profname]=profile[profname]+duration
            end

            if ncalls[profname].nil?
              ncalls[profname]=1
            else
              ncalls[profname]=ncalls[profname]+1
            end

            $stderr.puts "#{action_type}: #{duration} : #{profname}" if options[:verbose]
          end
        end
        start_time=nil
        action_type=nil
      end
    end
  end
rescue Interrupt
end


printf("\n")
printf("%8s: %6s: %8s: %s\n", "tot msec", " calls", "   avg  ", "      action        ")
printf("%8s: %6s: %8s: %s\n", "--------", "------", "--------", "--------------------")
sprof=profile.sort_by {|key, value| value}
sprof.reverse.each do |pair|
  printf("%8d: %6d: %8d: %s\n", pair[1], ncalls[pair[0]], pair[1]/ncalls[pair[0]], pair[0])
end
