#!/bin/bash
#
# libra         This shell script starts libra services
#
# Author:       Seth Vidal <skvidal@phy.duke.edu>
#               Mike McGrath <mmcgrath@redhat.com>
#
# chkconfig:    345 90 01
#
# description:  Start local libra services
# processname:  NA
#

# source function library
. /etc/rc.d/init.d/functions
id -Z
#set -x

# A function to start a program.
# This version of daemon overrides the one in /etc/init.d/functions and
# starts apps with su, this does pam processing and allows pam_namesapce
# to function properly
daemon() {
    # Test syntax.
    local gotbase= force= nicelevel corelimit
    local pid base= user= nice= bg= pid_file=
    local cgroup=
    nicelevel=0
    while [ "$1" != "${1##[-+]}" ]; do
      case $1 in
        '')    echo $"$0: Usage: daemon [+/-nicelevel] {program}"
               return 1;;
        --check)
           base=$2
           gotbase="yes"
           shift 2
           ;;
        --check=?*)
           base=${1#--check=}
           gotbase="yes"
           shift
           ;;
        --user)
           user=$2
           shift 2
           ;;
        --user=?*)
               user=${1#--user=}
           shift
           ;;
        --pidfile)
           pid_file=$2
           shift 2
           ;;
        --pidfile=?*)
           pid_file=${1#--pidfile=}
           shift
           ;;
        --force)
           force="force"
           shift
           ;;
        [-+][0-9]*)
           nice="nice -n $1"
           shift
           ;;
        *)     echo $"$0: Usage: daemon [+/-nicelevel] {program}"
               return 1;;
      esac
    done

        # Save basename.
        [ -z "$gotbase" ] && base=${1##*/}

        # See if it's already running. Look *only* at the pid file.
    __pids_var_run "$base" "$pid_file"

    [ -n "$pid" -a -z "$force" ] && return

    # make sure it doesn't core dump anywhere unless requested
    corelimit="ulimit -S -c ${DAEMON_COREFILE_LIMIT:-0}"

    # if they set NICELEVEL in /etc/sysconfig/foo, honor it
    [ -n "${NICELEVEL:-}" ] && nice="nice -n $NICELEVEL"
    
    # if they set CGROUP_DAEMON in /etc/sysconfig/foo, honor it
    if [ -n "${CGROUP_DAEMON}" ]; then
        if [ ! -x /bin/cgexec ]; then
            echo -n "Cgroups not installed"; warning
            echo
        else
            cgroup="/bin/cgexec";
            for i in $CGROUP_DAEMON; do
                cgroup="$cgroup -g $i";
            done
        fi
    fi

    # Echo daemon
        [ "${BOOTUP:-}" = "verbose" -a -z "${LSB:-}" ] && echo -n " $base"

    # And start it up.
    if [ -z "$user" ]; then
       $cgroup $nice /bin/bash -c "$corelimit >/dev/null 2>&1 ; $*"
    else
       $cgroup $nice /bin/su $user -c "$corelimit >/dev/null 2>&1 ; $*"
    fi

    [ "$?" -eq 0 ] && success $"$base startup" || failure $"$base startup"
}


lockfile=/var/lock/subsys/libra

function libra_users() {
    grep ":libra guest:" /etc/passwd | cut -d: -f1
}

#
# Given a username, get the home directory
#
function homedir() {
    # USERNAME=$1
    grep "^$1:" /etc/passwd | cut -d: -f 6
}

function userapps() {
    # USERNAME=$1
    /bin/find `homedir $1` -maxdepth 2 -mindepth 2 -type f -name "*_ctl.sh" 2> /dev/null
}

function apptype() {
    # USERNAME=$1
    # APPNAME=$2
    _HOMEDIR=`homedir $1`
    _APP_TYPE=`cat $_HOMEDIR/git/${2}.git/description | cut -d' ' -f 1`
    echo $_APP_TYPE
}

RETVAL=0
GROUP_RETVAL=0

# UGLY HACK, fix this later
if ! ( runcon | grep -q s0-s0:c0.c1023 )
then
    echo 1>&2
    echo "ERROR: incorrect selinux range - please rerun with:" 1>&2
    echo "runcon -l s0-s0:c0.c1023 $0" 1>&2
    echo 1>&2
    exit 243
fi

startuser() {
    # USERNAME=$1
    for APPNAME in `userapps $1`
    do
        startapp $1 $APPNAME
    done
}

stopuser() {
    # USERNAME=$1
    for APPNAME in `userapps $1`
    do
        stopapp $1 $APPNAME
    done
}


startapp() {
    # USERNAME=$1
    # APPSCRIPT=$2
    uid=$(id -u "$1")
    c_val="c$(($uid/1023)),c$(($uid%1023))"
    echo -n $"    Start: $1-$(basename $2)"
    daemon --user="$1" --pidfile=httpd_$1-$(basename $2) runcon -t libra_t -l s0:$c_val $2 start
    RETVAL=$?
    echo
    if [ $RETVAL -eq 0 ]
    then
        echo_success
    else
        GROUP_RETVAL=$(($GROUP_RETVAL+1))
        echo_failure
    fi
}

stopapp() {
    # USERNAME=$1
    # APPSCRIPT=$2
    uid=$(id -u "$1")
    c_val="c$(($uid/1023)),c$(($uid%1023))"
    echo -n $"    Stop: $1-$(basename $2)"
    daemon --user="$1" --pidfile=httpd_$1-$(basename $2) runcon -t libra_t -l s0:$c_val $2 stop
    RETVAL=$?
    echo
    if [ $RETVAL -eq 0 ]
    then
        echo_success
    else
        GROUP_RETVAL=$(($GROUP_RETVAL+1))
        echo_failure
    fi
}

start() {
    echo "Starting Libra Services: "

    for USERNAME in `libra_users`
    do
        startuser $USERNAME
    done
    [ $GROUP_RETVAL -eq 0 ] && touch ${lockfile}
    [ $GROUP_RETVAL -eq 0 ] && success || failure
    echo -n $"Libra services started"
    echo
    return $GROUP_RETVAL
}

stop() {
    echo "Stopping Libra Services: "
    for USERNAME in `libra_users`
    do
        stopuser $USERNAME
    done
    [ $GROUP_RETVAL -eq 0 ] && touch ${lockfile}
    echo -n $"Libra services stopped"
    echo
    return $GROUP_RETVAL
}

restart() {
    stop
    start
}

case "$1" in
  start)
    start
    ;;
  stop) 
    stop
    ;;
  restart|force-reload)
    restart
    ;;
  reload)
    ;;
  condrestart)
    [ -f "$lockfile" ] && restart
    ;;
  status)
    echo "Checking Libra Services: "

    # check for $1 (user) and $2 (appname)
    # This won't scale forever, but works fine in the '100 or so' range
    for ctl_script in `/bin/find /var/lib/libra/ -maxdepth 3 -mindepth 3 -type f -name "*_ctl.sh"`
    do
        script_name=$(basename $ctl_script)
        run_as=$( echo $ctl_script | awk -F/ '{print $5}')
        echo -n $"    Checking http for ${script_name%_ctl.sh}"
        uid=$(id -u "$run_as")
        c_val="c$(($uid/1023)),c$(($uid%1023))"
        daemon --user=$run_as --pidfile=httpd_${script_name} runcon -t libra_t -l s0:$c_val $ctl_script status
        RETVAL=$?
        echo
        if [ $RETVAL -eq 0 ]
        then
            echo_success
        else
            GROUP_RETVAL=$(($GROUP_RETVAL+1))
            echo_failure
        fi
    done
    echo
    #return $GROUP_RETVAL
    ;;

  startuser)
    startuser $2
    ;;

  stopuser)
    stopuser $2
    ;;

  restartuser)
    stopuser $2
    startuser $2
    ;;

  startapp)
    startapp $2 $3 
    ;;

  stopapp)
    stopapp $2 $3
    ;;

  restartapp)
    stopapp $2 $3
    startapp $2 $3
    ;;

  *)
    echo $"Usage: $0 {start|stop|status|restart|reload|force-reload|condrestart}"
    exit 1
esac

exit $RETVAL
