function start_app {
    runuser --shell /bin/sh "$uuid" -c "runcon -t libra_t -l $mcs_level $APP_DIR/${application}_ctl.sh start" || error "Failed to start ${application}" 121
}

function stop_app {
    runuser --shell /bin/sh "$uuid" -c "runcon -t libra_t -l $mcs_level $APP_DIR/${application}_ctl.sh stop" || echo "Failed to stop ${application}" 1>&2
}

function create_standard_env_vars {
    echo "export OPENSHIFT_APP_DIR='$APP_DIR/'" > $APP_HOME/.env/OPENSHIFT_APP_DIR
    echo "export OPENSHIFT_LOG_DIR='$APP_DIR/logs/'" > $APP_HOME/.env/OPENSHIFT_LOG_DIR
    echo "export OPENSHIFT_DATA_DIR='$APP_DIR/data/'" > $APP_HOME/.env/OPENSHIFT_DATA_DIR
    echo "export OPENSHIFT_TMP_DIR='/tmp/'" > $APP_HOME/.env/OPENSHIFT_TMP_DIR
    echo "export OPENSHIFT_RUN_DIR='$APP_DIR/run/'" > $APP_HOME/.env/OPENSHIFT_RUN_DIR
    echo "export OPENSHIFT_APP_NAME='$application'" > $APP_HOME/.env/OPENSHIFT_APP_NAME
    echo "export OPENSHIFT_APP_TYPE='$app_type'" > $APP_HOME/.env/OPENSHIFT_APP_TYPE
}

function create_standard_network_env_vars {
    echo "export OPENSHIFT_INTERNAL_IP='$IP'" > $APP_HOME/.env/OPENSHIFT_INTERNAL_IP
    echo "export OPENSHIFT_INTERNAL_PORT='8080'" > $APP_HOME/.env/OPENSHIFT_INTERNAL_PORT
    echo "export OPENSHIFT_APP_CTL_SCRIPT='$APP_DIR/${application}_ctl.sh'" > $APP_HOME/.env/OPENSHIFT_APP_CTL_SCRIPT
    echo "export OPENSHIFT_APP_DNS='${application}-${namespace}.${libra_domain}'" > $APP_HOME/.env/OPENSHIFT_APP_DNS
}

function create_standard_redo_dir_env_var {
    echo "export OPENSHIFT_REPO_DIR='$APP_DIR/repo/'" > $APP_HOME/.env/OPENSHIFT_REPO_DIR
}

function create_standard_path_env_var {
    echo "export PATH=$CART_INFO_DIR/bin/:$CART_DIR/abstract-httpd/info/bin/:$CART_DIR/li-controller/info/bin/:$PATH" > $APP_HOME/.env/PATH
}

function create_standard_app_dirs {
	mkdir run tmp data
}

# Create simple application start / stop script
function create_app_ctl_script {

    cat <<EOF > "$APP_DIR/${application}_ctl.sh"
#!/bin/bash -e

# Import Environment Variables
for f in ~/.env/*
do
    . \$f
done

app_ctl.sh \$1
EOF

chmod +x "$APP_DIR/${application}_ctl.sh" || error "Failed to chmod new application scripts" 122
chown root.root "$APP_DIR/${application}_ctl.sh"

}

function secure_app_dir {
    chown $user_id.$group_id -R $APP_DIR || error "Failed to chown new application space.  Please contact support" 123
    chown root.root "$APP_DIR"
}

function secure_conf_dirs {
    chown root:root -R "$APP_DIR/conf" "$APP_DIR/conf.d"
}

function chcon_app_dir_and_git {
    chcon -t libra_var_lib_t -l $mcs_level -R "$APP_HOME/git/" "$APP_DIR"
}

function check_app_dir_doesnt_exist {
    if [ -d "$APP_DIR" ] 
    then
        error "${application}.  Please destroy then recreate, or pick a new name: $APP_DIR" 132
    fi
}

function check_app_dir_exists {
    if [ ! -d "$APP_DIR" ]
    then
        error "${application}.  Application directory doesn't exist:  $APP_DIR" 125
    fi
}

function load_node_conf {
    if [ -f '/etc/libra/node.conf' ]
    then
        . /etc/libra/node.conf
    elif [ -f 'node.conf' ]
    then
        . node.conf
    else
        echo "node.conf not found.  Cannot continue" 1>&2
        exit 3
    fi
}

function load_node_data_conf {
    if [ -f '/etc/libra/node_data.conf' ]
    then
        . /etc/libra/node_data.conf
    elif [ -f 'node_data.conf' ]
    then
        . node_data.conf
    else
        echo "node_data.conf not found.  Cannot continue" 1>&2
        exit 3
    fi
}

function load_resource_limits_conf {
    if [ -f '/etc/libra/resource_limits.conf' ]
    then
        . /etc/libra/resource_limits.conf
    fi
}

function generate_password {
    head -n 500 /dev/urandom|tr -dc "a-np-zA-NP-Z1-9-_"|fold -w 12 | head | head -n1
}

function obfuscate_password {
    password="$1"
    java -classpath "${APP_DIR}/data/war/WEB-INF/lib/acegi-security-1.0.5.jar:${APP_DIR}/data/war/WEB-INF/lib/commons-codec-1.4.jar:${CART_DIR}/jenkins-1.4/info/lib/password-encoder.jar" com.redhat.openshift.PasswordEncoder $password
}

function error {
    echo "$1" 1>&2
    exit "$2"
}

function warning {
    echo "$1" 1>&2
    #echo "$2"
}

function client_result {
    echo "CLIENT_RESULT: $1"
}

function client_message {
    echo "CLIENT_MESSAGE: $1"
}

function client_error {
    echo "CLIENT_ERROR: $1"
}

function client_debug {
    echo "CLIENT_DEBUG: $1"
}

function add_ssh_key {
    echo "SSH_KEY_ADD: $1"
}

function remove_ssh_key {
    echo "SSH_KEY_REMOVE: "
}

function add_env_var {
    echo "ENV_VAR_ADD: $1"
}

function remove_env_var {
    echo "ENV_VAR_REMOVE: $1"
}

function add_broker_auth_key {
    echo "BROKER_AUTH_KEY_ADD: "
}

function remove_broker_auth_key {
    echo "BROKER_AUTH_KEY_REMOVE: "
}

function setup_configure {
    source ${CART_DIR}/li-controller/info/lib/git
    source ${CART_DIR}/li-controller/info/lib/selinux
    source ${CART_DIR}/li-controller/info/lib/network
    source ${CART_DIR}/li-controller/info/lib/apache
	
    CART_INFO_DIR=$CART_DIR/$app_type/info
    CART_CONF_DIR=$CART_INFO_DIR/configuration/etc/conf

    load_node_conf

    load_node_data_conf

    load_resource_limits_conf

    application="$1"
    namespace=`basename $2`
    uuid=$3
		
    setup_basic_vars
	
    #
    # Get user id info
    # Not caching this information caused some early chowns to work but some later
    # chowns to fail with a user not found error
    user_id=$(id -u "$uuid") || error "Could not find user $uuid ($namespace)" 134
    group_id=$(id -g "$uuid") || error "Could not find user $uuid ($namespace)" 135

    export mcs_level
}

function setup_deconfigure {
    source ${CART_DIR}/li-controller/info/lib/selinux
    source ${CART_DIR}/li-controller/info/lib/git
    source ${CART_DIR}/li-controller/info/lib/apache

    load_node_conf

    load_node_data_conf

    namespace=`basename $2`
    application="$1"
    uuid=$3

    setup_basic_vars

    check_app_dir_exists
}

function setup_embedded_configure {
    source ${CART_DIR}/li-controller/info/lib/selinux
    source ${CART_DIR}/li-controller/info/lib/network
    source ${CART_DIR}/li-controller/info/lib/apache

    CART_INFO_DIR=$CART_DIR/embedded/$app_type/info
    CART_ETC_DIR=$CART_INFO_DIR/configuration/etc
    CART_CONF_DIR=$CART_INFO_DIR/configuration/etc/conf

    load_node_conf

    load_node_data_conf

    load_resource_limits_conf

    application="$1"
    namespace=$2 # Not used
    uuid=$3

    setup_basic_vars

    check_app_dir_exists

    user_id=$(id -u "$uuid") || error "Could not find user $uuid" 134
    group_id=$(id -g "$uuid") || error "Could not find user $uuid" 135
}

function setup_embedded_deconfigure {
    source ${CART_DIR}/li-controller/info/lib/selinux

    CART_INFO_DIR=$CART_DIR/embedded/$app_type/info

    load_node_conf

    load_node_data_conf

    application="$1"
    namespace=$2 # Not used
    uuid=$3

    setup_basic_vars

    check_app_dir_exists
}

function setup_basic_hook {
    source ${CART_DIR}/li-controller/info/lib/selinux

    load_node_conf

    uuid=`basename $3`
    application="$1"
    
    setup_basic_vars

    check_app_dir_exists
}

function setup_basic_vars {
    APP_HOME="$libra_dir/$uuid/"
    APP_DIR=`echo $APP_HOME/$application | tr -s /`

    uid=$(id -u "$uuid")
    mcs_level=`openshift_mcs_level $uid`
}

function rm_unobfuscated_app_home {
    # Check if unobfuscate is set in /etc/libra/node.conf
    # If it is set, remove symlink

    namespace=$1
    appname=$2

    if [ $unobfuscate -eq 1 ]
    then
        rm "${libra_dir}/${appname}-${namespace}"
    fi
}

function unobfuscate_app_home {
    # Check if unobfuscate is set in /etc/libra/node.conf
    # If it is set, symlink /var/lib/libra/uuid to /var/lib/libra/appname-namespace
    # This will allow easier debugging.

    uuid=$1
    namespace=$2
    appname=$3

    if [ $unobfuscate -eq 1 ]
    then
        if [ ! -f "${libra_dir}/$appname-$namespace" ] && [ ! -d "${libra_dir}/$appname-$namespace" ]
        then
            /bin/ln -sf "${libra_dir}/${uuid}" "${libra_dir}/${appname}-${namespace}"
        fi
    fi
}