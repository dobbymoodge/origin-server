#!/usr/bin/env oo-ruby

require 'rubygems'
require 'getoptlong'
require 'socket'

def usage
    puts <<USAGE
== Synopsis

rhc-admin-ctl-usage: Control usage

== Usage

rhc-admin-ctl-usage OPTIONS

Options:
--sync
    Sync usage with the billing vendor
--remove_sync_lock
    Remove existing sync lock
--list
    List usage available to be synced
-h|--help
    Show Usage info
USAGE
  exit 255
end

opts = GetoptLong.new(
    ["--remove_sync_lock",       GetoptLong::NO_ARGUMENT],
    ["--list",                   GetoptLong::NO_ARGUMENT],
    ["--sync",                   GetoptLong::NO_ARGUMENT],
    ["--help",             "-h", GetoptLong::NO_ARGUMENT]
)

args = {}
begin
  opts.each{ |k,v| args[k]=v }
rescue GetoptLong::Error => e
  usage
end

$sync = args["--sync"]
$list = args["--list"]
$remove_sync_lock = args["--remove_sync_lock"]

if args["--help"]
  usage
end

unless $sync || $list || $remove_sync_lock
  puts "You must --list or --sync or --remove_sync_lock"
  usage
end

require "/var/www/openshift/broker/config/environment"
# Disable analytics for admin scripts
Rails.configuration.analytics[:enabled] = false
$failures = []

def usage_record_to_billing_usage_type(billing_api, usage_record)
  billing_usage_type = nil
  
  case usage_record.usage_type
  when UsageRecord::USAGE_TYPES[:gear_usage]
    billing_usage_type = billing_api.usage_type[:gear][usage_record.gear_size.to_sym]
  when UsageRecord::USAGE_TYPES[:addtl_fs_gb]
    billing_usage_type = billing_api.usage_type[:storage][:gigabyte_hour]
  else
    raise "Usage type not supported: '#{usage_record.usage_type}'"
  end
end

def usage_time(billing_api, acct_no, usage_record, begin_time, end_time)
  if usage_record.sync_time
    found = false
    billing_usage_type = usage_record_to_billing_usage_type(billing_api, usage_record)
    if billing_usage_type
      usages = billing_api.get_usage_history(acct_no, billing_usage_type)
      usages.each do |usage|
        gear_id = usage["qualifier_1"]
        sync_time = usage["qualifier_2"]
        if usage_record.sync_time.to_i == sync_time.to_i && usage_record.gear_id == gear_id
          found = true
          break
        end
      end
      if found
        puts "WARNING: Usage data has already been sent to billing vendor but not removed from datastore usage.  Resetting begin_time to previous sync_time."
        begin_time = usage_record.sync_time
      else
        puts "WARNING: Billing vendor doesn't have the records.  Leaving begin_time from previous sync."
      end
    end
  end
  total_time = (end_time - begin_time) / 3600 # hours
  total_time
end

def get_billing_user_acct_no(billing_api, billing_user_id)
  puts "Aria userid: #{billing_user_id}"
  unless billing_api.userid_exists(billing_user_id)
    puts "User didn't exist"
    # Temporary code until users are created up front
    acct_no = billing_api.create_fake_acct(billing_user_id, :megashift)
  else
    acct_no = billing_api.get_acct_no_from_user_id(billing_user_id)
  end
  acct_no
end

def sync_usage(usage_records)
  # Check UsageRecord and Usage collection consistency for gears
  begin
    usage = Usage.find_by(gear_id: usage_records[0].gear_id)
  rescue Mongoid::Errors::DocumentNotFound
    puts "WARNING: Gear '#{usage_records[0].gear_id} not found in Usage collection."
    usage = Usage.new
    usage.login = usage_records[0].login
    usage.gear_id = usage_records[0].gear_id,
    usage.time = usage_records[0].time,
    usage.usage_type = usage_records[0].usage_type
    usage.gear_size = usage_records[0].gear_size
    usage.addtl_fs_gb = usage_records[0].addtl_fs_gb
    usage.save!
  end
  if (usage_records.length == 2) && usage
    unless usage.end_time
      puts "WARNING: End time not set for gear '#{usage_records[0].gear_id}'"
      usage.end_time = usage_records[1].time > usage.begin_time ? usage_records[1].time : usage.begin_time
      usage.save!
    end
  end

  # Get billing act# for the user
  billing_api = Express::AriaBilling::Api.new
  billing_user_id = Digest::MD5::hexdigest(usage_records[0].login)
  billing_acct_no = get_billing_user_acct_no(billing_api, billing_user_id)
    
  usage = nil
  begin_time = usage_records[0].time
  end_time = usage_records[1].time if usage_records.length == 2
  now = Time.now.utc
  end_time = now unless end_time
  end_time = begin_time if end_time < begin_time

  usage_record = usage_records.first
  puts "Collecting '#{usage_record.usage_type}' usage for gear: #{usage_record.gear_id}"
  ut = usage_time(billing_api, billing_acct_no, usage_record, begin_time, end_time)
  puts "Saving sync_time before sending usage data to billing vendor."
  usage_record.sync_time = now
  usage_record.save
  billing_usage_type = usage_record_to_billing_usage_type(billing_api, usage_record)
  success = false
  if billing_usage_type
    puts "Sending usage data (#{ut}h) to billing vendor."
    # Send data to billing vendor
    if billing_api.record_usage(usage_record.gear_id, usage_record.sync_time, billing_user_id, nil, billing_usage_type, ut)
      puts "Billing vendor returned success."
      success = true
    end
  else
    puts "Skipping billing for usage data (#{ut}h) of type: #{usage_record.usage_type}"
    success = true
  end
  if success
    if usage_records.length == 2
      puts "Deleting ended usage record"
      UsageRecord.where(login: usage_record.login, gear_id: usage_record.gear_id, usage_type: usage_record.usage_type).destroy
    else
      puts "Continuing usage record."
      usage_record.event = UsageRecord::EVENTS[:continue]
      usage_record.time = now
      usage_record.sync_time = nil
      usage_record.save!
    end
  else
    raise Exception.new "Billing vendor returned error for gear_id: #{usage_record.gear_id}, usage_type: #{usage_record.usage_type}"
  end
end

def list_usage(usage_records)
  # Get billing act# for the user
  billing_api = Express::AriaBilling::Api.new
  billing_user_id = Digest::MD5::hexdigest(usage_records[0].login)
  billing_acct_no = get_billing_user_acct_no(billing_api, billing_user_id)
    
  begin_time = usage_records[0].time
  end_time = usage_records[1].time if usage_records.length == 2
  now = Time.now.utc
  puts "Collecting '#{usage_records[0].usage_type}' usage for gear: #{usage_records[0].gear_id}"
  if end_time
    puts "Usage record ended."
  else
    puts "Usage record continued."
    end_time = now
  end
  end_time = begin_time if end_time < begin_time
  ut = usage_time(billing_api, billing_acct_no, usage_records[0], begin_time, end_time)
  puts "Usage to send to billing vendor: #{ut}h"
end

def process_usage_records(usage_records)
  return if usage_records.empty?
  user = usage_records[0].login
  gear_id = usage_records[0].gear_id
  puts "\n#################"
  puts "User: #{user}"
  puts "###################"

  begin
    # Sanitize usage records        
    if usage_records.length > 2
      raise Exception.new "Found more than 2 usage records for gear '#{gear_id}'. We expect only begin/continue and end records."
    elsif (usage_records.length == 2) && (usage_records[1].event != UsageRecord::EVENTS[:end])
      raise Exception.new "Found 2 usage records with no end marker for gear: #{gear_id}."
    elsif usage_records[0].event == UsageRecord::EVENTS[:end]
      raise Exception.new "Found usage records with no begin/continue marker for gear: #{gear_id}."
    elsif !usage_records[0].time
      raise Exception.new "Event time not set for begin/continue usage record for gear: #{gear_id}."
    end

    if $sync
      sync_usage(usage_records)
    elsif $list
      list_usage(usage_records)
    end
  rescue Exception => e
    puts e.message
    puts e.backtrace
    $failures << "ERROR:: Processing usage records for user #{user}: #{e.message}"
  end
end

if $remove_sync_lock
  DistributedLock.release_lock("sync_usage")
else
  hostname = Socket.gethostname
  if DistributedLock.obtain_lock("sync_usage", hostname)
    begin
      user_usage_records = []
      UsageRecord.asc(:gear_id).asc(:login).asc(:usage_type).asc(:time).each { |usage_record|
        if user_usage_records.empty? or
           ((user_usage_records[0].gear_id == usage_record.gear_id) && (user_usage_records[0].login == usage_record.login) && (user_usage_records[0].usage_type == usage_record.usage_type))
          user_usage_records << usage_record
          next if usage_record.event != UsageRecord::EVENTS[:end]
          process_usage_records(user_usage_records)
          user_usage_records = []
        else
          process_usage_records(user_usage_records)
          user_usage_records = [usage_record]
        end
      }
      process_usage_records(user_usage_records) unless user_usage_records.empty?

      unless $failures.empty?
        puts "******************FAILURES******************"
        $failures.each do |failure|
          puts failure
        end
        puts "****************END FAILURES****************"
      end
    ensure
      DistributedLock.release_lock("sync_usage", hostname)
    end
  else
    puts "Failed to obtain lock to interact with usage data"
    exit 1
  end
  puts "Done"
end
