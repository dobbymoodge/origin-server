#!/bin/sh
#
# libra-cgroups This shell script initializes libra control groups
#
# Author:       Seth Vidal <skvidal@phy.duke.edu>
#               Mike McGrath <mmcgrath@redhat.com>
#               Mark lamourine <markllama@redhat.com>
#
# chkconfig:    345 6 94
#
# description:  Create Libra user cgroups
# processname:  NA
#

# source function library
. /etc/rc.d/init.d/functions

# import libra cgroups settings
if [ -f /etc/sysconfig/libra-cgroups ]
then
    . /etc/sysconfig/libra-cgroups
fi

lockfile=/var/lock/subsys/libra-cgroups

if [ -f /etc/libra/node.conf ]
then
    . /etc/libra/node.conf
fi

if [ -f /etc/libra/resource_limits.conf ]
then
    . /etc/libra/resource_limits.conf
fi

RETVAL=0
GROUP_RETVAL=0

#
# Set defaults if not provided
#
LIBRA_CGROUP_ROOT=${LIBRA_CGROUP_ROOT:="/libra"}
LIBRA_CGROUP_SUBSYSTEMS=${LIBRA_CGROUP_SUBSYSTEMS:="cpu,cpuacct,memory,net_cls,freezer"}

CGROUP_RULES_FILE=${CGROUP_RULES_FILE:="/etc/cgrules.conf"}

CPU_VARS="rt_period_us rt_runtime_us shares"
MEM_VARS="limit_in_bytes memsw_limit_in_bytes soft_limit_in_bytes swappiness"

# Get a user's UID
function uid() {
    grep -e "^$1:" /etc/passwd | cut -d: -f3
}

# get a user's home directory
function homedir() {
    grep -e "^$1:" /etc/passwd | cut -d: -f6
}

# ============================================================================
#  Functions for setting the net class
# ============================================================================
#
# Convert a UID number into an selinux MCS pair
#
function mcs() {
    #       div           mod
    echo `expr $1 / 1023`:`expr $1 % 1023`
}

#
# Convert an MCS pair into a cgroup net class id
#
function netid() {
    echo -n 0x
    for COMPONENT in `echo $1 | tr : '\n'`
    do
	printf "%04x" $COMPONENT
    done
    echo
}

function set_net_cls() {
    # USERNAME=$1
    CGPATH=libra/$1
    USERID=`uid $1`
    USERMCS=`mcs $USERID`
    USERCLASSID=`netid $USERMCS`
    cgset -r net_cls.classid=$USERCLASSID $CGPATH
}

# ==========================================================================
#  Functions for tuning the user's CPU limits in cgroups
# ==========================================================================
CPUVARS="rt_period_us rt_runtime_us shares"
function set_cpu() {
    # USERNAME=$1
    CGPATH=libra/$1

    for VARNAME in $CPUVARS
    do
	# cgroups names can have periods(.)  shell varnames can't
	SAFENAME=`echo $VARNAME | tr . _`
	VALUE=`eval echo \\$cgroup_cpu_$SAFENAME`
	if [ -n "${VALUE}" ]
	then
	    # TODO: get per-app increments
	    cgset -r "cpu.$VARNAME=$VALUE" $CGPATH
	fi
    done
}

# ==========================================================================
#  Functions for tuning the user's memory limits in cgroups
# ==========================================================================
MEMVARS="limit_in_bytes memsw.limit_in_bytes soft_limit_in_bytes swappiness"
function set_memory() {
    # USERNAME=$1
    CGPATH=libra/$1

    # for each var get and set the value
    for VARNAME in $MEMVARS
    do
	# cgroups names can have periods(.)  shell varnames can't
	SAFENAME=`echo $VARNAME | tr . _`
	VALUE=`eval echo \\$cgroup_memory_$SAFENAME`
	if [ -n "${VALUE}" ]
	then
	    # TODO: get per-app increments
	    cgset -r "memory.$VARNAME=$VALUE" $CGPATH
	fi
    done
}

# ==========================================================================
#  Functions for tuning the user's memory limits in cgroups
# ==========================================================================
BLKIOVARS="weight weight_device"
function set_blkio() {
    # USERNAME=$1
    CGPATH=/$1

    # for each var get and set the value
    for VARNAME in $BLKIOVARS
    do
	# cgroups names can have periods(.)  shell varnames can't
	SAFENAME=`echo $VARNAME | tr . _`
	VALUE=`eval echo \\$cgroup_blkio_$SAFENAME`
	if [ -n "${VALUE}" ]
	then
	    # TODO: get per-app increments
	    # TODO: weight_device should really use the user's home device
	    #       and set the rest (if any) to 0
	    # cgset -r "blkio.$VARNAME=$VALUE" $CGPATH
	    echo nothing >>/dev/null
	fi
    done
}

# List the libra guest users
#
libra_users() {
    grep 'libra guest' /etc/passwd | cut -d: -f1
}

#
# Create a new libra user cgroup
#
add_cgroup() {
    # USERNAME=$1
    cgcreate -g ${LIBRA_CGROUP_SUBSYSTEMS}:${LIBRA_CGROUP_ROOT}/$1
}

#
# Delete a libra user cgroup
#
delete_cgroup() {
    # USERNAME=$1
    cgdelete ${LIBRA_CGROUP_SUBSYSTEMS}:${LIBRA_CGROUP_ROOT}/$1
}


#
# check which user cgroups exist
#
cgroup_user_subsystems() {
    # USERNAME=$1
    lscgroup | grep ":${LIBRA_CGROUP_ROOT}/$1\$" | cut -d: -f1
}

#
# Check that a group binding rule exists for a user
#
cgroup_rule_exists() {
    #USERNAME=$1
    # remove comments, get first field, match exactly, quiet
    grep -v '^#' ${CGROUP_RULES_FILE} | cut -f1 | grep -q -x $1
}


#
# Bind the user to the cgroup: update /etc/cgrules.conf and kick cgred
#
add_cgroup_rule() {
    # USERNAME=$1
    cat <<EOF >>${CGROUP_RULES_FILE}
$1	$LIBRA_CGROUP_SUBSYSTEMS	$LIBRA_CGROUP_ROOT/$1
EOF
}

#
# Unbind the user from any cgroup
#
delete_cgroup_rule() {
    # USERNAME=$1
    sed -i -e "/^$1\s/d" ${CGROUP_RULES_FILE}
}

startuser() {
    NEWUSER=$1

    echo -n "starting cgroups for $NEWUSER..."

    add_cgroup $NEWUSER
    if [ $? != 0 ]
    then
	RETVAL=$?
    fi

    set_cpu $NEWUSER
    set_memory $NEWUSER
    #set_blkio $NEWUSER
    set_net_cls $NEWUSER

    # CHECK: don't trust old rules
    if ( cgroup_rule_exists $NEWUSER )
    then
	delete_cgroup_rule $NEWUSER
    fi
    add_cgroup_rule $NEWUSER
    if [ $? != 0 ]
    then
	RETVAL=$?
    fi
	
    if [ $RETVAL -eq 0 ]
    then
        echo_success
    else
        GROUP_RETVAL=$(($GROUP_RETVAL+1))
        echo_failure
    fi
    echo
}


start() {
    echo "Initializing Libra guest control groups: "

    if !(service cgconfig status >/dev/null)
    then
       RETVAL=1
       GROUP_RETVAL=3
       echo "cgconfig service not running"

       return $GROUP_RETVAL
    fi

    # create the root of the libra user control group
    add_cgroup # defaults to creating the root group
    RETVAL=$?

    # This won't scale forever, but works fine in the '100 or so' range
    for USERNAME in `libra_users`
    do
	startuser $USERNAME
    done

    # kick the Cgroups rules daemon
    service cgred reload

    [ $GROUP_RETVAL -eq 0 ] && touch ${lockfile}
    [ $GROUP_RETVAL -eq 0 ] && success || failure

    echo -n $"Libra cgroups initialized"
    echo
    return $GROUP_RETVAL
}


stopuser() {
    DELUSER=$1
    echo -n "stopping cgroups for $DELUSER..."

    # kill any processes owned by these users
    pkill -u $DELUSER
    
    # remove the user's cgroup
    delete_cgroup $DELUSER
    if [ $? != 0 ]
    then
	RETVAL=$?
    fi
    
    # remove the user's cgroup binding rule
    delete_cgroup_rule $DELUSER
    if [ $? != 0 ]
    then
	RETVAL=$?
    fi

    if [ $RETVAL -eq 0 ]
    then
        echo_success
    else
        GROUP_RETVAL=$(($GROUP_RETVAL+1))
        echo_failure
    fi
}

stop() {
    echo "Removing Libra guest control groups: "

    if !(service cgconfig status >/dev/null)
    then
       RETVAL=1
       GROUP_RETVAL=3
       echo "cgconfig service not running"

       return $GROUP_RETVAL
    fi

    # This won't scale forever, but works fine in the '100 or so' range
    for USERNAME in `libra_users`
    do
	stopuser $USERNAME
    done

    # notify the cgroup rule daemon
    service cgred reload

    # remove the libra root cgroup
    delete_cgroup

    if [ $RETVAL -eq 0 ]
    then
        echo_success
    else
        GROUP_RETVAL=$(($GROUP_RETVAL+1))
        echo_failure
    fi

    [ $GROUP_RETVAL -eq 0 ] && touch ${lockfile}
    echo -n $"Libra cgroups uninitialized"
    echo
    return $GROUP_RETVAL
}

restart() {
    stop
    start
}

status() {
    echo "Checking Libra Services: "

    if [ -z "$1" ]
    then
	USERLIST=`libra_users`
    else
        USERLIST=$1
    fi

    # check that the /libra cgroup exists

    # This won't scale forever, but works fine in the '100 or so' range
    #  would be easy to convert to a 'in `find...`'     jj
    for USERNAME in $USERLIST
    do
	# check that /libra/<username> exists
	SUBSYSTEMS=`cgroup_user_subsystems`
	if ( cgroup_rule_exists $USERNAME )
        then
	    RETVAL=0
            BOUND="BOUND"
        else
	    RETVAL=1
            BOUND="UNBOUND"
        fi

	echo -n "${USERNAME}: $BOUND	" `echo $SUBSYSTEMS | tr ' ' ,`
	# check that cgrule exists

        if [ $RETVAL -eq 0 ]
        then
            echo_success
        else
            GROUP_RETVAL=$(($GROUP_RETVAL+1))
            echo_failure
        fi
	echo
    done
    return $GROUP_RETVAL
}


case "$1" in
  start)
    start
    ;;

  stop) 
    stop
    ;;

  restart|force-reload|reload)
    restart
    ;;

  condrestart)
    [ -f "$lockfile" ] && restart
    ;;

  status)
    status $2
    ;;

  startuser)
    if (service cgconfig status >/dev/null)
    then
	startuser $2
	service cgred reload
    else
	RETVAL=1
	echo "cgconfig service not running"
    fi
    ;;

  stopuser)
    if (service cgconfig status >/dev/null)
    then
	stopuser $2
	service cgred reload
    else
	RETVAL=1
	echo "cgconfig service not running"
    fi
    ;;

  *)
    echo $"Usage: $0 {start|stop|status|restart|reload|force-reload|condrestart|startuser <username>|stopuser <username>}"
    exit 1
esac

exit $RETVAL
