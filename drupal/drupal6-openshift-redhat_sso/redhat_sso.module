<?php
// $Id$

/**
 * @file
 * redhat_sso.module
 *
 * Connects Drupal to RedHat Streamline SSO service as a standard
 * login background.  Tracks the Streamline rhlogin value as 
 * profile_rhlogin on the user's profile_values table.
 *
 */

function redhat_sso_menu() {
  $items = array(
  );
  return $items;
}

/*
 * Change user/register and user/password to be simple menu hooks 
 * (so they can redirect) and so they don't show up as tabs on the
 * login page (MENU_CALLBACK).
 */
function redhat_sso_menu_alter(&$items) {
  $items['user']['type'] = MENU_CALLBACK;
  $items['user']['title callback'] = '_redhat_sso_title_page_user';
  $items['user/register']['type'] = MENU_CALLBACK;
  $items['user/register']['access callback'] = TRUE;
  $items['user/register']['page callback'] = '_redhat_sso_page_register';
  $items['user/password']['type'] = MENU_CALLBACK;
  $items['user/password']['access callback'] = TRUE;
  $items['user/password']['page callback'] = '_redhat_sso_page_password';
  $items['logout']['type'] = MENU_CALLBACK;
  $items['logout']['access callback'] = TRUE;
  $items['logout']['page callback'] = 'redhat_sso_logout';
}

function redhat_sso_logout() {
  global $user;

  watchdog('user', 'Session closed for %name.', array('%name' => $user->name));

  // Destroy the current session:
  session_destroy();
  // Only variables can be passed by reference workaround.
  $null = NULL;
  user_module_invoke('logout', $null, $user);

  // Load the anonymous user
  $user = drupal_anonymous_user();

  watchdog('user', 'Redirecting to %url.', array('%url' => redhat_sso_logout_url()));
  _redhat_sso_redirect(redhat_sso_logout_url());
}

function _redhat_sso_title_page_user() {
  global $user;
  return t($user->uid == 0 ? 'Log In to the Community' : 'My Community Account');
}

function redhat_sso_server_url() {
  $url = variable_get('redhat_sso_host_url', NULL);
  if (!isset($url)) {
    $url = parse_url($GLOBALS['base_url']);
    $url = $url['scheme'].'://'.$url['host'];
  }
  return $url;
}

function redhat_sso_change_password_url() {
  return redhat_sso_server_url() . variable_get('redhat_sso_change_password_uri', '/app/account/password/new');
}
function redhat_sso_register_url() {
  return redhat_sso_server_url() . variable_get('redhat_sso_register_uri', '/app/account/new');
}
function redhat_sso_logout_url() {
  global $base_url;
  return redhat_sso_server_url() . variable_get('redhat_sso_logout_uri', '/app/logout') . '?then='.$base_url;
}

/*
 * Redirect the user from user/register and user/password to the 
 * configured OpenShift pages.
 */
function _redhat_sso_page_password() {
  _redhat_sso_redirect(redhat_sso_change_password_url());
}
function _redhat_sso_page_register() {
  _redhat_sso_redirect(redhat_sso_register_url());
}

/*
 * Override user_page to redirect the user from user/login to user (so 
 * they won't receive an error after login).
 */
function _redhat_sso_page_user() {
  global $user;
  if ($user->uid) {
    menu_set_active_item('user/' . $user->uid);
    return menu_execute_active_handler();
  }
  else if ($_GET['q'] == 'user/login') {
    drupal_goto('user');
    exit;
  }
  else {
    return drupal_get_form('user_login');
  }
}

/*
 * Ensure that the user cannot see their password form on the profile.
 */
function redhat_sso_form_alter( &$form, $form_state, $form_id ) {
  if ($form_id == 'user_login') {
    $items = array();
    unset($form['links']);
  }

  // Remove pass field from user edit form if he cant change
  else if ($form_id == 'user_profile_form') {
    $form['account']['current_pass']['#access'] = false;
    $form['account']['pass']['#access'] = false;
  }
}

/*
 * Hook the user login form and provide custom validation.
 */
function redhat_sso_form_user_login_alter( &$form, $form_state ) {
  if (!variable_get('redhat_sso_enabled', FALSE)) {
    return;
  }
  unset($form['links']);
  $form['#validate'] = array( 
    /* skip default name validation from Drupal */
    'redhat_sso_login_validate', // Handles standard flow
    'user_login_final_validate'  // Displays error if no user authed
  );
}
function redhat_sso_form_user_login_block_alter( &$form, $form_state ) {
  return redhat_sso_form_user_login_alter($form, $form_state);
}

/*
 * Implement a customization of user_login_validate specific to 
 * OpenShift.  Performs an authentication to retrieve the rhlogin.
 * If authenticated, search for an existing UID and do the standard
 * blocked/invalid password checks.  Finally, register or load the
 * user and call finalize to establish the session.
 */
function redhat_sso_login_validate( $form, &$form_state ) {
  $name = $form_state['values']['name'];

  if (isset($name)) {
    $rhlogin = _redhat_sso_authenticate($name, $form_state['values']['pass']);

    if (isset($rhlogin)) {
      $uid = _redhat_sso_uid_for_login($name);

      if (_redhat_sso_user_is_blocked($uid)) {
        // blocked in user administration
        form_set_error('name', t('The username %name has not been activated or is blocked.', array('%name' => $name)));
      }
      else if (drupal_is_denied('user', $name)) {
        // denied by access controls
        form_set_error('name', t('The name %name is a reserved username.', array('%name' => $name)));
      }

      if (_redhat_sso_external_login_register($uid, $rhlogin, 'redhat_sso')) {
        user_authenticate_finalize( $form_state['values'] );
      }
    }
  }
}

/*
 * Subclass user_external_login_register to allow us to set a custom mail 
 * address, perform a unique name insertion if there are conflicts, and
 * insert the proper RHLogin after the user accesses the system.
 *
 * If the profile_values insert fails the user will not be able to log in
 * on subsequent attempts.
 */
function _redhat_sso_external_login_register($existing_uid, $rhlogin, $module) {
  global $user;

  if (isset($existing_uid)) {
    $existing_user = user_load(array('uid' => $existing_uid));
  }
  if ($existing_user && isset($existing_user->uid)) {
    $user = $existing_user;
  }
  else {
    // Register this new user.
    $email = _redhat_get_email($rhlogin);

    if (valid_email_address($email) == FALSE) {
      drupal_set_message('There was an error retrieving your email.  You will be unable to receive emails from the community for notification purposes', 'error');
      $email = NULL;
    }

    $name = _redhat_sso_rhlogin_to_name($rhlogin);

    $userinfo = array(
      'name' => $name,
      'pass' => user_password(),
      'init' => $name,
      'mail' => $email,
      'status' => 1,
      "authname_$module" => $rhlogin,
      'access' => time(),
    );
    $account = _redhat_sso_user_save_with_unique_name($userinfo);
    // Terminate if an error occured during user_save().
    if (!$account) {
      drupal_set_message(t("Error saving user account."), 'error');
      return;
    }

    // Map the user rhlogin to their account
    $insert = db_query("INSERT INTO {profile_values} (fid, uid, value) SELECT f.fid, '%d', '%s' FROM {profile_fields} f WHERE f.name = 'profile_rhlogin'", $account->uid, $rhlogin);
    if (!$insert) {
      drupal_set_message(t("Error saving user account info."), 'error');
      return;
    }

    $user = $account;
    watchdog('redhat_sso', 'New external user: %name using module %module.', array('%name' => $rhlogin, '%module' => $module), WATCHDOG_NOTICE, l(t('edit'), 'user/' . $user->uid . '/edit'));
    return $user;
  }
}

/*
 * In order to protect user email addresses, automatically strip the 
 * host section of the rhlogin.
 */
function _redhat_sso_rhlogin_to_name( $rhlogin ) {
  $i = strpos($rhlogin, '@');
  if ($i > 0) {
    return substr($rhlogin, 0, $i);
  }
  return $rhlogin;
}

/*
 * Attempt to select a user name that is unique by trying to append
 * an incrementing sequence at the end of the name.  If all possible
 * matches are taken in the limited search, use the last insert id
 * as a suitable unique value (guaranteed to be unique).
 */
function _redhat_sso_user_save_with_unique_name( $userinfo ) {
  $account = user_save('', $userinfo);
  if (!$account) {
    $name = $userinfo['name'];
    $names = array();
    $result = db_query("SELECT name FROM {users} WHERE name like '%s_%' and CHAR_LENGTH(name) < %d ORDER BY name LIMIT 25;", $name, strlen($name)+3);
    while ($field = db_fetch_array($result)) {
      $names[$field['name']] = 1;
    }

    watchdog('redhat_sso', 'Searching for non matching names: %field', array('%field' => implode(',', array_keys($names))), WATCHDOG_NOTICE);
    $names_found = count($names);
    for ($i=0; $i<$names_found+1; $i++) {
      $test = _redhat_sso_append_name($name, $i + 1);
      watchdog('redhat_sso', 'Testing %name', array('%name' => $test), WATCHDOG_NOTICE);
      if (!array_key_exists($test, $names)) {
        watchdog('redhat_sso', 'Attepting to create with %name', array('%name' => $test), WATCHDOG_NOTICE);
        $userinfo['name'] = $test;
        $account = user_save('', $userinfo);
        if ($account) {
          return $account;
        }
      }
    }

    $userinfo['name'] = _redhat_sso_append_name($name, db_last_insert_id('users', 'uid'));
    $account = user_save('', $userinfo);
  }
  return $account;
}

function _redhat_sso_append_name($name, $i) {
  return $name . '-' . $i;
}

/*
 * Return the UID of a user with the provided rhlogin value, or
 * NULL.
 */
function _redhat_sso_uid_for_login($login) {
  $result = db_query('select u.uid as uid from {profile_values} as v, {profile_fields} as f, {users} as u where f.name = "profile_rhlogin" and v.value = "%s" and f.fid = v.fid and u.uid = v.uid order by u.uid asc limit 1', $login);
  $uid = NULL;
  while ($field = db_fetch_array($result)) {
    if ($uid == NULL) {
      $uid = $field['uid'];
    }
  }
  // Allow passthrough auth integration
  if (!isset($uid) && variable_get('redhat_sso_skip_password', FALSE)) {
    $user = user_load(array('name' => $login));
    watchdog('redhat_sso', 'Integration disabled, looking up "%username" in users: %found', array('%username' => $login, '%found' => $user->uid), WATCHDOG_NOTICE);
    $uid = $user->uid;
  }
  return $uid;
}

/*
 * Perform the user_is_blocked() test with a UID.
 */
function _redhat_sso_user_is_blocked($uid) {
  if (!isset($uid)) {
    return FALSE;
  }
  $deny = db_fetch_object(db_query("SELECT name FROM {users} WHERE status = 0 AND uid = '%d' limit 1", $uid));
  watchdog('redhat_sso', 'Deny "%uid"? "%deny"', array('%uid' => $uid, '%deny' => ($deny != FALSE)), WATCHDOG_NOTICE);
  return $deny != FALSE;
}

/*
 * Retrieve a user's email from a Red Hat's streamline service.  Here is an example response:
 * 
 * stdClass Object (
 *   [request] => POST /wapps/streamline/userInfo.html
 *     HTTP/1.0 Host: www.webqa.redhat.com
 *     User-Agent: Drupal (+http://drupal.org/)
 *     Content-Length: 33
 *     Content-Type: application/x-www-form-urlencoded
 *     login=xeops&secretKey=sw33tl1Qu0r
 *   [data] => {"emailAddress":"xeops_linux@deutsche-boerse.com","login":"XEOPS"}
 *   [protocol] => HTTP/1.1
 *   [status_message] => OK
 *   [headers] => Array
 *       (
 *           [Date] => Thu, 05 May 2011 20:17:37 GMT
 *           [Server] => Apache
 *           [Content-Language] => en-US
 *           [Content-Length] => 66
 *           [Content-Type] => application/json;charset=UTF-8
 *           [Connection] => close
 *       )
 *
 *   [code] => 200
 * )
 */
function _redhat_get_email($username) {
  if (variable_get('redhat_sso_skip_password', FALSE)) {
    watchdog('redhat_sso', 'Integration disabled, automatically return stock email', array(), WATCHDOG_NOTICE);
    return 'a_made_up_email@mailinator.com';
  }

  $data = array('login' => $username, 'secretKey' => variable_get('redhat_user_info_secret_key', 'redhat_user_info_secret_key_NOT_SET'));

  // Set some parameters for sending request.
  $request_url = variable_get('redhat_user_info_url', 'redhat_user_info_url_NOT_SET');
  $request_headers = array('Content-Type' => 'application/x-www-form-urlencoded');
  $request_method = 'POST';
  $request_retry = 3;
  $post_data = http_build_query($data, '', '&');

  // Send the request.
  $response = drupal_http_request($request_url, $request_headers, $request_method, $post_data, $request_retry);
  $response_array = json_decode($response->data, TRUE);
  return $response_array['emailAddress'];
}

/*
 * Attempt to authenticate the username and password with the
 * Streamline service.  Return the rhlogin of the user or
 * NULL if authentication failed.
 */
function _redhat_sso_authenticate($username, $password) {
  if (variable_get('redhat_sso_skip_password', FALSE)) {
    watchdog('redhat_sso', 'Integration disabled, automatically authorized "%username"', array('%username' => $username), WATCHDOG_NOTICE);
    return $username;
  }

  $data = array('login' => $username, 'password' => $password);

  // Set some parameters for sending request.
  $request_url = variable_get('redhat_sso_login_url', 'redhat_user_info_url_NOT_SET');
  $request_headers = array('Content-Type' => 'application/x-www-form-urlencoded');
  $request_method = 'POST';
  $request_retry = 3;
  $post_data = http_build_query($data, '', '&');

  watchdog('redhat_sso', 'Call Streamline %username with %request_url"', array('%username' => $username, '%request_url' => $request_url), WATCHDOG_NOTICE);
  // Send the request.
  $response = drupal_http_request($request_url, $request_headers, $request_method, $post_data, $request_retry);
  if ($response->code == 200) {
    $response_array = json_decode($response->data, TRUE);
    watchdog('redhat_sso', 'User "%username" is authenticated with "%login"', array('%username' => $username, '%login' => $response_array['login']), WATCHDOG_NOTICE);
    return $response_array['login'];
  }
  watchdog('redhat_sso', 'User "%username" failed authentication with status %code', array('%username' => $username, '%code' => $response->code), WATCHDOG_NOTICE);
  return NULL;
}

/*
 * Perform an external redirect (drupal_goto does not handle
 * external URLs correctly in all cases).  Copied from 
 * drupal_goto.
 */
function _redhat_sso_redirect($url) {
  // Allow modules to react to the end of the page request before redirecting.
  // We do not want this while running update.php.
  if (!defined('MAINTENANCE_MODE') || MAINTENANCE_MODE != 'update') {
    module_invoke_all('exit', $url);
  }

  // Even though session_write_close() is registered as a shutdown function, we
  // need all session data written to the database before redirecting.
  session_write_close();

  header('Location: ' . $url, TRUE, $http_response_code);

  // The "Location" header sends a redirect status code to the HTTP daemon. In
  // some cases this can be wrong, so we make sure none of the code below the
  // drupal_goto() call gets executed upon redirection.
  exit();
}
