#!/usr/bin/env ruby

require 'rubygems'
require 'parseconfig'
require 'getoptlong'
require 'logger'
require 'pp'
require 'open4'

# Synchronize output
$stdout.sync = true
$stderr.sync = true

def complete(pid, status)
  process = @processes[pid]

  begin
    # Write the username if successful
    if status.exitstatus == 0
      return process[:stdout].read.chomp
    else
      @logger.error(process[:stderr].read)
    end
  ensure
    # Clean out the process entry
    @processes.delete(pid)
  end
end

def wait_for_processes(blocking=true)
  result = []

  if blocking
    @logger.debug("Blocking until next process finishes...")
    pid, status = Process::waitpid2
    result << complete(pid, status)
  else
    until @processes.empty?
      @logger.debug("Non-blocking check for processes...")
      pid, status = Process::waitpid2(-1, Process::WNOHANG)
      break unless status
      result << complete(pid, status)
    end
  end

  return result
end

def p_usage
    puts <<USAGE

Usage: batch_register
Batch register users for testing

  -n|--num       num_users     Number of users to create
  -c|--processes num_processes The number of parallel processes to run
  -p|--proxy                   Use a proxy
  -d|--debug                   Show debug info
  -h|--help                    Show Usage info

USAGE
  exit 255
end

begin
    opts = GetoptLong.new(
        ["--num",   "-n", GetoptLong::REQUIRED_ARGUMENT],
        ["--processes", "-c", GetoptLong::REQUIRED_ARGUMENT],
        ["--debug", "-d", GetoptLong::NO_ARGUMENT],
        ["--proxy", "-p", GetoptLong::NO_ARGUMENT],
        ["--help",  "-h", GetoptLong::NO_ARGUMENT]
    )
    opt = {}
    opts.each do |o, a|
        opt[o[2..-1]] = a.to_s
    end
rescue Exception => e
  puts e.message
  p_usage
end

if opt["help"] or !opt["num"]
    p_usage
end

@num_users = opt['num'].to_i
@num_processes = opt['processes'].to_i

# Default if necessary
if @num_processes == 0
  @num_processes = 10
end

@debug = opt['debug']

@options = ""
@options << " -p" if opt['proxy']
@options << " -d" if opt['debug']

# Setup logger
@logger = Logger.new(STDERR)
@logger.level = @debug ? Logger::DEBUG : Logger::ERROR

# Clear out the multi-process log
`rm -rf /tmp/reg`
`mkdir -p /tmp/reg`

@logger.debug("Creating users with #{@num_processes} processes")

# Create the users
users = []
@processes = {}
@num_users.times do |i|
  # If we are at the max processes, start waiting for results
  if @processes.length == @num_processes
    users += wait_for_processes
  end

  # Clean out any other processes that might have completed
  users += wait_for_processes(false)

  # Kick off a new process
  pid, stdin, stdout, stderr = Open4::popen4("./register_random" + @options + " 2> /tmp/output#{i}")

  stdin.close
  @processes[pid] = {:stdout => stdout, :stderr => stderr}
  @logger.debug("Starting process #{pid}")

  sleep rand
end

# Wait for the rest of them
until @processes.empty?
  users += wait_for_processes
end

# Output the results
puts users.join("\n")
