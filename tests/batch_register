#!/usr/bin/env ruby

require 'rubygems'
require 'parseconfig'
require 'getoptlong'
require 'logger'
require 'pp'
require 'open4'

# Synchronize output
$stdout.sync = true
$stderr.sync = true

def wait_for_process(pid, data)
  begin
    @logger.debug("Waiting on next process #{pid}...")
    ignored, status = Process::waitpid2 pid
    @logger.debug("Process #{pid} finished.")
    @logger.debug("Process status = #{status}")

    # Write the username if successful
    if status.exitstatus == 0
      return data[:stdout].read.chomp
    else
      @logger.error(data[:stderr].read)
    end
  rescue
    @logger.error("Exception")
  end
end

def p_usage
    puts <<USAGE

Usage: batch_register
Batch register users for testing

  -n|--num       num_users     Number of users to create
  -c|--processes num_processes The number of parallel processes to run
  -p|--proxy                   Use a proxy
  -d|--debug                   Show debug info
  -h|--help                    Show Usage info

USAGE
  exit 255
end

begin
    opts = GetoptLong.new(
        ["--num",   "-n", GetoptLong::REQUIRED_ARGUMENT],
        ["--processes", "-c", GetoptLong::REQUIRED_ARGUMENT],
        ["--debug", "-d", GetoptLong::NO_ARGUMENT],
        ["--proxy", "-p", GetoptLong::NO_ARGUMENT],
        ["--help",  "-h", GetoptLong::NO_ARGUMENT]
    )
    opt = {}
    opts.each do |o, a|
        opt[o[2..-1]] = a.to_s
    end
rescue Exception => e
  puts e.message
  p_usage
end

if opt["help"] or (!opt["num"] or !opt["processes"])
    p_usage
end

@num_users = opt['num'].to_i
@num_processes = opt['processes'].to_i
@debug = opt['debug']

@options = ""
@options << " -p" if opt['proxy']
@options << " -d" if opt['debug']

# Setup logger
@logger = Logger.new(STDERR)
@logger.level = @debug ? Logger::DEBUG : Logger::ERROR

# Clear out the multi-process log
`rm -rf /tmp/reg`
`mkdir -p /tmp/reg`

@logger.debug("Creating users with #{@num_processes} processes")

# Create the users
users = []
processes = {}
@num_users.times do |i|
  # If we are at the max processes, start waiting for results
  if processes.length == @num_processes
    # Pull a process out to wait for
    process = processes.shift
    @logger.debug("Waiting on process #{process.pretty_inspect}")
    @logger.debug("Remaining processes #{processes.pretty_inspect}")
    users << wait_for_process(process[0], process[1])
  end

  # Kick off a new process
  pid, stdin, stdout, stderr = Open4::popen4("./register_random" + @options + " 2> /tmp/output#{i}")

  stdin.close
  processes[pid] = {:stdout => stdout, :stderr => stderr}
  @logger.debug("Starting process #{pid}")

  sleep rand * 2
end

# Wait for the rest of them
processes.each do |pid, data|
 users << wait_for_process(pid, data)
end

# Output the results
puts users.join("\n")
