#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))

require 'rubygems'
require 'thor'
require 'fileutils'
require 'lib/openshift'
require 'pp'
require 'yaml'

class DevEnv < Thor
  include Thor::Actions
  include OpenShift::Tito
  include OpenShift::SSH
  include OpenShift::Amazon
  
  no_tasks do
    
    def sync_repo(repo_name, hostname, ssh_path)
      temp_commit

      # Get the current branch
      branch = get_branch
  
      puts "Synchronizing local changes from branch #{branch} for repo #{repo_name}..."
      run("export GIT_SSH=#{ssh_path}; #{branch == 'origin/master' ? "git push -q root@#{hostname}:/root/#{repo_name} master:master --tags --force; " : ''}git push -q root@#{hostname}:/root/#{repo_name} #{branch}:master --tags --force", :verbose => options.verbose?)
      update_remote_tests(hostname) if repo_name == 'li'
      puts "Done"
  
      reset_temp_commit
    end
    
    def temp_commit
      # Warn on uncommitted changes
      `git diff-index --quiet HEAD`
  
      if $? != 0
        # Perform a temporary commit
        puts "Creating temporary commit to build"
        `git commit -a -m "Temporary commit to build"`
        if $? != 0
          puts "No-op."
        else
          @temp_commit = true
          puts "Done."
        end
      end
    end
    
    def reset_temp_commit
      if @temp_commit
        puts "Undoing temporary commit..."
        `git reset HEAD^`
        @temp_commit = false
        puts "Done."
      end
    end
    
    def update_remote_tests(hostname)
      print "Updating remote tests..."
      ssh(hostname, "rm -rf /root/li-test; cd /root/li; git archive --prefix li-test/ --format=tar HEAD | (cd /root && tar --warning=no-timestamp -xf -); mkdir -p /tmp/rhc/junit")
      puts "Done"
    end

    def download_artifacts(hostname)
      print "Downloading logs and screenshots..."
      `mkdir -p rhc/log`
      scp_from(hostname, "/tmp/rhc/*.log", "rhc/log")
      scp_from(hostname, "/tmp/rhc/*.html", "rhc/log")
      scp_from(hostname, "/var/www/libra/site/httpd/logs/access_log", "rhc/log/site_access_log.txt")
      scp_from(hostname, "/var/www/libra/site/httpd/logs/error_log", "rhc/log/site_error_log.txt")
      scp_from(hostname, "/var/www/libra/site/log/development.log", "rhc/log")
      scp_from(hostname, "/var/www/libra/broker/httpd/logs/access_log", "rhc/log/broker_access_log.log")
      scp_from(hostname, "/var/www/libra/broker/httpd/logs/error_log", "rhc/log/broker_error_log.log")
      scp_from(hostname, "/var/www/libra/broker/log/development.log", "rhc/log")
      scp_from(hostname, "/var/log/mcollective.log", "rhc/log")
      scp_from(hostname, "/var/www/libra/broker/log/mcollective-client.log", "rhc/log")
      scp_from(hostname, "/var/log/httpd/access_log", "rhc/log/system_access_log.log")
      scp_from(hostname, "/var/log/httpd/error_log", "rhc/log/system_error_log.log")
      scp_from(hostname, "/var/log/messages", "rhc/log/messages.log")
      scp_from(hostname, "/var/log/dmesg", "rhc/log/messages.log")
      scp_from(hostname, "/tmp/rhc/screenshots/", "rhc/log")
      puts "Done"
    end

    def run_ssh(hostname, title, cmd)
      output, code = ssh(hostname, cmd, 4800, true)
      puts <<-eos


          -----------------------------------------------------------
                      Begin Output From #{title} Tests
          -----------------------------------------------------------

#{output}

          -----------------------------------------------------------
                       End Output From #{title} Tests
          -----------------------------------------------------------


      eos
      if code != 0
        download_artifacts hostname
        exit code
      end
    end
    
    def rpm_manifest(hostname)
      print "Retrieving RPM manifest"
      manifest = ssh(hostname, 'rpm -qa | grep rhc-')
      manifest = manifest.split("\n").sort.join(" / ")
      # Trim down the output to 255 characters
      manifest.gsub!(/rhc-([a-z])/, '\1')
      manifest.gsub!('.el6.noarch', '')
      manifest.gsub!('.el6_1.noarch', '')
      manifest.gsub!('cartridge', 'c-')
      manifest = manifest[0..254]
      puts "Done"
      return manifest
    end
    
    def validate_instance(hostname)
      # Validate the node installation
      print "Validating instance..."
      unless is_valid?(hostname)
        puts "ERROR - instance is not valid"
        exit 1
      end
      puts "Done"
    end
    
    def reboot(instance)
      print "Rebooting instance to apply new kernel..."
      instance.reboot
      puts "Done"
    end
    
  end

  desc "build NAME", "Build a new devenv AMI with the given NAME"
  method_option :register, :type => :boolean, :desc => "Register the instance"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance on exit"
  method_option :use_stage_repo, :type => :boolean, :desc => "Build instance off the stage repository"
  method_option :reboot, :type => :boolean, :desc => "Reboot the instance after updating"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  def build(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Establish a new connection
    conn = connect     
    conn = conn.regions[options.region] unless (options.region?nil)
    # Create a new builder instance
    if (options.region?nil)
      image = conn.images[AMI["us-east-1"]]
    elsif AMI[options.region].nil?
      puts "No AMI specified for region:" + options.region
      exit 1
    else
      image = conn.images[AMI[options.region]]
    end

    instance = launch_instance(image, name)
    hostname = instance.dns_name

    begin
      # TODO - Remove this once nss is updated in RHEL 6.2
      print "Running one yum update to get around RHEL 6.2 AMI problem..."
      ssh(hostname, "yum update -y --exclude='rhc*'", 3600)
      puts "Done"

      print "Updating all packages on the system..."
      ssh(hostname, "yum update -y --exclude='rhc*'", 3600)
      puts "Done"

      if options.reboot?
        reboot(instance)
      end

      print "Uploading devenv script..."
      script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/devenv/li-devenv.sh")
      scp_to(hostname, script_path, "~/")
      puts "Done"

      print "Performing clean install with the latest code..."
      cmd = 'set -e; sh li-devenv.sh'
      cmd += ' stage' if options.use_stage_repo?
      output = ssh(hostname, cmd, 3600)
      puts "Done"

      puts "----------------- Install Output ------------------------"
      puts output
      puts "---------------------------------------------------------"

      validate_instance(hostname)

      manifest = rpm_manifest(hostname)

      if options.register?
        register_image(conn, instance, name, manifest)
      end
    ensure
      terminate_instance(instance) if options.terminate?
    end
  end
  
  desc "yum_update TAG", "Build a new devenv AMI with the given NAME of an existing instance"
  method_option :register, :type => :boolean, :desc => "Register the instance"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance on exit"
  method_option :reboot, :type => :boolean, :desc => "Reboot the instance after updating"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  def yum_update(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Establish a new connection
    conn = connect
    conn = conn.regions[options.region] unless (options.region?nil)
    instance = find_instance(conn, tag, true)
    hostname = instance.dns_name

    begin
      print "Updating all packages on the system..."
      ssh(hostname, "yum clean metadata; yum update -y --exclude='rhc-devenv'; yum update -y --exclude='rhc-devenv' --disablerepo=\* --enablerepo=li", 600)
      puts "Done"

      if options.reboot?
        reboot(instance)
      end

      validate_instance(hostname)

      manifest = rpm_manifest(hostname)

      if options.register?
        register_image(conn, instance, tag, manifest)
      end
    ensure
      terminate_instance(instance) if options.terminate?
    end
  end

  desc "update", "Update current instance by installing RPMs from local git tree"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def update
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Warn on uncommitted changes
    `git diff-index --quiet HEAD` 
    puts "WARNING - Uncommitted repository changes" if $? != 0

    remove_dir '/tmp/tito/'

    # Figure out what needs to be built - exclude devenv for syncs
    build_dirs = get_build_dirs - ['misc/devenv']
    
    # Build and install them
    build_dirs.each do |build_dir|
      puts "Building in #{build_dir}"
      inside(File.expand_path("../#{build_dir}", File.dirname(__FILE__))) do
        # Build and install the RPM's locally
        exit 1 unless run('tito build --rpm --test --install', :verbose => options.verbose?)
      end
    end
    run('service mcollective restart; service libra-broker restart; service libra-site restart', :verbose => options.verbose?)
  end

  desc "sync NAME", "Synchronize a local git repo with a remote DevEnv instance.  NAME should be ssh resolvable."
  method_option :tag, :type => :boolean, :desc => "NAME is an Amazon tag"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :verifier, :type => :boolean, :desc => "Maintain verifier functionality (private IP setup)"
  method_option :skip_build, :type => :boolean, :desc => "Indicator to skip the rpm build/install"
  method_option :clean_metadata, :type => :boolean, :desc => "Cleans metadata before running yum update"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  def sync(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Get the hostname from a tag lookup or assume it's SSH accessible directly
    conn = connect
    conn = conn.regions[options.region] unless (options.region?nil)
    hostname = options.tag? ? find_instance(conn, name, true).dns_name : name
    
    ssh_path=File.expand_path(File.dirname(__FILE__)) + "/ssh-override"
    sync_repo('li', hostname, ssh_path)
    
    has_client = File.exists?('../os-client-tools')
    
    if has_client
      inside('../os-client-tools') do
        sync_repo('os-client-tools', hostname, ssh_path)
      end
    end

    if !options.skip_build?
      puts "Performing remote install...."
      output, exit_code = ssh(hostname, "set -e; #{options.clean_metadata? ? 'yum clean metadata; ' : ''}yum update -y --exclude='rhc-devenv' --disablerepo=\* --enablerepo=li rhc-*; rm -rf li-working os-client-tools-working; git clone li li-working;#{has_client ? ' git clone os-client-tools os-client-tools-working;' : ''} pushd li-working; build/devenv update #{options.verbose? ? '--verbose' : ''}; popd; rm -rf li-working os-client-tools-working", 600, true)
      if exit_code != 0
        puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        puts "Build failed!  Exiting."
        puts output
        puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        exit 1
      end
      puts "Done"
    end

    # If this is a verifier, you'll need to reset the private ip setup on each sync
    if options.verifier?
      use_private_ip(hostname)
    else
      use_public_ip(hostname)
    end
  end

  desc "sync_sdk NAME PATH", "Synchronize a local git repo with a remote DevEnv instance.  NAME should be ssh resolvable. PATH should be the location of the git repository to sync"
  method_option :tag, :type => :boolean, :desc => "NAME is an Amazon tag"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :skip_build, :type => :boolean, :desc => "Indicator to skip the rpm build/install"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  def sync_sdk(name, path)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Get the hostname from a tag lookup or assume it's SSH accessible directly
    conn = connect
    conn = conn.regions[options.region] unless (options.region?nil)
    hostname = options.tag? ? find_instance(conn, name, true).dns_name : name

    # Get the current branch
    branch = get_branch

    puts "Synchronizing local changes from branch #{branch}..."
    ssh_path=File.expand_path(File.dirname(__FILE__)) + "/ssh-override"

    # Don't change directories until the ssh_path has been determined from the working directory
    FileUtils.cd path 

    run("export GIT_SSH=#{ssh_path}; #{branch == 'origin/master' ? "git push -q root@#{hostname}:/root/cloud-sdk master:master --tags --force; " : ''}git push -q root@#{hostname}:/root/cloud-sdk #{branch}:master --tags --force", :verbose => options.verbose?)
    puts "Done"

    if !options.skip_build?
      puts "Performing remote install...."
      ssh(hostname, "rm -rf cloud-sdk-working; git clone cloud-sdk cloud-sdk-working; pushd cloud-sdk-working; tito build --rpm --test -i; popd; rm -rf cloud-sdk-working", 600)
      puts "Done"
    end
  end

  desc "terminate TAG", "Terminates the instance with the specified tag"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  def terminate(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
    conn = connect
    conn = conn.regions[options.region] unless (options.region?nil)
    instance = find_instance(conn, tag, true)
    terminate_instance(instance)
  end

  desc "launch NAME", "Launches the latest DevEnv instance, tagging with NAME"
  method_option :verifier, :type => :boolean, :desc => "Add verifier functionality (private IP setup and local tests)"
  method_option :use_stage_image, :type => :boolean, :desc => "Launch a stage DevEnv image"
  method_option :use_clean_image, :type => :boolean, :desc => "Launch a clean DevEnv image"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :express_server, :type => :boolean, :desc => "Set as express server in express.conf and leave on public_ip"
  method_option :ssh_config_verifier, :type => :boolean, :desc => "Set as verifier in .ssh/config"
  method_option :init_repo, :type => :boolean, :desc => "Initialize git repo for syncing and tests (requires --verifier)"
  method_option :instance_type, :required => false, :desc => "Amazon machine type override (default m1.large)"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  def launch(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Override the machine type to launch if necessary
    if options[:instance_type]
      $amz_options[:instance_type] = options[:instance_type]
    end

    # Get the latest devenv image and create a new instance
    conn = connect
    conn = conn.regions[options.region] unless (options.region?nil)
    if options.use_stage_image?
      filter = DEVENV_STAGE_WILDCARD
    elsif options.use_clean_image?
      filter = DEVENV_CLEAN_WILDCARD
    else
      filter = DEVENV_WILDCARD
    end
    ami = get_latest_ami(conn, filter)
    puts "Launching latest DevEnv instance #{ami.id}"
    instance = launch_instance(ami, name)
    hostname = instance.dns_name
    puts "Done"
    puts "Hostname: #{hostname}"

    puts "Sleeping for 30 seconds to let node stabilize..."
    sleep 30
    puts "Done"
   
    if options.verifier?
      use_private_ip(hostname)

      if options.init_repo?
        print "Initializing git repo for syncing..."
        ssh(hostname, "rm -rf /root/li; git clone --bare git://git1.ops.rhcloud.com/li.git/ /root/li")
        update_remote_tests(instance.dns_name)
        puts "Done"
      else
        print "Archiving local changes..."
        `git archive --prefix li-test/ HEAD --output /tmp/li-test.tar`
        puts "Done"
        print "Updating tests to remote instance..."
        scp_to(hostname, "/tmp/li-test.tar", "~/", 600)
        ssh(hostname, 'rm -rf li-test; tar -xf li-test.tar; mkdir -p /tmp/rhc/junit')
        puts "Done"
      end
    end

    validate_instance(hostname)
    
    if options.ssh_config_verifier?
      public_ip = instance.public_ip_address
      ssh_config = "~/.ssh/config"
      pem_file = File.expand_path("~/.ssh/libra.pem")
      if not File.exist?(pem_file)
        # copy it from local repo
        cmd = "cp misc/libra.pem #{pem_file}"
        puts cmd
        system(cmd)
        system("chmod 600 #{pem_file}")
      end
      config_file = File.expand_path(ssh_config)

      config_template = <<END
Host verifier
  HostName 10.1.1.1
  User      root
  IdentityFile ~/.ssh/libra.pem
END

      if not FileTest.exists?(config_file)
        puts "File '#{ssh_config}' does not exists, creating..."
        system("touch #{ssh_config}")
        cmd = "chmod 600 #{ssh_config}"
        system(cmd)
        file_mode = 'w'
        File.open(config_file, file_mode) { |f| f.write(config_template) }
      else
        if not system("grep -n 'Host verifier' #{config_file}")
          file_mode = 'a'
          File.open(config_file, file_mode) { |f| f.write(config_template) }
        end
        
      end

      
      line_num = `grep -n 'Host verifier' ~/.ssh/config`.chomp.split(':')[0]
      puts "Updating ~/.ssh/config verifier entry with public ip = #{public_ip}"
      (1..4).each do |i|
        `sed -i '#{line_num.to_i + i}s,HostName.*,HostName #{public_ip},' ~/.ssh/config`
      end
    end
    
    if options.express_server?
      public_ip = instance.public_ip_address
      puts "Updating ~/.openshift/express.conf libra_server entry with public ip = #{public_ip}"
      `sed -i 's,^libra_server.*,libra_server=#{public_ip},' ~/.openshift/express.conf`
      use_public_ip(hostname)
    end
    
    puts "Done"
  end

  desc "test TAG", "Runs the tests on a tagged instance and downloads the results"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance when finished"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :unofficial, :type => :boolean, :desc => "For unofficial use.  Do not send emails, etc."
  method_option :exclude_internal, :type => :boolean, :desc => "Exclude running unit and internal tests"
  method_option :exclude_verification, :type => :boolean, :desc => "Exclude running verification tests"
  method_option :exclude_web, :type => :boolean, :desc => "Exclude running Selenium tests"
  method_option :sauce_username, :required => false, :desc => "Sauce Labs username (default '#{SAUCE_USER}')"
  method_option :sauce_access_key, :required => false, :desc => "Sauce Labs access key (default '#{SAUCE_SECRET}')"
  method_option :sauce_os, :required => false, :desc => "Sauce Labs OS (default '#{SAUCE_OS}')"
  method_option :sauce_browser, :required => false, :desc => "Sauce Labs browser (default '#{SAUCE_BROWSER}')"
  method_option :sauce_browser_version, :required => false, :desc => "Sauce Labs browser version (default '#{SAUCE_BROWSER_VERSION}')"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  def test(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    conn = connect
    conn = conn.regions[options.region] unless (options.region?nil)
      
    instance = find_instance(conn, tag, true)
    hostname = instance.dns_name

    begin
      if options.unofficial?
        use_private_ip(hostname)
      end

      threads = []

      unless options.exclude_internal?
        threads << Thread.new do
          cmd = "cd li-test/broker; rake test"
          run_ssh(hostname, "Broker Unit", cmd)
        end
        threads << Thread.new do
          cmd = "cd li-test/site; rake test"
          run_ssh(hostname, "Site Unit", cmd)
        end
        threads << Thread.new do
          cmd = "cd li-test/cloud-sdk/controller; rake test"
          run_ssh(hostname, "Cloud SDK Unit", cmd)
        end
      end
      
      threads << Thread.new do
        unless options.exclude_internal?
          cmd = "cucumber -f html --out /tmp/rhc/internals.html -f progress -t @internals li-test/tests/"
          run_ssh(hostname, "Internal", cmd)
        end
        unless options.exclude_verification?
          cmd = "cucumber -f html --out /tmp/rhc/verfication.html -f progress -t @verify li-test/tests/"
          run_ssh(hostname, "Verification", cmd)
        end
      end

      unless options.exclude_web?
        threads << Thread.new do
          sauce_opts = {
            "SAUCE_USERNAME" => (options.sauce_username || SAUCE_USER),
            "SAUCE_ACCESS_KEY" => (options.sauce_access_key || SAUCE_SECRET),
            "SAUCE_OS" => (options.sauce_os || SAUCE_OS),
            "SAUCE_BROWSER" => (options.sauce_browser || SAUCE_BROWSER),
            "SAUCE_BROWSER_VERSION" => (options.sauce_browser_version || SAUCE_BROWSER_VERSION),
            "JENKINS_BUILD" => 'unofficial'
          }

          # If we passed a jenkins build like name, use that for the build number
          if m = tag.match(/libra_/)
            sauce_opts['JENKINS_BUILD'] = tag
          end

          env_string = sauce_opts.keys.map{|k| %Q(#{k}="#{sauce_opts[k]}")}.join(' ')

          puts "Running Sauce tests with the following options:"
          puts sauce_opts.to_yaml

          cmd = "cd li-test/selenium; #{env_string} ruby ts_web"
          run_ssh(hostname, "Web Selenium", cmd)
        end
      end
      
      threads.each do |t|
        t.join
      end

      validate_instance(hostname)

      # Download the successful artifacts
      download_artifacts hostname

      if !options.unofficial?
        # Mark the image as verified
        image = conn.images[instance.image_id]
        verify_image(image)
        
        print "Sending QE ready email..."
        begin
          send_verified_email(instance.image_id, image.name)
        rescue Exception => e
          print "Failed sending email with message: #{e.message}"
        end
      else
        use_public_ip(hostname)
      end
      
      puts "Done"

    ensure
      terminate_instance(instance) if options.terminate?
    end
  end

  desc "test_sdk TAG", "Runs the tests on a tagged instance and downloads the results"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance when finished"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  def test_sdk(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    conn = connect
    conn = conn.regions[options.region] unless (options.region?nil)
    
    instance = find_instance(conn, tag, true)
    hostname = instance.dns_name
    begin
      cmd = "cd /usr/lib/ruby/gems/*/gems/cloud-sdk*; rake test"
      run_ssh(hostname, "OpenShift SDK Unit", cmd)
      
      puts "Done"
    ensure
      terminate_instance(instance) if options.terminate?
    end
  end

  desc "install_local_client", "Builds and installs the local client rpm (uses sudo)"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def install_local_client
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    if File.exists?('../os-client-tools')
      inside('../os-client-tools') do
        temp_commit
        
        `rm -rf /tmp/tito/; pushd express; tito build --rpm --test; popd; sudo rpm -Uvh /tmp/tito/noarch/rhc-*;rm -rf /tmp/tito/`
    
        reset_temp_commit
    
        puts "Done"
      end
    else
      puts "Couldn't find ../os-client-tools."
    end
  end  
  
  desc "sync_groups GROUPNAME", "Copies the security group permission from specified region to other regions"
  method_option :clean, :type => :boolean, :desc => "Revokes any existing permissions and starts fresh"
  method_option :region, :required => false, :default => 'us-east-1', :desc => "Amazon region to copy (default us-east-1)"
  def sync_groups(group_name)
    conn = connect
    origin_sg = conn.regions[options.region].security_groups.filter('group-name', group_name).first
    if(origin_sg.nil?)
      puts "Group #{group_name} not found in region #{options.region}"
      exit 1
    end
    conn.regions.each do |region|
      #skip the region of origin
      next if(region.name == options.region) 
      
      puts "Synching #{region.name}"
      sg = conn.regions[region.name].security_groups.filter('group-name', group_name).first
      #If group does not exist then create it
      if(sg.nil?)
        sg = conn.regions[region.name].security_groups.create(group_name)
        #open access within the group
        sg.authorize_ingress(:tcp, 0..65535, sg)
        sg.authorize_ingress(:udp, 0..65535, sg)
        sg.authorize_ingress(:icmp, -1, sg)
      elsif (options.clean)
        puts "Revoking existing permissions"
        sg.ingress_ip_permissions.each do |i|
          i.revoke()
        end
        #open access within the group
        sg.authorize_ingress(:tcp, 0..65535, sg)
        sg.authorize_ingress(:udp, 0..65535, sg)
        sg.authorize_ingress(:icmp, -1, sg)
      end
      puts "Adding permissions"
      origin_sg.ingress_ip_permissions.each do |i|
        i.ip_ranges.each do |ip| 
          puts "#{i.protocol}  \tport_range=#{i.port_range}\t" + 
            "ip_range=#{ip} "
          begin
            sg.authorize_ingress(i.protocol , i.port_range, ip )
          rescue AWS::EC2::Errors::InvalidPermission::Duplicate
            puts "Permission already exists."
          end 
        end
        i.groups.each do |g| 
          if(g.owner_id != sg.owner_id)
            puts "#{i.protocol}  \tport_range=#{i.port_range}\t" + 
              "group name=#{g.name} owner=#{g.owner_id} id=#{g.group_id} " 
            if(g.exists?)
              begin
                sg.authorize_ingress(i.protocol , i.port_range, g )
              rescue AWS::EC2::Errors::InvalidPermission::Duplicate
                puts "Permission already exists."
              end 
            else
              puts "ERROR: Group name=#{g.name} owner=#{g.owner_id} id=#{g.group_id} " + 
                "does not exist or is in a different region."
            end
          end
        end
      end
    end
  end
end

DevEnv.start
