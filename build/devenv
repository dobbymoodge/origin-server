#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))

require 'rubygems'
require 'thor'
require 'fileutils'
require 'lib/openshift'
require 'pp'
require 'yaml'

include FileUtils

class DevEnv < Thor
  include Thor::Actions
  include OpenShift::Tito
  include OpenShift::SSH
  include OpenShift::Amazon
  include OpenShift::SauceLabs

  @@SSH_TIMEOUT = 4800
  @@SSH_TIMEOUT_OVERRIDES = { "benchmark" => 172800 }

  no_tasks do
    def sync_repo(repo_name, hostname, ssh_path)
      temp_commit

      # Get the current branch
      branch = get_branch

      puts "Synchronizing local changes from branch #{branch} for repo #{repo_name}..."
      ssh(hostname, %{export GIT_DIR=/root/#{repo_name}; git log ^HEAD || ( mkdir -p /root/#{repo_name} && cd /root/#{repo_name} && git init-db --bare)}, 15)
      exitcode = run(%{
#######
# Start shell code
export GIT_SSH=#{ssh_path}
#{branch == 'origin/master' ? "git push -q root@#{hostname}:/root/#{repo_name} master:master --tags --force; " : ''}
git push -q root@#{hostname}:/root/#{repo_name} #{branch}:master --tags --force
      
#######
# End shell code
}, :verbose => options.verbose?)

      puts "Done"

      reset_temp_commit
    end
    
    def sync_sibling_repo(repo_name, repo_dir, hostname, ssh_path)
      exists = File.exists?(repo_dir) 
      inside(repo_dir) do
        sync_repo(repo_name, hostname, ssh_path)
      end if exists
      exists
    end

    def init_repo(hostname)
      git_clone_commands = ''
      SIBLING_REPOS.each do |repo_name, repo_dirs|
        repo_dirs.each do |repo_dir|
          if File.exists?(repo_dir)
            git_clone_commands += "rm -rf /root/#{repo_name}; git clone --bare git@github.com:openshift/#{repo_name}.git /root/#{repo_name}; "
            break 
          end
        end
      end
      ssh(hostname, %{
rm -rf /root/li; git clone --bare git://git1.ops.rhcloud.com/li.git/ /root/li
#{git_clone_commands}
}, 120)
    end

    def temp_commit
      # Warn on uncommitted changes
      `git diff-index --quiet HEAD`

      if $? != 0
        # Perform a temporary commit
        puts "Creating temporary commit to build"
        `git commit -a -m "Temporary commit to build"`
        if $? != 0
          puts "No-op."
        else
          @temp_commit = true
          puts "Done."
        end
      end
    end

    def reset_temp_commit
      if @temp_commit
        puts "Undoing temporary commit..."
        `git reset HEAD^`
        @temp_commit = false
        puts "Done."
      end
    end

    def update_remote_tests(hostname)
      print "Updating remote tests..."
      repo_dirs = ['/root/li']
      SIBLING_REPOS.each do |repo_name, repo_dirs|
        repo_dirs.each do |repo_dir|
          if File.exists?(repo_dir)
            repo_dirs << ["/root/#{repo_name}"]
            break
          end
        end
      end
      git_archive_commands = ''
      repo_dirs.each do |repo_dir|
        git_archive_commands += "pushd #{repo_dir} > /dev/null; git archive --prefix li-test/ --format=tar HEAD | (cd /root && tar --warning=no-timestamp -xf -); popd > /dev/null; "
      end
      ssh(hostname, %{
rm -rf /root/li-test
#{git_archive_commands}
cp -n /root/li-test/stickshift/controller/test/cucumber/*.feature /root/li-test/tests/.  
mkdir -p /tmp/rhc/junit
})
      puts "Done"
    end
    
    def idle_all_gears(hostname)
      puts "Idling all gears on remote instance: #{hostname}"
      ssh(hostname, "for dir in /var/lib/stickshift/*; do if [ -d $dir ] && [ ! -h $dir ] ; then rhc-idler -u `basename $dir`; fi; done", 240)
      puts "Done"
    end

    def disable_charlie(hostname)
      puts "Disabling automatic shutdown on remote instance: #{hostname}"
      ssh(hostname, "echo HOURS=9999 > /etc/charlie.conf", 240)
    end

    def broker_profiler(hostname, enable=true)
      puts "Setting broker profile enable: #{enable}"
      f=Tempfile.open('fixbroker')
      begin
        if enable
          f.puts '/config.profiler = {/,/}/ { s/\#//g; }'
        else
          f.puts '/config.profiler = {/,/}/ { s/\#//g; s/^/#/; }'
        end
        f.close
        scp_to(hostname, f.path, "/tmp/fixbroker.sed", 600, 10)
        ssh(hostname, "sed -i -f /tmp/fixbroker.sed /var/www/stickshift/broker/config/environments/development.rb", 240)
        ssh(hostname, "/sbin/service libra-broker restart", 240)
      ensure
        f.close
        f.unlink
      end
    end

    def scp_remote_tests(hostname)
      puts "Archiving local changes..."
      FileUtils.rm_rf '/tmp/li-test'
      repo_dirs = ['.']
      SIBLING_REPOS.each do |repo_name, repo_dirs|
        repo_dirs.each do |repo_dir|
          if File.exists?(repo_dir)
            repo_dirs << repo_dir
            break
          end
        end
      end
      repo_dirs.each do |repo_dir|
        inside(repo_dir) do
          `git archive --prefix li-test/ --format=tar HEAD | (cd /tmp && tar --warning=no-timestamp -xf -)`
        end
      end
      `cd /tmp/ && tar -cvf /tmp/li-test.tar li-test`
      puts "Done"
      puts "Copying tests to remote instance: #{hostname}"
      scp_to(hostname, "/tmp/li-test.tar", "~/", 600, 10)
      puts "Done"
      puts "Extracting tests on remote instance: #{hostname}"
      ssh(hostname, 'set -e; rm -rf li-test; tar -xf li-test.tar; cp -n /root/li-test/stickshift/controller/test/cucumber/*.feature /root/li-test/tests/. ; mkdir -p /tmp/rhc/junit', 120)
      puts "Done"
    end

    def repo_path(dir='')
      File.expand_path("../#{dir}", File.dirname(__FILE__))
    end

    def download_artifacts(hostname)
      print "Downloading logs and screenshots..."
      `mkdir -p rhc/log`
      scp_from(hostname, "/tmp/rhc/*.log", "rhc/log")
      scp_from(hostname, "/tmp/rhc/*.html", "rhc/log")
      scp_from(hostname, "/var/www/stickshift/site/httpd/logs/access_log", "rhc/log/site_access_log.txt")
      scp_from(hostname, "/var/www/stickshift/site/httpd/logs/error_log", "rhc/log/site_error_log.txt")
      scp_from(hostname, "/var/www/stickshift/site/log/development.log", "rhc/log")
      scp_from(hostname, "/var/www/stickshift/site/log/test.log", "rhc/log/site_test.log")
      scp_from(hostname, "/var/www/stickshift/broker/httpd/logs/access_log", "rhc/log/broker_access_log.log")
      scp_from(hostname, "/var/www/stickshift/broker/httpd/logs/error_log", "rhc/log/broker_error_log.log")
      scp_from(hostname, "/var/www/stickshift/broker/log/development.log", "rhc/log")
      scp_from(hostname, "/var/www/stickshift/broker/log/test.log", "rhc/log/broker_test.log")
      scp_from(hostname, "/var/log/mcollective.*", "rhc/log")
      scp_from(hostname, "/var/www/stickshift/broker/log/mcollective-client.log", "rhc/log")
      scp_from(hostname, "/var/log/httpd/access_log", "rhc/log/system_access_log.log")
      scp_from(hostname, "/var/log/httpd/error_log", "rhc/log/system_error_log.log")
      scp_from(hostname, "/var/log/messages", "rhc/log/messages.log")
      scp_from(hostname, "/var/log/dmesg", "rhc/log/messages.log")
      scp_from(hostname, "/tmp/rhc/screenshots/", "rhc/log")
      scp_from(hostname, "/root/li-test/selenium/output/*", "rhc/log")
      scp_from(hostname, "/var/lib/stickshift/*/*/jbossas-7/standalone/tmp/*.log", "rhc/log")
      scp_from(hostname, "/tmp/rhc/benchmark.csv", "rhc/log")
      scp_from(hostname, "/tmp/broker-profiler/*", "rhc/log")
      puts "Done"
    end

    def run_ssh(hostname, title, cmd, timeout=@@SSH_TIMEOUT)
      output, code = ssh(hostname, cmd, timeout, true)
      puts <<-eos


          -----------------------------------------------------------
                      Begin Output From #{title} Tests
          -----------------------------------------------------------

#{output}

          -----------------------------------------------------------
                       End Output From #{title} Tests
          -----------------------------------------------------------
      

      eos
      return output, code
    end

    def rpm_manifest(hostname)
      print "Retrieving RPM manifest..."
      manifest = ssh(hostname, 'rpm -qa | grep rhc-')
      manifest = manifest.split("\n").sort.join(" / ")
      # Trim down the output to 255 characters
      manifest.gsub!(/rhc-([a-z])/, '\1')
      manifest.gsub!('.el6.noarch', '')
      manifest.gsub!('.el6_1.noarch', '')
      manifest.gsub!('cartridge', 'c-')
      manifest = manifest[0..254]
      puts "Done"
      return manifest
    end

    def validate_instance(hostname)
      # Validate the node installation
      print "Validating instance..."
      unless is_valid?(hostname)
        puts "ERROR - instance is not valid"
        exit 1
      end
      puts "Done"
    end

    def reboot(instance)
      print "Rebooting instance to apply new kernel..."
      instance.reboot
      puts "Done"
    end

    def add_ssh_cmd_to_threads(hostname, threads, failures, titles, cmds, timeout=@@SSH_TIMEOUT)
      titles = [titles] if titles.kind_of?(String)
      cmds = [cmds] if cmds.kind_of?(String)
      threads << Thread.new do
        multi = cmds.length > 1
        cmds.each_with_index do |cmd, index|
          title = titles[index]
          output, exit_code = run_ssh(hostname, title, cmd, timeout)
          if exit_code != 0
            if output.include?("Failing Scenarios:") && output =~ /cucumber li-test\/tests\/.*\.feature:\d+/
              output.lines.each do |line|
                if line =~ /cucumber li-test\/tests\/(.*\.feature):\d+/
                  test = $1
                  failures.push(["#{title} (#{test})", "cucumber -f html --out /tmp/rhc/#{test}.html -f progress li-test/tests/#{test}"])
                end
              end
            else
              failures.push([title, cmd])
            end
          end
        end
      end
    end
    
    def setup_test_dir(hostname)
      ssh(hostname, "rm -rf /tmp/rhc; mkdir -p /tmp/rhc/junit")
    end

    def test_instance(tag, hostname, instance, conn, options, image_id=nil)
      begin
        unless options.official?
          use_private_ip(hostname)
        end

        disable_charlie(hostname) if options.disable_charlie?
        
        idle_all_gears(hostname) unless options.official?
        
        setup_test_dir(hostname)

        broker_profiler(hostname) if options.profile_broker?

        threads = []
        failures = []

        unless options.exclude_internal?
          add_ssh_cmd_to_threads(hostname, threads, failures, "Broker Unit", "cd li-test/broker; rake test")
          site_titles = ["Site Unit:Units", "Site Unit:Functionals", "Site Unit:Integration"]
          site_cmds = ["cd li-test/site; rake test:units", "cd li-test/site; rake test:functionals", "cd li-test/site; rake test:integration"]
          add_ssh_cmd_to_threads(hostname, threads, failures, site_titles, site_cmds)
          add_ssh_cmd_to_threads(hostname, threads, failures, "StickShift Node Unit", "cd li-test/stickshift/node; rake test")
          add_ssh_cmd_to_threads(hostname, threads, failures, "StickShift Broker Unit", "cd li-test/stickshift/broker; rake test")
        end

        unless options.exclude_internal?
          add_ssh_cmd_to_threads(hostname, threads, failures, "Internal", "cucumber -f html --out /tmp/rhc/internals.html -f progress -t @internals li-test/tests")
        end

        unless options.exclude_verification?
          add_ssh_cmd_to_threads(hostname, threads, failures, "Verification", "cucumber -f html --out /tmp/rhc/verfication.html -f progress -t @verify li-test/tests")
        end

        if options.include_cucumber
          timeout=@@SSH_TIMEOUT
          timeout = @@SSH_TIMEOUT_OVERRIDES[options.include_cucumber] if not @@SSH_TIMEOUT_OVERRIDES[options.include_cucumber].nil?
          add_ssh_cmd_to_threads(hostname, threads, failures, "#{options.include_cucumber}", "cucumber -f html --out /tmp/rhc/#{options.include_cucumber}.html -f progress -t @#{options.include_cucumber} li-test/tests", timeout)
        end

        if options.include_web?

          # check sauce quotas first
          usage = sauce_usage options
          puts "Sauce Labs Usage: #{usage[:percentage]}% (#{usage[:used]} minutes of #{usage[:quota]})"

          if usage[:percentage] > 95 && !options[:sauce_overage]
            puts "Refusing to run Sauce Labs tests due to quota overage considerations.  Run with --sauce_overage to override."
            return
          end

          if options.sauce_os && options.sauce_browser && options.sauce_browser_version
            browsers = [[options.sauce_os, options.sauce_browser, options.sauce_browser_version]]
          else
            browsers = [['Windows 2003', 'firefox', ''],
              ['Windows 2008', 'chrome', ''],
              ['Windows 2008', 'iexplore', '9'],
              ['Windows 2003', 'safari', '']]
            # not working very well
            browsers.delete_at(2)
            browsers.delete_at(2)
          end

          browsers.each do |browser|
            sauce_os = browser[0]
            sauce_browser = browser[1]
            sauce_browser_version = browser[2]
            sauce_opts = {
              "SAUCE_USERNAME" => (options.sauce_username || 'openshift_ci'),
              "SAUCE_ACCESS_KEY" => (options.sauce_access_key || '3d67e770-ce7d-482a-8c7f-07aec039d564'),
              "SAUCE_OS" => sauce_os,
              "SAUCE_BROWSER" => sauce_browser,
              "SAUCE_BROWSER_VERSION" => sauce_browser_version,
              "SAUCE_SELENIUM_VERSION" => '2.18.0',
              "SAUCE_BROWSER_URL" => "https://#{hostname}",
              "JENKINS_BUILD" => 'unofficial'
            }
            # If we passed a jenkins build like name, use that for the build number
            if tag.start_with?('libra_') || tag.start_with?('devenv_') || tag.start_with?('devenv-')
              sauce_opts['JENKINS_BUILD'] = tag
            else
              sauce_opts['SAUCE_USERNAME'] = options.sauce_username
              sauce_opts['SAUCE_ACCESS_KEY'] = options.sauce_access_key
            end

            env_string = sauce_opts.keys.map{|k| %Q(#{k}="#{sauce_opts[k]}")}.join(' ')

            puts "Running Sauce tests with the following options:"
            puts sauce_opts.to_yaml

            Dir.foreach('selenium/testcases') do |filename|
              cmds = []
              titles = []
              if filename =~ /^tc_(.*)\.rb$/
                test = $1
                cmds << "cd li-test/selenium; #{env_string} ruby ts_web #{test}"
                titles << "Web Selenium (#{sauce_os} - #{sauce_browser} #{sauce_browser_version}) (#{test})"
              end
              add_ssh_cmd_to_threads(hostname, threads, failures, titles, cmds)
            end
          end
        end

        threads.each do |t|
          t.join
        end

        retry_threshold = 0
        retry_threshold += 6 unless options.exclude_internal?
        retry_threshold += 2 unless options.exclude_verification?
        retry_threshold += 6 if options.include_web?
        
        failures.uniq!

        begin
          if failures.length > 0 && failures.length <= retry_threshold 
            idle_all_gears(hostname)
            retry_test_failures(hostname, failures, 2)
          elsif failures.length > retry_threshold
            exit 1
          end
          validate_instance(hostname)
        ensure
          download_artifacts hostname
        end

        if options.official?
          image_id = image_id ? image_id : instance.image_id
          # Mark the image as verified
          image = conn.images[image_id]
          verify_image(image)

          print "Sending QE ready email..."
          begin
            send_verified_email(image_id, image.name)
          rescue Exception => e
            print "Failed sending email with message: #{e.message}"
          end
        elsif !options.terminate?
          idle_all_gears(hostname)
          use_public_ip(hostname, options.public_hostname?)
        end

        broker_profiler(hostname, enable=false) if options.profile_broker?

        puts "Done"

      ensure
        terminate_instance(instance) if options.terminate?
      end
    end
    
    def retry_test_failures(hostname, failures, num_retries=1, timeout=@@SSH_TIMEOUT)
      failures.reverse!
      puts "All Failures: #{failures.pretty_inspect}"
      setup_test_dir(hostname)
      failures.each do |failure|
        title = failure[0]
        cmd = failure[1]
        (1..num_retries).each do |i|
          puts "Retry attempt #{i} for: #{title}"
          output, exit_code = run_ssh(hostname, title, cmd, timeout)
          if exit_code != 0
            if i == num_retries
              exit exit_code
            else
              setup_test_dir(hostname)
            end
          else
            break
          end
        end
      end
    end

    def build_and_install(package_name, build_dir)
      remove_dir '/tmp/tito/'
      FileUtils.mkdir_p '/tmp/tito/'
      puts "Building in #{build_dir}"
      inside(File.expand_path("../#{build_dir}", File.dirname(__FILE__))) do
        # Build and install the RPM's locally
        unless run('tito build --rpm --test', :verbose => options.verbose?)
          FileUtils.rm_rf '/tmp/devenv/sync/'
          exit 1
        end
        Dir.glob('/tmp/tito/x86_64/*.rpm').each {|file|
          FileUtils.mkdir_p "/tmp/tito/noarch/"
          FileUtils.mv file, "/tmp/tito/noarch/"
        }
        unless run("rpm -Uvh --force /tmp/tito/noarch/*.rpm", :verbose => options.verbose?)
          unless run("rpm -e --justdb --nodeps #{package_name}; yum install -y /tmp/tito/noarch/*.rpm", :verbose => options.verbose?)
            FileUtils.rm_rf '/tmp/devenv/sync/'
            exit 1
          end
        end
      end
    end
  end

  desc "write_sync_history", "Write out the sync history so updates won't happen for already installed changes"

  def write_sync_history()
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
    get_sync_dirs
  end

  desc "watch", "Watch for changes to your source directory and copy them to the remote image.  Will look for ~/.openshiftdev/watch.lua for an override configuration.  Not a full replacement for 'sync' - intended to speed Rails development. Requires the lsyncd package installed."
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def watch
    raise Thor::Error, "You must install lsyncd ('sudo yum install lsyncd') in order to run the 'watch' command" if not run "which lsyncd > /dev/null", :verbose => false
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    config = File.join ENV['HOME'], '.openshiftdev/watch.lua'
    if File.exists? config
      say "Using your custom sync config '#{config}'"
    else
      say "Creating the default sync config"
      template = IO.read(repo_path('build/watch_default.lua')).gsub('{LOCAL_DIR}', "#{repo_path}")
      if options.verbose?
        puts "Lsyncd template"
        puts "----------"
        puts template
        puts "----------"
      end
      Tempfile.open('lsynctemplate') { |f| f.puts template; config = f.path }
    end

    # Rsync cannot set owner or group, so we should inherit
    ssh("verifier", "find /var/www/stickshift -type d | xargs chmod g+s", 1800)
    ssh("verifier", "find /usr/lib/ruby/site_ruby -type d | xargs chmod g+s", 1800)

    say "Watching your development directories, hit CTRL+C to stop"
    run "lsyncd #{options.verbose? ? '-log all' : ''} #{config}"
  end

  desc "build NAME BUILD_NUM", "Build a new devenv AMI with the given NAME"
  method_option :register, :type => :boolean, :desc => "Register the instance"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance on exit"
  method_option :use_stage_repo, :type => :boolean, :desc => "Build instance off the stage repository"
  method_option :reboot, :type => :boolean, :desc => "Reboot the instance after updating"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :official, :type => :boolean, :desc => "For official use.  Send emails, etc."
  method_option :exclude_internal, :type => :boolean, :desc => "Exclude running unit and internal tests"
  method_option :exclude_verification, :type => :boolean, :desc => "Exclude running verification tests"
  method_option :include_web, :type => :boolean, :desc => "Include running Selenium tests"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  method_option :build_clean_ami, :required => false, :desc => "Indicates whether to start from a base RHEL image"
  method_option :install_from_source, :required => false, :desc => "Indicates whether to build based off origin/master"
  method_option :install_from_local_source, :required => false, :desc => "Indicates whether to build based on your local source"
  method_option :skip_verify, :type => :boolean, :desc => "Skip running tests to verify the build"
  method_option :instance_type, :required => false, :desc => "Amazon machine type override (default m1.medium)"

  def build(name, build_num)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
    
    # Override the machine type to launch if necessary
    if options[:instance_type]
      $amz_options[:instance_type] = options[:instance_type]
    end

    # Establish a new connection
    conn = connect(options.region)

    image = nil
    if options.build_clean_ami || options.install_from_source || options.install_from_local_source
      # Create a new builder instance
      if (options.region?nil)
        image = conn.images[AMI["us-east-1"]]
      elsif AMI[options.region].nil?
        puts "No AMI specified for region:" + options.region
        exit 1
      else
        image = conn.images[AMI[options.region]]
      end
    else
      # Get the latest devenv image and create a new instance
      if options.use_stage_repo?
        filter = DEVENV_STAGE_CLEAN_WILDCARD
      else
        filter = DEVENV_CLEAN_WILDCARD
      end
      image = get_latest_ami(conn, filter)
    end

    instance = launch_instance(image, name + '_' + build_num)
    hostname = instance.dns_name
    
    puts "Building on: #{hostname}"

    begin
      manifest = nil
      if options.build_clean_ami || options.install_from_source || options.install_from_local_source
        # TODO - Remove this once nss is updated in RHEL 6.2
        print "Running one yum update to get around RHEL 6.2 AMI problem..."
        ssh(hostname, "yum update -y --exclude='rhc*'", 1800)
        puts "Done"

        print "Updating all packages on the system..."
        ssh(hostname, "yum update -y --exclude='rhc*'; yum -y install openssh-clients", 1800)
        puts "Done"

        if options.reboot?
          reboot(instance)
        end

        print "Uploading devenv script..."
        script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/devenv/li-devenv.sh")
        scp_to(hostname, script_path, "~/")
        puts "Done"
        print "Uploading yum client certificates..."
        script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/client-cert.pem")
        scp_to(hostname, script_path, "/var/lib/yum/")
        script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/client-key.pem")
        scp_to(hostname, script_path, "/var/lib/yum/")
        scp_to(hostname, "misc/devenv/root/.ssh/*", "/root/.ssh/")
        ssh(hostname, "chmod 0600 /root/.ssh/id_rsa; chmod 0644 /root/.ssh/id_rsa.pub /root/.ssh/known_hosts;")
        puts "Done"
        output = ''
        if options.install_from_source
          cmd = 'set -e; sh li-devenv.sh candidate --install_build_prereqs'
          output += ssh(hostname, cmd, 600)
          print "Performing clean install from source..."
          cmd = 'set -e; sh li-devenv.sh candidate --install_from_source'
        elsif options.install_from_local_source
          cmd = 'set -e; sh li-devenv.sh candidate --install_build_prereqs'
          output += ssh(hostname, cmd, 600)
          init_repo(hostname)
          ssh_path = File.expand_path(File.dirname(__FILE__)) + "/ssh-override"
          sync_repo('li', hostname, ssh_path)
          SIBLING_REPOS.each do |repo_name, repo_dirs|
            repo_dirs.each do |repo_dir|
              break if sync_sibling_repo(repo_name, repo_dir, hostname, ssh_path)
            end
          end
          print "Performing clean install from local source..."
          cmd = 'set -e; sh li-devenv.sh candidate --install_from_local_source'
        else
          print "Performing clean install with the latest code..."
          cmd = 'set -e ; sh ~/li-devenv.sh'
          cmd += ' stage' if options.use_stage_repo?
        end
        output = ssh(hostname, cmd, 3600)
        puts "Done"

        puts "----------------- Install Output ------------------------"
        puts output
        puts "---------------------------------------------------------"

        validate_instance(hostname)

        manifest = rpm_manifest(hostname)

        if options.register? && options.build_clean_ami
          register_image(conn, instance, name + '-clean_' + build_num, manifest)
        end
      else
        print "Updating all packages on the system..."
        ssh(hostname, "yum clean metadata; yum update -y --exclude='rhc-devenv'; set -e; yum update -y --exclude='rhc-devenv' --disablerepo=\\* --enablerepo=li", 600)
        puts "Done"

        validate_instance(hostname)

        manifest = rpm_manifest(hostname)
      end

      image_id = nil
      if options.register?
        image = register_image(conn, instance, name + '_' + build_num, manifest)
        image_id = image.id
      end

      unless options.skip_verify?
        scp_remote_tests(hostname)
        test_instance(name + '_' + build_num, hostname, instance, conn, options, image_id)
      end
    ensure
      terminate_instance(instance) if options.terminate?
    end
  end

  desc "update", "Update current instance by installing RPMs from local git tree"
  method_option :include_stale, :type => :boolean, :desc => "Include packages that have been tagged but not synced to the repo"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def update
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Warn on uncommitted changes
    `git diff-index --quiet HEAD`
    puts "WARNING - Uncommitted repository changes" if $? != 0

    # Figure out what needs to be built - exclude devenv for syncs
    sync_dirs = get_sync_dirs

    sync_dirs.each do |sync_dir|
      package_name = sync_dir[0]
      build_dir = sync_dir[1]
      build_and_install(package_name, build_dir)
    end
    
    if options.include_stale?
      stale_dirs = get_stale_dirs
      stale_dirs.each do |stale_dir|
        package_name = stale_dir[0]
        build_dir = stale_dir[1]
        build_and_install(package_name, build_dir)
      end
    end
    run("yum update -y --exclude='rhc-devenv' --disablerepo=\\* --enablerepo=li rhc-* rubygem-stickshift-* rubygem-gearchanger-* rubygem-uplift-* rubygem-swingshift-*", :verbose => options.verbose?)
    run("service mcollective restart; service libra-broker restart; service libra-site restart", :verbose => options.verbose?)
  end

  desc "sync NAME", "Synchronize a local git repo with a remote DevEnv instance.  NAME should be ssh resolvable."
  method_option :tag, :type => :boolean, :desc => "NAME is an Amazon tag"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :verifier, :type => :boolean, :desc => "Maintain verifier functionality (private IP setup)"
  method_option :public_hostname, :type => :boolean, :default => false, :desc => "Embed the public hostname rather than the ssh hostname"
  method_option :private_hostname, :type => :boolean, :default => false, :desc => "Embed the ssh hostname rather than the public hostname"
  method_option :skip_build, :type => :boolean, :desc => "Indicator to skip the rpm build/install"
  method_option :clean_metadata, :type => :boolean, :desc => "Cleans metadata before running yum commands"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  def sync(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Get the hostname from a tag lookup or assume it's SSH accessible directly
    conn = connect(options.region)
    hostname = options.tag? ? find_instance(conn, name, true).dns_name : name

    ssh_path=File.expand_path(File.dirname(__FILE__)) + "/ssh-override"

    sync_repo('li', hostname, ssh_path)

    avail_sibling_repo_names = []

    SIBLING_REPOS.each do |repo_name, repo_dirs|
      repo_dirs.each do |repo_dir|
        if sync_sibling_repo(repo_name, repo_dir, hostname, ssh_path)
          avail_sibling_repo_names.push(repo_name)
          break
        end
      end
    end
    update_remote_tests(hostname)

    clone_commands = ''
    working_dirs = ''
    avail_sibling_repo_names.each do |repo_name|
      working_dirs += "#{repo_name}-working "
      clone_commands += "git clone #{repo_name} #{repo_name}-working; "
    end

    if !options.skip_build?
      puts "Performing remote install...."
      output, exit_code = ssh(hostname, %{
##################
# Start shell code

set -e
#{options.clean_metadata? ? 'yum clean metadata' : ''}
rm -rf li-working #{working_dirs}

#{clone_commands}

# li repo
git clone li li-working

pushd li-working && build/devenv update#{options.verbose? ? ' --verbose' : ''} #{options.clean_metadata? ? ' --include_stale' : ''} 2>&1
popd

rm -rf li-working #{working_dirs}
#{options.clean_metadata? ? "yum update -y --exclude='rhc-devenv' rhc-* rubygem-stickshift-*  rubygem-gearchanger-* rubygem-uplift-* rubygem-swingshift-*; " : ''}

# End shell code
################
}, 600, true)

      if exit_code != 0
        puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        puts "Build failed!  Exiting."
        puts output
        puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        exit 1
      end
      puts "Done"
    end

    # If this is a verifier, you'll need to reset the private ip setup on each sync
    if options.verifier?
      if options.public_hostname?
        use_public_ip(hostname)
      elsif options.private_hostname?
        use_private_ip(hostname)
      else
        update_facts(hostname)
      end
    else
      #use_public_ip(hostname)
      update_facts(hostname)
    end
    
    run_libra_data(hostname)
  end

  desc "terminate TAG", "Terminates the instance with the specified tag"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"

  def terminate(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
    conn = connect(options.region)
    instance = find_instance(conn, tag, true)
    terminate_instance(instance, true) if instance
  end

  desc "launch NAME", "Launches the latest DevEnv instance, tagging with NAME"
  method_option :verifier, :type => :boolean, :desc => "Add verifier functionality (private IP setup and local tests)"
  method_option :public_hostname, :type => :boolean, :default => false, :desc => "Embed the public hostname rather than the ssh hostname"
  method_option :private_hostname, :type => :boolean, :default => false, :desc => "Embed the ssh hostname"
  method_option :use_stage_image, :type => :boolean, :desc => "Launch a stage DevEnv image"
  method_option :use_clean_image, :type => :boolean, :desc => "Launch a clean DevEnv image"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :express_server, :type => :boolean, :desc => "Set as express server in express.conf and leave on public_ip"
  method_option :ssh_config_verifier, :type => :boolean, :desc => "Set as verifier in .ssh/config"
  method_option :init_repo, :type => :boolean, :desc => "Initialize git repo for syncing and tests (requires --verifier)"
  method_option :instance_type, :required => false, :desc => "Amazon machine type override (default m1.medium)"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  method_option :image_name, :required => false, :desc => "AMI ID or DEVENV name to launch"

  def launch(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Override the machine type to launch if necessary
    if options[:instance_type]
      $amz_options[:instance_type] = options[:instance_type]
    end

    # Get the latest devenv image and create a new instance
    conn = connect(options.region)
    if options.use_stage_image?
      filter = DEVENV_STAGE_WILDCARD
    elsif options.use_clean_image?
      filter = DEVENV_CLEAN_WILDCARD
    else
      filter = DEVENV_WILDCARD
    end
    if options[:image_name]
      filter = options[:image_name]
      ami = get_specific_ami(conn, filter)
    else
      ami = get_latest_ami(conn, filter)
    end
    if ami.nil?
      puts "No image name '#{options[:image_name]}' found!"
      exit(1)
    else
      puts "Launching latest DevEnv instance #{ami.id}"
    end
    instance = launch_instance(ami, name)
    hostname = instance.dns_name
    puts "Done"
    puts "Hostname: #{hostname}"

    puts "Sleeping for 30 seconds to let node stabilize..."
    sleep 30
    puts "Done"

    if options.verifier?
      if options.public_hostname?
        use_public_ip(hostname)
      elsif options.private_hostname?
        use_private_ip(hostname)
      else
        update_facts(hostname)
      end

      if options.init_repo?
        print "Initializing git repo for syncing..."
        init_repo(hostname)
        puts "Done"
        update_remote_tests(instance.dns_name)
      else
        scp_remote_tests(hostname)
      end
    else
      update_facts(hostname)
    end

    run_libra_data(hostname)

    validate_instance(hostname)

    if options.ssh_config_verifier?
      public_ip = instance.public_ip_address
      ssh_config = "~/.ssh/config"
      pem_file = File.expand_path("~/.ssh/libra.pem")
      if not File.exist?(pem_file)
        # copy it from local repo
        cmd = "cp misc/libra.pem #{pem_file}"
        puts cmd
        system(cmd)
        system("chmod 600 #{pem_file}")
      end
      config_file = File.expand_path(ssh_config)

      config_template = <<END
Host verifier
  HostName 10.1.1.1
  User      root
  IdentityFile ~/.ssh/libra.pem
END

      if not FileTest.exists?(config_file)
        puts "File '#{ssh_config}' does not exists, creating..."
        system("touch #{ssh_config}")
        cmd = "chmod 600 #{ssh_config}"
        system(cmd)
        file_mode = 'w'
        File.open(config_file, file_mode) { |f| f.write(config_template) }
      else
        if not system("grep -n 'Host verifier' #{config_file}")
          file_mode = 'a'
          File.open(config_file, file_mode) { |f| f.write(config_template) }
        end

      end

      line_num = `grep -n 'Host verifier' ~/.ssh/config`.chomp.split(':')[0]
      puts "Updating ~/.ssh/config verifier entry with public ip = #{public_ip}"
      (1..4).each do |i|
        `sed -i -e '#{line_num.to_i + i}s,HostName.*,HostName #{public_ip},' ~/.ssh/config`
      end
    end

    if options.express_server?
      public_ip = instance.public_ip_address
      puts "Updating ~/.openshift/express.conf libra_server entry with public ip = #{public_ip}"
      `sed -i -e 's,^libra_server.*,libra_server=#{public_ip},' ~/.openshift/express.conf`
      #use_public_ip(hostname, options.public_hostname?)
    end

    home_dir=File.join(ENV['HOME'], '.openshiftdev/home.d')
    if File.exists?(home_dir)
      Dir.glob(File.join(home_dir, '???*'), File::FNM_DOTMATCH).each {|file|
        puts "Installing ~/#{File.basename(file)}"
        scp_to(hostname, file, "~/", File.stat(file).mode, 10)
      }
    end

    puts "Public IP:       #{instance.public_ip_address}"
    puts "Public Hostname: #{hostname}"
    puts "Site URL:        https://#{hostname}"
    puts "Done"
  end

  desc "test TAG", "Runs the tests on a tagged instance and downloads the results"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance when finished"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :official, :type => :boolean, :desc => "For official use.  Send emails, etc."
  method_option :exclude_internal, :type => :boolean, :desc => "Exclude running unit and internal tests"
  method_option :exclude_verification, :type => :boolean, :desc => "Exclude running verification tests"
  method_option :include_cucumber, :required => false, :desc => "Include a specific cucumber test (verify, internal, node, api, etc)"
  method_option :disable_charlie, :type => :boolean, :desc=> "Disable idle shutdown timer on dev instance (charlie)"
  method_option :profile_broker, :type => :boolean, :desc=> "Enable profiling code on broker"
  method_option :include_web, :type => :boolean, :desc => "Include running Selenium tests"
  method_option :sauce_username, :required => false, :desc => "Sauce Labs username (default '#{SAUCE_USER}')"
  method_option :sauce_access_key, :required => false, :desc => "Sauce Labs access key (default '#{SAUCE_SECRET}')"
  method_option :sauce_overage, :type => :boolean, :desc => "Run Sauce Labs tests even if we are over our monthly minute quota"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"

  def test(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    conn = connect(options.region)

    instance = find_instance(conn, tag, true)
    hostname = instance.dns_name

    test_instance(tag, hostname, instance, conn, options)
  end

  desc "sanity_check TAG", "Runs a set of sanity check tests on a tagged instance"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  def sanity_check(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    conn = connect(options.region)

    instance = find_instance(conn, tag, true)
    hostname = instance.dns_name

    threads = []
    failures = []
    add_ssh_cmd_to_threads(hostname, threads, failures, "Broker Unit", "cd li-test/broker; rake test")
    site_titles = ["Site Unit:Units"]
    site_cmds = ["cd li-test/site; rake test:units"]
    add_ssh_cmd_to_threads(hostname, threads, failures, site_titles, site_cmds)
    add_ssh_cmd_to_threads(hostname, threads, failures, "StickShift Node Unit", "cd li-test/stickshift/node; rake test")
    add_ssh_cmd_to_threads(hostname, threads, failures, "StickShift Broker Unit", "cd li-test/stickshift/broker; rake test")
    add_ssh_cmd_to_threads(hostname, threads, failures, "Sanity", "cucumber -f html --out /tmp/rhc/sanity.html -f progress -t @sanity li-test/tests/")

    threads.each do |t|
      t.join
    end

    unless failures.empty?
      failures.uniq!
      retry_test_failures(hostname, failures, 1)
    end
    validate_instance(hostname)
  end

  desc "setup_multi_node_broker", "Sets up verifier as a multi-node broker"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"

  def setup_multi_node_broker
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    #internal_hostname = get_internal_hostname("verifier")
    internal_ip = get_private_ip("verifier")
    ssh("verifier", "sed -i 's,^plugin.amqp.host.*=.*,plugin.amqp.host=#{internal_ip},' /etc/mcollective/client.cfg;" \
                  "sed -i 's,^plugin.amqp.host.*=.*,plugin.amqp.host=#{internal_ip},' /etc/mcollective/server.cfg;" \
                  "sed -i 's,^ssl-cert-name.*=.*,ssl-cert-name=#{internal_ip},' /etc/qpidd.conf;" \
                  "sed -i 's,^server_id.*=.*,server_id=#{internal_ip},' /etc/stickshift/devenv/qpid/make-certs.sh;" \
                  "sed -i 's,^owner_domain_name.*=.*,owner_domain_name=#{internal_ip},' /etc/stickshift/devenv/qpid/make-certs.sh;" \
                  "sed -i 's,^#-A,-A,' /etc/sysconfig/iptables;" \
                  "sed -i 's,^BROKER_HOST.*=.*,BROKER_HOST=#{internal_ip},' /etc/stickshift/stickshift-node.conf;" \
                  "pushd /etc/stickshift/devenv/qpid/ > /dev/null;" \
                  "./make-certs.sh;" \
                  "/bin/cp test/client_db/* /etc/qpid/pki/client_db/; /bin/cp test/server_db/* /etc/qpid/pki/server_db/;" \
                  "popd > /dev/null;" \
                  "restorecon -R /etc/qpid/pki/; chmod +r /etc/qpid/pki/client_db/* /etc/qpid/pki/server_db/*;" \
                  "service iptables restart; service qpidd restart; service mcollective restart", 240)

    puts ssh("verifier", "mc-ping")
  end

  desc "add_multi_node_devenv", "Adds a node to a multi node devenv setup"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"

  def add_multi_node_devenv(hostname)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    internal_hostname = get_internal_hostname("verifier")
    internal_ip = get_private_ip("verifier")

    puts `pushd /tmp > /dev/null; rm -rf /tmp/test; scp -r verifier:/etc/stickshift/devenv/qpid/test/ .; scp -r test/client_db/* #{hostname}:/etc/qpid/pki/client_db/; scp -r test/server_db/* #{hostname}:/etc/qpid/pki/server_db/; popd > /dev/null`
    puts `pushd /tmp > /dev/null; rm -rf /tmp/clients; scp -r verifier:/etc/mcollective/ssl/clients/ .; scp -r clients/* #{hostname}:/etc/mcollective/ssl/clients/; popd > /dev/null`

    ssh(hostname, "sed -i 's,^plugin.amqp.host.*=.*,plugin.amqp.host=#{internal_ip},' /etc/mcollective/server.cfg;" \
                  "restorecon -R /etc/qpid/pki/; chmod +r /etc/qpid/pki/client_db/* /etc/qpid/pki/server_db/*;" \
                  "sed -i 's,^BROKER_HOST.*=.*,BROKER_HOST=#{internal_ip},' /etc/stickshift/stickshift-node.conf;" \
                  "service qpidd stop; service mcollective restart", 240)

    puts ssh("verifier", "mc-ping")
  end

  desc "install_local_client", "Builds and installs the local client rpm (uses sudo)"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"

  def install_local_client
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    if File.exists?('../os-client-tools')
      inside('../os-client-tools') do
        temp_commit

        puts "building rhc..."
        `pushd express; tito build --rpm --test; popd;`
        puts "installing rhc..."
        `sudo rpm -Uvh --force /tmp/tito/noarch/rhc-*; rm -rf /tmp/tito; mkdir -p /tmp/tito`

        reset_temp_commit

        puts "Done"
      end
    else
      puts "Couldn't find ../os-client-tools."
    end
  end

  desc "sync_groups GROUPNAME", "Copies the security group permission from specified region to other regions"
  method_option :clean, :type => :boolean, :desc => "Revokes any existing permissions and starts fresh"
  method_option :region, :required => false, :default => 'us-east-1', :desc => "Amazon region to copy (default us-east-1)"

  def sync_groups(group_name)
    conn = connect
    origin_sg = conn.regions[options.region].security_groups.filter('group-name', group_name).first
    if(origin_sg.nil?)
      puts "Group #{group_name} not found in region #{options.region}"
      exit 1
    end
    conn.regions.each do |region|
      #skip the region of origin
      next if(region.name == options.region)

      puts "Synching #{region.name}"
      sg = conn.regions[region.name].security_groups.filter('group-name', group_name).first
      #If group does not exist then create it
      if(sg.nil?)
        sg = conn.regions[region.name].security_groups.create(group_name)
        #open access within the group
        sg.authorize_ingress(:tcp, 0..65535, sg)
        sg.authorize_ingress(:udp, 0..65535, sg)
        sg.authorize_ingress(:icmp, -1, sg)
      elsif (options.clean)
        puts "Revoking existing permissions"
        sg.ingress_ip_permissions.each do |i|
          i.revoke()
        end
        #open access within the group
        sg.authorize_ingress(:tcp, 0..65535, sg)
        sg.authorize_ingress(:udp, 0..65535, sg)
        sg.authorize_ingress(:icmp, -1, sg)
      end
      puts "Adding permissions"
      origin_sg.ingress_ip_permissions.each do |i|
        i.ip_ranges.each do |ip|
          puts "#{i.protocol}  \tport_range=#{i.port_range}\t" +
          "ip_range=#{ip} "
          begin
            sg.authorize_ingress(i.protocol , i.port_range, ip )
          rescue AWS::EC2::Errors::InvalidPermission::Duplicate
            puts "Permission already exists."
          end
        end
        i.groups.each do |g|
          if(g.owner_id != sg.owner_id)
            puts "#{i.protocol}  \tport_range=#{i.port_range}\t" +
            "group name=#{g.name} owner=#{g.owner_id} id=#{g.group_id} "
            if(g.exists?)
              begin
                sg.authorize_ingress(i.protocol , i.port_range, g )
              rescue AWS::EC2::Errors::InvalidPermission::Duplicate
                puts "Permission already exists."
              end
            else
              puts "ERROR: Group name=#{g.name} owner=#{g.owner_id} id=#{g.group_id} " +
              "does not exist or is in a different region."
            end
          end
        end
      end
    end
  end
end

DevEnv.start
