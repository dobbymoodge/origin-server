#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))

require 'rubygems'
require 'thor'
require 'fileutils'
require 'lib/openshift'
require 'pp'

class DevEnv < Thor
  include Thor::Actions
  include OpenShift::Tito
  include OpenShift::SSH
  include OpenShift::Amazon
  
  no_tasks do
    def get_branch
      branch_str = `git status | head -n1`.chomp
      branch_str =~ /.*branch (.*)/
      branch = $1 ? $1 : 'origin/master'
      return branch
    end
    
    def sync_repo(repo_name, hostname, ssh_path)
      temp_commit

      # Get the current branch
      branch = get_branch
  
      puts "Synchronizing local changes from branch #{branch} for repo #{repo_name}..."
      run("export GIT_SSH=#{ssh_path}; #{branch == 'origin/master' ? "git push -q root@#{hostname}:/root/#{repo_name} master:master --tags --force; " : ''}git push -q root@#{hostname}:/root/#{repo_name} #{branch}:master --tags --force", :verbose => options.verbose?)
      update_remote_tests(hostname) if repo_name == 'li'
      puts "Done"
  
      reset_temp_commit
    end
    
    def temp_commit
      # Warn on uncommitted changes
      `git diff-index --quiet HEAD`
  
      if $? != 0
        # Perform a temporary commit
        puts "Creating temporary commit to build"
        `git commit -a -m "Temporary commit to build"`
        if $? != 0
          puts "No-op."
        else
          @temp_commit = true
          puts "Done."
        end
      end
    end
    
    def reset_temp_commit
      if @temp_commit
        puts "Undoing temporary commit..."
        `git reset HEAD^`
        @temp_commit = false
        puts "Done."
      end
    end
    
    def update_remote_tests(hostname)
      print "Updating remote tests..."
      ssh(hostname, "rm -rf /root/li-test; cd /root/li; git archive --prefix li-test/ --format=tar HEAD | (cd /root && tar --warning=no-timestamp -xf -); mkdir -p /tmp/rhc/junit")
      puts "Done"
    end

    def download_artifacts(hostname)
      print "Downloading logs and screenshots..."
      `mkdir -p rhc/log`
      scp_from(hostname, "/tmp/rhc/*.log", "rhc/log")
      scp_from(hostname, "/tmp/rhc/*.html", "rhc/log")
      scp_from(hostname, "/var/www/libra/site/httpd/logs/access_log", "rhc/log/site_access_log.txt")
      scp_from(hostname, "/var/www/libra/site/httpd/logs/error_log", "rhc/log/site_error_log.txt")
      scp_from(hostname, "/var/www/libra/site/log/development.log", "rhc/log")
      scp_from(hostname, "/var/www/libra/broker/httpd/logs/access_log", "rhc/log/broker_access_log.log")
      scp_from(hostname, "/var/www/libra/broker/httpd/logs/error_log", "rhc/log/broker_error_log.log")
      scp_from(hostname, "/var/www/libra/broker/log/development.log", "rhc/log")
      scp_from(hostname, "/var/log/mcollective.log", "rhc/log")
      scp_from(hostname, "/var/www/libra/broker/log/mcollective-client.log", "rhc/log")
      scp_from(hostname, "/var/log/httpd/access_log", "rhc/log/system_access_log.log")
      scp_from(hostname, "/var/log/httpd/error_log", "rhc/log/system_error_log.log")
      scp_from(hostname, "/var/log/messages", "rhc/log/messages.log")
      scp_from(hostname, "/var/log/dmesg", "rhc/log/messages.log")
      scp_from(hostname, "/tmp/rhc/screenshots/", "rhc/log")
      puts "Done"
    end

    def run_ssh(hostname, title, cmd)
      output, code = ssh(hostname, cmd, 4800, true)
      puts "Output from #{title} Tests...\n----------------\n#{output}\n----------------\n"
      if code != 0
        download_artifacts hostname
        exit code
      end
    end
    
    def rpm_manifest(hostname)
      print "Retrieving RPM manifest"
      manifest = ssh(hostname, 'rpm -qa | grep rhc-')
      manifest = manifest.split("\n").sort.join(" / ")
      # Trim down the output to 255 characters
      manifest.gsub!(/rhc-([a-z])/, '\1')
      manifest.gsub!('.el6.noarch', '')
      manifest.gsub!('.el6_1.noarch', '')
      manifest.gsub!('cartridge', 'c-')
      manifest = manifest[0..254]
      puts "Done"
      return manifest
    end
    
    def validate_instance(hostname)
      # Validate the node installation
      print "Validating instance..."
      unless is_valid?(hostname)
        puts "ERROR - instance is not valid"
        exit 1
      end
      puts "Done"
    end
    
    def reboot(instance)
      print "Rebooting instance to apply new kernel..."
      instance.reboot
      puts "Done"
    end
    
  end

  desc "build NAME", "Build a new devenv AMI with the given NAME"
  method_option :register, :type => :boolean, :desc => "Register the instance"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance on exit"
  method_option :use_stage_repo, :type => :boolean, :desc => "Build instance off the stage repository"
  method_option :reboot, :type => :boolean, :desc => "Reboot the instance after updating"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def build(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Establish a new connection
    conn = connect

    # Create a new builder instance
    image = conn.images[AMI]
    instance = launch_instance(image, name)
    hostname = instance.dns_name

    begin
      print "Uploading devenv script..."
      script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/devenv/li-devenv.sh")
      scp_to(hostname, script_path, "~/")
      puts "Done"

      print "Performing clean install with the latest code..."
      cmd = 'sh li-devenv.sh'
      cmd += ' stage' if options.use_stage_repo?
      output = ssh(hostname, cmd, 3600)
      puts "Done"

      puts "----------------- Install Output ------------------------"
      puts output
      puts "---------------------------------------------------------"

      print "Updating all packages on the system..."
      ssh(hostname, "yum update -y --exclude='rhc-devenv'", 3600)
      puts "Done"

      if options.reboot?
        reboot(instance)
      end

      validate_instance(hostname)

      manifest = rpm_manifest(hostname)

      if options.register?
        register_image(conn, instance, name, manifest)
      end
    ensure
      terminate_instance(instance) if options.terminate?
    end
  end
  
  desc "yum_update TAG", "Build a new devenv AMI with the given NAME of an existing instance"
  method_option :register, :type => :boolean, :desc => "Register the instance"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance on exit"
  method_option :reboot, :type => :boolean, :desc => "Reboot the instance after updating"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def yum_update(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Establish a new connection
    conn = connect

    instance = find_instance(connect, tag, true)
    hostname = instance.dns_name

    begin
      print "Updating all packages on the system..."
      ssh(hostname, "yum clean metadata; yum update -y --exclude='rhc-devenv'; yum update -y --exclude='rhc-devenv' --disablerepo=\* --enablerepo=li", 3600)
      puts "Done"

      if options.reboot?
        reboot(instance)
      end

      validate_instance(hostname)

      manifest = rpm_manifest(hostname)

      if options.register?
        register_image(conn, instance, tag, manifest)
      end
    ensure
      terminate_instance(instance) if options.terminate?
    end
  end

  desc "update", "Update current instance by installing RPMs from local git tree"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def update
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Warn on uncommitted changes
    `git diff-index --quiet HEAD` 
    puts "WARNING - Uncommitted repository changes" if $? != 0

    remove_dir '/tmp/tito/'

    # Figure out what needs to be built - exclude devenv for syncs
    build_dirs = get_build_dirs - ['misc/devenv']
    
    # Build and install them
    build_dirs.each do |build_dir|
      puts "Building in #{build_dir}"
      inside(File.expand_path("../#{build_dir}", File.dirname(__FILE__))) do
        # Build and install the RPM's locally
        exit 1 unless run('tito build --rpm --test --install', :verbose => options.verbose?)
      end
    end
    run('service mcollective restart; service libra-broker restart; service libra-site restart', :verbose => options.verbose?)
  end

  desc "sync NAME", "Synchronize a local git repo with a remote DevEnv instance.  NAME should be ssh resolvable."
  method_option :tag, :type => :boolean, :desc => "NAME is an Amazon tag"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :verifier, :type => :boolean, :desc => "Maintain verifier functionality (private IP setup)"
  method_option :skip_build, :type => :boolean, :desc => "Indicator to skip the rpm build/install"
  def sync(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Get the hostname from a tag lookup or assume it's SSH accessible directly
    # Get the hostname from a tag lookup or assume it's SSH accessible directly
    hostname = options.tag? ? find_instance(connect, name, true).dns_name : name
    
    ssh_path=File.expand_path(File.dirname(__FILE__)) + "/ssh-override"
    sync_repo('li', hostname, ssh_path)
    
    has_client = File.exists?('../os-client-tools')
    
    if has_client
      inside('../os-client-tools') do
        sync_repo('os-client-tools', hostname, ssh_path)
      end
    end

    if !options.skip_build?
      puts "Performing remote install...."
      ssh(hostname, "yum update -y --exclude='rhc-devenv' rhc-*; rm -rf li-working os-client-tools-working; git clone li li-working;#{has_client ? ' git clone os-client-tools os-client-tools-working;' : ''} pushd li-working; build/devenv update; popd; rm -rf li-working os-client-tools-working", 600)
      puts "Done"
    end

    # If this is a verifier, you'll need to reset the private ip setup on each sync
    if options.verifier?
      use_private_ip(hostname)
    else
      use_public_ip(hostname)
    end
  end

  desc "sync_sdk NAME PATH", "Synchronize a local git repo with a remote DevEnv instance.  NAME should be ssh resolvable. PATH should be the location of the git repository to sync"
  method_option :tag, :type => :boolean, :desc => "NAME is an Amazon tag"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :skip_build, :type => :boolean, :desc => "Indicator to skip the rpm build/install"
  def sync_sdk(name, path)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Get the hostname from a tag lookup or assume it's SSH accessible directly
    hostname = options.tag? ? find_instance(connect, name, true).dns_name : name

    # Get the current branch
    branch = get_branch

    puts "Synchronizing local changes from branch #{branch}..."
    ssh_path=File.expand_path(File.dirname(__FILE__)) + "/ssh-override"

    # Don't change directories until the ssh_path has been determined from the working directory
    FileUtils.cd path 

    run("export GIT_SSH=#{ssh_path}; #{branch == 'origin/master' ? "git push -q root@#{hostname}:/root/openshift-sdk master:master --tags --force; " : ''}git push -q root@#{hostname}:/root/openshift-sdk #{branch}:master --tags --force", :verbose => options.verbose?)
    puts "Done"

    if !options.skip_build?
      puts "Performing remote install...."
      ssh(hostname, "rm -rf openshift-sdk-working; git clone openshift-sdk openshift-sdk-working; pushd openshift-sdk-working; tito build --rpm --test -i; popd; rm -rf openshift-sdk-working", 600)
      puts "Done"
    end
  end

  desc "launch NAME", "Launches the latest DevEnv instance, tagging with NAME"
  method_option :verifier, :type => :boolean, :desc => "Add verifier functionality (private IP setup and local tests)"
  method_option :use_stage_image, :type => :boolean, :desc => "Launch a stage DevEnv image"
  method_option :use_clean_image, :type => :boolean, :desc => "Launch a clean DevEnv image"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :express_server, :type => :boolean, :desc => "Set as express server in express.conf and leave on public_ip"
  method_option :ssh_config_verifier, :type => :boolean, :desc => "Set as verifier in .ssh/config"
  method_option :init_repo, :type => :boolean, :desc => "Initialize git repo for syncing and tests (requires --verifier)"
  method_option :instance_type, :required => false, :desc => "Amazon machine type override (default m1.large)"
  def launch(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Override the machine type to launch if necessary
    if options[:instance_type]
      $amz_options[:instance_type] = options[:instance_type]
    end

    # Get the latest devenv image and create a new instance
    conn = connect
    if options.use_stage_image?
      filter = DEVENV_STAGE_WILDCARD
    elsif options.use_clean_image?
      filter = DEVENV_CLEAN_WILDCARD
    else
      filter = DEVENV_WILDCARD
    end
    ami = get_latest_ami(conn, filter)
    puts "Launching latest DevEnv instance #{ami.id}"
    instance = launch_instance(ami, name)
    hostname = instance.dns_name
    puts "Done"

    puts "Sleeping for 30 seconds to let node stabilize..."
    sleep 30
    puts "Done"
   
    if options.verifier?
      use_private_ip(hostname)

      if options.init_repo?
        print "Initializing git repo for syncing..."
        ssh(hostname, "rm -rf /root/li; git clone --bare git://git1.ops.rhcloud.com/li.git/ /root/li")
        update_remote_tests(instance)
        puts "Done"
      else
        print "Archiving local changes..."
        `git archive --prefix li-test/ HEAD --output /tmp/li-test.tar`
        puts "Done"
        print "Updating tests to remote instance..."
        scp_to(hostname, "/tmp/li-test.tar", "~/", 600)
        ssh(hostname, 'rm -rf li-test; tar -xf li-test.tar; mkdir -p /tmp/rhc/junit')
        puts "Done"
      end
    end

    validate_instance(hostname)
    
    if options.ssh_config_verifier?
      public_ip = instance.public_ip_address
      
      line_num = `grep -n 'Host verifier' ~/.ssh/config`.chomp.split(':')[0]
      puts "Updating ~/.ssh/config verifier entry with public ip = #{public_ip}"
      (1..4).each do |i|
        `sed -i '#{line_num.to_i + i}s,HostName.*,HostName #{public_ip},' ~/.ssh/config`
      end
    end
    
    if options.express_server?
      public_ip = instance.public_ip_address
      puts "Updating ~/.openshift/express.conf libra_server entry with public ip = #{public_ip}"
      `sed -i 's,^libra_server.*,libra_server=#{public_ip},' ~/.openshift/express.conf`
      use_public_ip(hostname)
    end
    
    puts "Done"
  end

  desc "test TAG", "Runs the tests on a tagged instance and downloads the results"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance when finished"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :unofficial, :type => :boolean, :desc => "For unofficial use.  Do not send emails, etc."
  method_option :exclude_internal, :type => :boolean, :desc => "Exclude running unit and internal tests"
  method_option :exclude_verification, :type => :boolean, :desc => "Exclude running verification tests"
  method_option :exclude_web, :type => :boolean, :desc => "Exclude running Selenium tests"
  def test(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    conn = connect
    instance = find_instance(conn, tag, true)
    hostname = instance.dns_name

    begin
      if options.unofficial?
        use_private_ip(hostname)
      end

      threads = []

      unless options.exclude_internal?
        threads << Thread.new do
          cmd = "cd li-test/broker; rake test"
          run_ssh(hostname, "Broker Unit", cmd)
        end
        threads << Thread.new do
          cmd = "cd li-test/site; rake test"
          run_ssh(hostname, "Site Unit", cmd)
        end
      end
      
      threads << Thread.new do
        unless options.exclude_internal?
          cmd = "cucumber -f html --out /tmp/rhc/internals.html -f progress -t @internals li-test/tests/"
          run_ssh(hostname, "Internal", cmd)
        end
        unless options.exclude_verification?
          cmd = "cucumber -f html --out /tmp/rhc/verfication.html -f progress -t @verify li-test/tests/"
          run_ssh(hostname, "Verification", cmd)
        end
      end

      unless options.exclude_web?
        threads << Thread.new do
          cmd = "rm -rf /tmp/unzip* /tmp/webdriver-profile*; cd li-test/selenium; ./ts_web"
          run_ssh(hostname, "Web Selenium", cmd)
        end
      end
      
      threads.each do |t|
        t.join
      end

      validate_instance(hostname)

      # Download the successful artifacts
      download_artifacts hostname

      if !options.unofficial?
        # Mark the image as verified
        image = conn.images[instance.image_id]
        verify_image(image)
        
        print "Sending QE ready email..."
        begin
          send_verified_email(instance.image_id, image.name)
        rescue Exception => e
          print "Failed sending email with message: #{e.message}"
        end
      else
        use_public_ip(hostname)
      end
      
      puts "Done"

    ensure
      terminate_instance(instance) if options.terminate?
    end
  end

  desc "test_sdk TAG", "Runs the tests on a tagged instance and downloads the results"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance when finished"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def test_sdk(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    conn = connect
    instance = find_instance(conn, tag, true)
    hostname = instance.dns_name
    begin
      cmd = "cd /usr/lib/ruby/gems/*/gems/openshift-sdk*; rake test"
      run_ssh(hostname, "OpenShift SDK Unit", cmd)
      
      puts "Done"
    ensure
      terminate_instance(instance) if options.terminate?
    end
  end

  desc "install_local_client", "Builds and installs the local client rpm (uses sudo)"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def install_local_client
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    if File.exists?('../os-client-tools')
      inside('../os-client-tools') do
        temp_commit
        
        `rm -rf /tmp/tito/; pushd express; tito build --rpm --test; popd; sudo rpm -Uvh /tmp/tito/noarch/rhc-*;rm -rf /tmp/tito/`
    
        reset_temp_commit
    
        puts "Done"
      end
    else
      puts "Couldn't find ../os-client-tools."
    end
  end  
end

DevEnv.start
