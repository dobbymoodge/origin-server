#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))

require 'rubygems'
require 'thor'
require 'fileutils'
require 'pp'
require 'yaml'
require 'li_constants'
require File.join('lib', '..', '..', '..', 'origin-dev-tools', 'build', 'lib', 'openshift')
require File.join('lib', '..', '..', '..', 'origin-dev-tools', 'build', 'lib', 'builder')
require 'lib/openshift/sauce_labs'
require 'lib/openshift/brew'

include FileUtils

module Express
  class BuilderPlugin < StickShift::Builder
    include OpenShift::BuilderHelper
    include OpenShift::SauceLabs

    desc "write_sync_history", "Write out the sync history so updates won't happen for already installed changes"
    def write_sync_history()
      options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
      get_sync_dirs
    end
  
    desc "watch", "Watch for changes to your source directory with the 'listen' gem and copy them to the remote image. Not a full replacement for 'sync' - intended to speed Rails development."
    method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
    def watch
      config = File.join ENV['HOME'], '.openshiftdev/watch.lua'
      if File.exists? config
        say "You have #{config}, which was used for an old mechanism which relied on lsyncd to check for local file changes. It is no longer used. Please remove it."
      end
      
      @rsync_default_opts = ['-vuzt', '--chmod=ug+rwX']
    
      @source_dir_for = {
        # The trailing slash is important in order to avoid creating an
        # additional directory
        :rails  => File.join('site', '/'),
        :rpm    => File.join('server-common', '/'),
        :drupal => File.join('misc', 'devenv', 'etc', 'drupal6', '/'),
        :httpd  => File.join('misc', 'devenv', 'etc', 'httpd', '/'),
        # Drupal modules
        :'custom_forms'                    => File.join('drupal', 'drupal6-openshift-custom_forms'                   , '/'),
        :'features-blogs'                  => File.join('drupal', 'drupal6-openshift-features-blogs'                 , '/'),
        :'features-community_wiki'         => File.join('drupal', 'drupal6-openshift-features-community_wiki'        , '/'),
        :'features-forums'                 => File.join('drupal', 'drupal6-openshift-features-forums'                , '/'),
        :'features-front_page'             => File.join('drupal', 'drupal6-openshift-features-front_page'            , '/'),
        :'features-global_settings'        => File.join('drupal', 'drupal6-openshift-features-global_settings'       , '/'),
        :'features-recent_activity_report' => File.join('drupal', 'drupal6-openshift-features-recent_activity_report', '/'),
        :'features-reporting_csv_views'    => File.join('drupal', 'drupal6-openshift-features-reporting_csv_views'   , '/'),
        :'features-rules_by_category'      => File.join('drupal', 'drupal6-openshift-features-rules_by_category'     , '/'),
        :'features-user_profile'           => File.join('drupal', 'drupal6-openshift-features-user_profile'          , '/'),
        :'features-video'                  => File.join('drupal', 'drupal6-openshift-features-video'                 , '/'),
        :'modals'                          => File.join('drupal', 'drupal6-openshift-modals'                         , '/'),
        :'og_comment_perms'                => File.join('drupal', 'drupal6-openshift-og_comment_perms'               , '/'),
        :'redhat_acquia'                   => File.join('drupal', 'drupal6-openshift-redhat_acquia'                  , '/'),
        :'redhat_frontpage'                => File.join('drupal', 'drupal6-openshift-redhat_frontpage'               , '/'),
        :'redhat_events'                   => File.join('drupal', 'drupal6-openshift-redhat_events'                  , '/'),
        :'redhat_ideas'                    => File.join('drupal', 'drupal6-openshift-redhat_ideas'                   , '/'),
        :'redhat_sso'                      => File.join('drupal', 'drupal6-openshift-redhat_sso'                     , '/'),
        :'theme'                           => File.join('drupal', 'drupal6-openshift-theme'                          , '/'),
      }
    
      @target_dir_for = {
        :rails  => '/var/www/stickshift/site',
        :rpm    => '/usr/lib/ruby/site_ruby/1.8',
        :drupal => '/etc/drupal6',
        :httpd  => '/etc/httpd',
        # Drupal modules
        :'custom_forms'                    => '/etc/drupal6/all/modules/custom/custom_forms',
        :'features-blogs'                  => '/etc/drupal6/all/modules/features/blogs',
        :'features-community_wiki'         => '/etc/drupal6/all/modules/features/community_wiki',
        :'features-forums'                 => '/etc/drupal6/all/modules/features/forums',
        :'features-front_page'             => '/etc/drupal6/all/modules/features/front_page',
        :'features-global_settings'        => '/etc/drupal6/all/modules/features/global_settings',
        :'features-recent_activity_report' => '/etc/drupal6/all/modules/features/recent_activity_report',
        :'features-reporting_csv_views'    => '/etc/drupal6/all/modules/features/reporting_csv_views',
        :'features-rules_by_category'      => '/etc/drupal6/all/modules/features/rules_by_category',
        :'features-user_profile'           => '/etc/drupal6/all/modules/features/user_profile',
        :'features-video'                  => '/etc/drupal6/all/modules/features/video',
        :'modals'                          => '/etc/drupal6/all/modules/custom/modals',
        :'og_comment_perms'                => '/etc/drupal6/all/modules/custom/og_comment_perms',
        :'redhat_acquia'                   => '/etc/drupal6/all/modules/custom/redhat_acquia',
        :'redhat_frontpage'                => '/etc/drupal6/all/modules/custom/redhat_frontpage',
        :'redhat_events'                   => '/etc/drupal6/all/modules/custom/redhat_events',
        :'redhat_ideas'                    => '/etc/drupal6/all/modules/custom/redhat_ideas',
        :'redhat_sso'                      => '/etc/drupal6/all/modules/custom/redhat_sso',
        :'theme'                           => '/etc/drupal6/all/themes/openshift-theme',
      }
        
      @ignore_for = {
        :rails => ['log', 'tmp', 'httpd'],
        :rpm   => ['*.spec'],
      }
    
      @latency_for = {
        :rails => 0.2,
        :rpm => 0.2,
      }
    
      @rsync_target_host = 'verifier'
    
      begin
        require 'listen'
        if options.verbose?
          say "Using 'listen' gem"
        end
        watch_with_listen(options.verbose?)
      rescue LoadError
        warn "'listen' gem is required for the 'watch' function."
      end
    end
  
    private
    def watch_with_listen(verbose = false)
      # Rsync cannot set owner or group, so we should inherit
      set_sticky_bits_for '/var/www/stickshift'
      set_sticky_bits_for '/usr/lib/ruby/site_ruby'

      [:rails, :rpm, :drupal, :httpd].each do |component|
        start_listener_for component
      end
    
      # gather drupal modules here for organizational purposes
      [:'custom_forms', :'features-blogs', :'features-community_wiki',
        :'features-forums', :'features-front_page', :'features-global_settings',
        :'features-recent_activity_report', :'features-reporting_csv_views',
        :'features-rules_by_category', :'features-user_profile', :'features-video',
        :'modals', :'og_comment_perms', :'redhat_acquia', :'redhat_frontpage',
        :'redhat_events', :'redhat_ideas', :'redhat_sso', :'theme'].each do |drupal_module|
          start_listener_for drupal_module
      end
    
      sleep
    end
  
    def start_listener_for(component)
      Dir.chdir(File.join(File.dirname(__FILE__), '..'))
      Listen.to(@source_dir_for[component],
        :latency => @latency_for[component]).
        change(&(callback_for component, @ignore_for[component])).start(false)
    end
  
    def callback_for(component, exclude = nil)
      unless @source_dir_for[component]
        warn "#{@source_dir_for[component]} does not contain key #{component}"
        return
      end
    
      Proc.new do |modified, added, removed|
        Dir.chdir(File.join(File.dirname(__FILE__), '..'))
        run ['rsync', '-r', @rsync_default_opts, exclude ? exclude.map {|dir| "--exclude=#{dir}" } : nil, @source_dir_for[component], @rsync_target_host + ':' + @target_dir_for[component]].join(" ")
      end
    end
  
    def set_sticky_bits_for(dir, timeout = 1800)
      ssh @rsync_target_host, "find #{dir} -type d | xargs chmod g+s", timeout
    end
  
    public
    
    desc "print_packages", "Print a space separated list of packages"
    def print_packages
      packages = get_packages(true)
      packages_str = ""
      packages.keys.sort.each do |package_name|
        packages_str += " #{package_name}"
      end
      puts packages_str
    end
    
    desc "print_ignore_packages", "Print a space separated list of packages to ignore"
    method_option :include_unmodified, :type => :boolean, :desc => "Include packages which have no modifications since their last tag"
    def print_ignore_packages
      packages_str = ""
      IGNORE_PACKAGES.each do |package_name|
        packages_str += " #{package_name}"
      end

      if options.include_unmodified?
        build_dirs = get_build_dirs

        all_packages = get_packages
        build_dirs.each do |build_info|
          package_name = build_info[0]
          all_packages.delete(package_name)
        end

        all_packages.keys.each do |package_name|
          packages_str += " #{package_name}"
        end
      end

      puts packages_str
    end

    desc "sauce_usage", "Prints out usage information for sauce tests"
    method_option :sauce_username, :required => false, :desc => "Sauce Labs username (default '#{SAUCE_USER}')"
    method_option :sauce_access_key, :required => false, :desc => "Sauce Labs access key (default '#{SAUCE_SECRET}')"
    def sauce_usage
      usage = super options
      puts "Sauce Labs Usage: #{usage[:percentage]}% (#{usage[:used]} minutes of #{usage[:quota]})"
      return usage
    end

    desc "setup_multi_node_broker", "Sets up verifier as a multi-node broker"
    method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
    def setup_multi_node_broker
      options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
  
      #internal_hostname = get_internal_hostname("verifier")
      internal_ip = get_private_ip("verifier")
      ssh("verifier", "sed -i 's,^plugin.qpid.host.ha.*=.*,plugin.qpid.host.ha=#{internal_ip},' /etc/mcollective/client.cfg;" \
                    "sed -i 's,^plugin.qpid.host.ha.*=.*,plugin.qpid.host.ha=#{internal_ip},' /etc/mcollective/server.cfg;" \
                    "sed -i 's,^ssl-cert-name.*=.*,ssl-cert-name=#{internal_ip},' /etc/qpidd.conf;" \
                    "sed -i 's,^server_id.*=.*,server_id=#{internal_ip},' /etc/stickshift/devenv/qpid/make-certs.sh;" \
                    "sed -i 's,^owner_domain_name.*=.*,owner_domain_name=#{internal_ip},' /etc/stickshift/devenv/qpid/make-certs.sh;" \
                    "sed -i 's,^#-A,-A,' /etc/sysconfig/iptables;" \
                    "sed -i 's,^BROKER_HOST.*=.*,BROKER_HOST=#{internal_ip},' /etc/stickshift/stickshift-node.conf;" \
                    "pushd /etc/stickshift/devenv/qpid/ > /dev/null;" \
                    "./make-certs.sh;" \
                    "/bin/cp test/client_db/* /etc/qpid/pki/client_db/; /bin/cp test/server_db/* /etc/qpid/pki/server_db/;" \
                    "popd > /dev/null;" \
                    "restorecon -R /etc/qpid/pki/; chmod +r /etc/qpid/pki/client_db/* /etc/qpid/pki/server_db/*;" \
                    "service iptables restart; service qpidd restart; service mcollective restart", 240)
  
      puts ssh("verifier", "mco ping")
    end
  
    desc "add_multi_node_devenv", "Adds a node to a multi node devenv setup"
    method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
    def add_multi_node_devenv(hostname)
      options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
  
      internal_hostname = get_internal_hostname("verifier")
      internal_ip = get_private_ip("verifier")
  
      puts `pushd /tmp > /dev/null; rm -rf /tmp/test; scp -r verifier:/etc/stickshift/devenv/qpid/test/ .; scp -r test/client_db/* #{hostname}:/etc/qpid/pki/client_db/; scp -r test/server_db/* #{hostname}:/etc/qpid/pki/server_db/; popd > /dev/null`
      puts `pushd /tmp > /dev/null; rm -rf /tmp/clients; scp -r verifier:/etc/mcollective/ssl/clients/ .; scp -r clients/* #{hostname}:/etc/mcollective/ssl/clients/; popd > /dev/null`
  
      ssh(hostname, "sed -i 's,^plugin.qpid.host.ha.*=.*,plugin.qpid.host.ha=#{internal_ip},' /etc/mcollective/server.cfg;" \
                    "restorecon -R /etc/qpid/pki/; chmod +r /etc/qpid/pki/client_db/* /etc/qpid/pki/server_db/*;" \
                    "sed -i 's,^BROKER_HOST.*=.*,BROKER_HOST=#{internal_ip},' /etc/stickshift/stickshift-node.conf;" \
                    "service qpidd stop; service mcollective restart", 240)
  
      puts ssh("verifier", "mco ping")
    end
  
    desc "sync_groups GROUPNAME", "Copies the security group permission from specified region to other regions"
    method_option :clean, :type => :boolean, :desc => "Revokes any existing permissions and starts fresh"
    method_option :region, :required => false, :default => 'us-east-1', :desc => "Amazon region to copy (default us-east-1)"
    def sync_groups(group_name)
      conn = connect
      origin_sg = conn.regions[options.region].security_groups.filter('group-name', group_name).first
      if(origin_sg.nil?)
        puts "Group #{group_name} not found in region #{options.region}"
        exit 1
      end
      conn.regions.each do |region|
        #skip the region of origin
        next if(region.name == options.region)
  
        puts "Synching #{region.name}"
        sg = conn.regions[region.name].security_groups.filter('group-name', group_name).first
        #If group does not exist then create it
        if(sg.nil?)
          sg = conn.regions[region.name].security_groups.create(group_name)
          #open access within the group
          sg.authorize_ingress(:tcp, 0..65535, sg)
          sg.authorize_ingress(:udp, 0..65535, sg)
          sg.authorize_ingress(:icmp, -1, sg)
        elsif (options.clean)
          puts "Revoking existing permissions"
          sg.ingress_ip_permissions.each do |i|
            i.revoke()
          end
          #open access within the group
          sg.authorize_ingress(:tcp, 0..65535, sg)
          sg.authorize_ingress(:udp, 0..65535, sg)
          sg.authorize_ingress(:icmp, -1, sg)
        end
        puts "Adding permissions"
        origin_sg.ingress_ip_permissions.each do |i|
          i.ip_ranges.each do |ip|
            puts "#{i.protocol}  \tport_range=#{i.port_range}\t" +
            "ip_range=#{ip} "
            begin
              sg.authorize_ingress(i.protocol , i.port_range, ip )
            rescue AWS::EC2::Errors::InvalidPermission::Duplicate
              puts "Permission already exists."
            end
          end
          i.groups.each do |g|
            if(g.owner_id != sg.owner_id)
              puts "#{i.protocol}  \tport_range=#{i.port_range}\t" +
              "group name=#{g.name} owner=#{g.owner_id} id=#{g.group_id} "
              if(g.exists?)
                begin
                  sg.authorize_ingress(i.protocol , i.port_range, g )
                rescue AWS::EC2::Errors::InvalidPermission::Duplicate
                  puts "Permission already exists."
                end
              else
                puts "ERROR: Group name=#{g.name} owner=#{g.owner_id} id=#{g.group_id} " +
                "does not exist or is in a different region."
              end
            end
          end
        end
      end
    end




    no_tasks do
      def idle_all_gears(hostname)
        puts "Idling all gears on remote instance: #{hostname}"
        ssh(hostname, "service mcollective restart; service stickshift-proxy restart; for dir in /var/lib/stickshift/*; do if [ -d $dir ] && [ ! -h $dir ] ; then rhc-idler -n -u `basename $dir`; fi; done; service httpd graceful", 240)
        puts "Done"
      end

      def repo_path(dir='')
        File.expand_path("../#{dir}", File.dirname(__FILE__))
      end

      def disable_charlie(hostname)
        puts "Disabling automatic shutdown on remote instance: #{hostname}"
        ssh(hostname, "echo HOURS=9999 > /etc/charlie.conf", 240)
      end
  
      def broker_profiler(hostname, enable=true)
        puts "Setting broker profile enable: #{enable}"
        f=Tempfile.open('fixbroker')
        begin
          if enable
            f.puts '/config.profiler = {/,/}/ { s/\#//g; }'
          else
            f.puts '/config.profiler = {/,/}/ { s/\#//g; s/^/#/; }'
          end
          f.close
          scp_to(hostname, f.path, "/tmp/fixbroker.sed", 600, 10)
          ssh(hostname, "sed -i -f /tmp/fixbroker.sed /var/www/stickshift/broker/config/environments/development.rb", 240)
          ssh(hostname, "/sbin/service libra-broker restart", 240)
        ensure
          f.close
          f.unlink
        end
      end

      def update_facts(hostname)
        puts "Updating instance facts and running libra-data to set the public ip..."
        ssh(hostname, "sed -i \"s/.*PUBLIC_IP_OVERRIDE.*/#PUBLIC_IP_OVERRIDE=/g\" /etc/stickshift/stickshift-node.conf; sed -i \"s/.*PUBLIC_HOSTNAME_OVERRIDE.*/#PUBLIC_HOSTNAME_OVERRIDE=/g\" /etc/stickshift/stickshift-node.conf; /usr/libexec/mcollective/update_yaml.rb /etc/mcollective/facts.yaml; service libra-data start")
        puts 'Done'
      end
      
      def update_cucumber_tests(hostname, repo_parent_dir="/root", user="root")
        ssh(hostname, "cp -n #{repo_parent_dir}/li-test/stickshift/controller/test/cucumber/*.feature #{repo_parent_dir}/li-test/tests/. ", 60, false, 2, user)
      end
      
      def setup_verifier(hostname)
        print "Initializing git repo for syncing..."
        init_repo(hostname)
        puts "Done"
        update_remote_tests(hostname)
      end

      def rpm_manifest(hostname)
        print "Retrieving RPM manifest.."
        manifest = ssh(hostname, 'rpm -qa | grep rhc-')
        manifest = manifest.split("\n").sort.join(" / ")
        # Trim down the output to 255 characters
        manifest.gsub!(/rhc-([a-z])/, '\1')
        manifest.gsub!('.el6.noarch', '')
        manifest.gsub!('.el6_1.noarch', '')
        manifest.gsub!('cartridge', 'c-')
        manifest = manifest[0..254]
        puts "Done"
        return manifest
      end

      def download_artifacts(hostname)
        puts "Downloading logs and screenshots..."
        `rm -rf rhc/log; mkdir -p rhc/log/; pushd rhc/log > /dev/null; mkdir -p site/test/reports broker mcollective system screenshots selenium jbossas broker-profiler coverage; popd > /dev/null`
        scp_from(hostname, "/tmp/rhc/*", "rhc/log")
        scp_from(hostname, "/var/www/stickshift/site/httpd/logs/access_log", "rhc/log/site/access_log.log")
        scp_from(hostname, "/var/www/stickshift/site/httpd/logs/error_log", "rhc/log/site/error_log.log")
        scp_from(hostname, "/var/www/stickshift/site/log/*", "rhc/log/site")
        scp_from(hostname, "/root/li-test/site/test/reports/*", "rhc/log/site/test/reports")
        scp_from(hostname, "/root/li-test/site/log/*", "rhc/log/site")
        scp_from(hostname, "/var/www/stickshift/broker/httpd/logs/access_log", "rhc/log/broker/access_log.log")
        scp_from(hostname, "/var/www/stickshift/broker/httpd/logs/error_log", "rhc/log/broker/error_log.log")
        scp_from(hostname, "/var/www/stickshift/broker/log/*", "rhc/log/broker")
        scp_from(hostname, "/root/li-test/broker/log/*", "rhc/log/broker")
        scp_from(hostname, "/var/log/stickshift/user_action.log", "rhc/log/broker/user_action.log")
        scp_from(hostname, "/var/log/mcollective.*", "rhc/log/mcollective")
        scp_from(hostname, "/var/log/httpd/access_log", "rhc/log/system/access_log.log")
        scp_from(hostname, "/var/log/httpd/error_log", "rhc/log/system/error_log.log")
        scp_from(hostname, "/var/log/yum.log", "rhc/log/system/yum.log")
        scp_from(hostname, "/var/log/messages", "rhc/log/system/messages.log")
        scp_from(hostname, "/var/log/dmesg", "rhc/log/system/dmesg.log")
        scp_from(hostname, "/var/log/secure", "rhc/log/system/secure.log")
        scp_from(hostname, "/var/log/audit/audit.log", "rhc/log/system/audit.log")
        scp_from(hostname, "/tmp/rhc/screenshots/*", "rhc/log/screenshots")
        scp_from(hostname, "/root/li-test/selenium/output/*", "rhc/log/selenium")
        scp_from(hostname, "/var/lib/stickshift/*/*/jbossas-7/standalone/tmp/*.log", "rhc/log/jbossas")
        scp_from(hostname, "/var/lib/stickshift/*/*/jbosseap-6.0/standalone/tmp/*.log", "rhc/log/jbosseap")
        scp_from(hostname, "/tmp/rhc/benchmark.csv", "rhc/log")
        scp_from(hostname, "/tmp/broker-profiler/*", "rhc/log/broker-profiler")
        scp_from(hostname, "/tmp/rhc/*_coverage", "rhc/log/coverage")
        puts "Done"
      end

      def validate_instance(hostname, num_tries=1)
        # Validate the node installation
        puts "Validating instance..."
        (1..num_tries).each do |i|
          unless is_valid?(hostname)
            if i == num_tries
              puts "ERROR - instance is not valid"
              exit 1
            elsif i == 2
              ssh(hostname, "service libra-broker restart; service libra-site restart; service httpd restart", 60)
            end
            sleep 5
          else
            break
          end
        end
        puts "Done"
      end

      def test_impl(tag, hostname, instance, conn, options, image_id=nil)
        begin
          
          validate_instance(hostname, 4)
  
          disable_charlie(hostname) if options.disable_charlie?
          
          mcollective_logs(hostname) if options.mcollective_logs?
  
          idle_all_gears(hostname) unless options.official?
          
          reset_test_dir(hostname)
  
          broker_profiler(hostname) if options.profile_broker?
  
          test_queues = [[], [], [], []]
            
          extended_tests = nil
          if options.include_extended
            extended_tests = []
            extended_tests = options.include_extended.split(",").map do |extended_test|
              extended_test.strip
            end
          end
  
          if options.include_extended
            extended_tests.each do |extended_test|
              case extended_test
              when 'broker'
                test_queues[0] << ["REST API Group 1", "cucumber #{CUCUMBER_OPTIONS} -t @broker_api1 li-test/tests", {:retry_individually => true}]
                test_queues[1] << ["REST API Group 2", "cucumber #{CUCUMBER_OPTIONS} -t @broker_api2 li-test/tests", {:retry_individually => true}]
                test_queues[2] << ["REST API Group 3", "cucumber #{CUCUMBER_OPTIONS} -t @broker_api3 li-test/tests", {:retry_individually => true}]
                test_queues[3] << ["REST API Group 4", "cucumber #{CUCUMBER_OPTIONS} -t @broker_api4 li-test/tests", {:retry_individually => true}]
                test_queues[0] << ["Broker Domain System", "cd li-test/broker; rake test:domain_system_test", {:retry_individually => true}]
                test_queues[2] << ["StickShift Broker Unit Ext 1", "cd li-test/stickshift/broker; rake test:ss_unit_ext1", {:retry_individually => true}]
                test_queues[3] << ["Broker Usage", "cd li-test/broker; rake test:usage"]
                test_queues[0] << ["Broker Application System", "cd li-test/broker; rake test:application_system_test", {:retry_individually => true}]
                test_queues[2] << ["Broker Cartridge System", "cd li-test/broker; rake test:cartridge_system_test", {:retry_individually => true}]
              when 'runtime'
                test_queues[0] << ["Extended Runtime Group 1", "cucumber #{CUCUMBER_OPTIONS} -t @runtime_extended1 li-test/tests"]
                test_queues[1] << ["Extended Runtime Group 2", "cucumber #{CUCUMBER_OPTIONS} -t @runtime_extended2 li-test/tests"]
                test_queues[2] << ["Extended Runtime Group 3", "cucumber #{CUCUMBER_OPTIONS} -t @runtime_extended3 li-test/tests"]
              when 'site'
                test_queues[0] << ["Site Extended", "cd li-test/site; rake test:extended"]
              when 'rhc'
                test_queues[0] << ["RHC Extended", "cucumber #{CUCUMBER_OPTIONS} -t @rhc_extended li-test/tests", {:retry_individually => true}]
                base_str = "QUIET=1 RHC_SERVER=localhost cucumber #{CUCUMBER_OPTIONS} li-test/features"
                tags = [
                  [ :client, :domain, :sshkey ],
                  [ :application ],
                  [ :single_cartridge ],
                  [ :multiple_cartridge ]
                ]
                #(0..3).each do |q|
                #  tags[q].each do |tag|
                #    test_queues[q] << ["RHC Functional: #{tag}", "#{base_str} -t @#{tag} "]
                #  end
                #end

                # TODO: Tests need to run serially until they are totally isolated
                #  eg - some will destroy a domain or app that another is working on
                tags.flatten.each do |tag|
                  test_queues[0] << ["RHC Functional: #{tag}", "#{base_str} -t @#{tag}", {:retry_individually => true}]
                end

              else
                puts "Not supported for extended: #{extended_test}"
                exit 1
              end
            end
          elsif options.include_rcov?
            test_queues[0] << ["StickShift Node Unit Coverage", "cd li-test/stickshift/node; rake rcov; cp -a coverage /tmp/rhc/stickshift_node_coverage"]
            test_queues[1] << ["Broker Unit and Functional Coverage", "cd li-test/broker; rake rcov; cp -a test/coverage /tmp/rhc/broker_coverage"]
            test_queues[2] << ["StickShift Broker Unit and Functional Coverage", "cd li-test/stickshift/broker; rake rcov; cp -a test/coverage /tmp/rhc/stickshift_broker_coverage"]
          elsif options.include_cucumber
            timeout = @@SSH_TIMEOUT
            timeout = @@SSH_TIMEOUT_OVERRIDES[options.include_cucumber] if not @@SSH_TIMEOUT_OVERRIDES[options.include_cucumber].nil?
            test_queues[0] << [options.include_cucumber, "cucumber #{CUCUMBER_OPTIONS} -t @#{options.include_cucumber} li-test/tests", {:timeout => timeout}]
          elsif options.include_web?
  
            # check sauce quotas first
            usage = sauce_usage
  
            if usage[:percentage] > 95 && !options[:sauce_overage]
              puts "Refusing to run Sauce Labs tests due to quota overage considerations.  Run with --sauce_overage to override."
              return
            end
  
            # TODO: respect sauce username and access key settings
            cmd = "service sauce-connect start"
            run_ssh(hostname, "Start sauce connect tunnel", cmd, timeout)
  
            if options.sauce_os && options.sauce_browser && options.sauce_browser_version
              browsers = [[options.sauce_os, options.sauce_browser, options.sauce_browser_version]]
            else
              browsers = [['Windows 2003', 'firefox', ''],
                ['Windows 2008', 'chrome', ''],
                ['Windows 2008', 'iexplore', '9'],
                ['Windows 2003', 'safari', '']]
              # not working very well
              browsers.delete_at(2)
              browsers.delete_at(2)
            end
  
            browsers.each do |browser|
              sauce_os = browser[0]
              sauce_browser = browser[1]
              sauce_browser_version = browser[2]
              sauce_opts = {
                "SAUCE_USERNAME" => (options.sauce_username || 'openshift_ci'),
                "SAUCE_ACCESS_KEY" => (options.sauce_access_key || '3d67e770-ce7d-482a-8c7f-07aec039d564'),
                "SAUCE_OS" => sauce_os,
                "SAUCE_BROWSER" => sauce_browser,
                "SAUCE_BROWSER_VERSION" => sauce_browser_version,
                "SAUCE_SELENIUM_VERSION" => '2.7.0',
                "SAUCE_BROWSER_URL" => "https://#{hostname}/app",
                "JENKINS_BUILD" => 'unofficial'
              }
              # If we passed a jenkins build like name, use that for the build number
              if tag.start_with?('libra_') || tag.start_with?('devenv_') || tag.start_with?('devenv-')
                sauce_opts['JENKINS_BUILD'] = tag
              else
                sauce_opts['SAUCE_USERNAME'] = options.sauce_username
                sauce_opts['SAUCE_ACCESS_KEY'] = options.sauce_access_key
              end
  
              env_string = sauce_opts.keys.map{|k| %Q(#{k}="#{sauce_opts[k]}")}.join(' ')
  
              puts "Running Sauce tests with the following options:"
              puts sauce_opts.to_yaml
  
              pos = 0
              Dir.foreach('selenium/testcases') do |filename|
                if filename =~ /^tc_(.*)\.rb$/
                  test = $1
                  test_queues[pos] << ["Web Selenium (#{sauce_os} - #{sauce_browser} #{sauce_browser_version}) (#{test})", "cd li-test/selenium; #{env_string} ruby ts_web #{test}"]
                  if pos == test_queues.length - 1
                    pos = 0
                  else 
                    pos += 1
                  end
                end
              end
            end
          else
  
            unless options.exclude_broker?
              test_queues[0] << ["Broker Unit", "cd li-test/broker; rake test:units"]
              test_queues[1] << ["Broker Functional", "cd li-test/broker; rake test:functionals"]
              test_queues[0] << ["Broker Integration", "cd li-test/broker; rake test:integration"]
              test_queues[1] << ["StickShift Broker Functional", "cd li-test/stickshift/broker; rake test:functionals"]
              test_queues[0] << ["StickShift Broker Integration", "cd li-test/stickshift/broker; rake test:integration"]

              test_queues[2] << ["StickShift Broker Unit 1", "cd li-test/stickshift/broker; rake test:ss_unit1"]
              test_queues[2] << ["StickShift Broker Unit 2", "cd li-test/stickshift/broker; rake test:ss_unit2"]
              test_queues[3] << ["Broker Cucumber", "cucumber --strict -f html --out /tmp/rhc/broker_cucumber.html -f progress -t @broker li-test/tests"]
            end

            unless options.exclude_runtime?
              test_queues[0] << ["Runtime Unit", "cd li-test/stickshift/node; rake unit_test"]
              (1..4).each do |i|
                test_queues[i-1] << ["Runtime Group #{i.to_s}", "cucumber #{CUCUMBER_OPTIONS} -t @runtime#{i.to_s} li-test/tests"]
              end
            end
  
            unless options.exclude_site?
              test_queues[0] << ["Site Check Applications", "cd li-test/site; rake test:check:applications"]
              test_queues[1].unshift ["Site Check Base", "cd li-test/site; rake test:check:base"]
              test_queues[1] << ["Site Check Cartridges", "cd li-test/site; rake test:check:cartridges"]
              test_queues[2] << ["Site Check Miscellaneous 1", "cd li-test/site; rake test:check:misc1"]
              test_queues[3] << ["Site Check REST API Integration", "cd li-test/site; rake test:check:restapi_integration"]
            end

            unless options.exclude_rhc?
            end
          end
  
          threads = []
          failures = []
  
          retry_threshold = 0
          test_queues.each do |test_queue|
            titles = []
            cmds = []
            retry_individually = []
            timeouts = []
            test_queue.each do |test|
              titles << test[0]
              cmds << test[1]
              opts = test[2] || {}
              retry_individually << opts[:retry_individually] ? true : false
              timeouts << opts[:timeout] ? opts[:timeout] : @@SSH_TIMEOUT
              retry_threshold += 8
            end
            add_ssh_cmd_to_threads(hostname, threads, failures, titles, cmds, retry_individually, timeouts)
          end
  
          threads.each do |t|
            t[0].join
          end
  
          failures.uniq!
  
          begin
            if failures.length > 0 && failures.length <= retry_threshold 
              idle_all_gears(hostname)
              retry_test_failures(hostname, failures, 2)
            elsif failures.length > retry_threshold
              exit 1
            end
  
            # These are special tests that cannot be written to work concurrently
            if options.include_extended
              extended_tests.each do |extended_test|
                case extended_test
                when 'broker'
                when 'runtime'
                  idle_all_gears(hostname)
                  singleton_queue = ['Singletons', "cucumber #{CUCUMBER_OPTIONS} -t @singleton li-test/tests"]
                  output, exit_code = run_ssh(hostname, singleton_queue[0], singleton_queue[1])
                  retry_test_failures(hostname, [singleton_queue], 2) if 0 != exit_code
                when 'site'
                when 'rhc'
                else
                  puts "Not supported for extended: #{extended_test}"
                  exit 1
                end
              end
            end
  
            validate_instance(hostname, 4)
          ensure
            if options.include_web?
              cmd = "service sauce-connect stop"
              run_ssh(hostname, "Stop sauce connect tunnel", cmd, timeout)
            end
          end
  
          if options.official?
            image_id = image_id ? image_id : instance.image_id
            # Mark the image as verified
            image = conn.images[image_id]
            verify_image(image)
  
            puts "Sending QE ready email..."
            begin
              send_verified_email(image_id, image.name)
            rescue Exception => e
              puts "Failed sending email with message: #{e.message}"
            end
          elsif !options.terminate?
            idle_all_gears(hostname)
          end
  
          broker_profiler(hostname, enable=false) if options.profile_broker?
  
          puts "Done"
  
        ensure
          if options.terminate? || options.official?
            download_artifacts(hostname)
          end
          if options.terminate?
            terminate_instance(instance)
          end
        end
      end
    
      def build_impl(name, build_num, image, conn, options)
        puts "Launching instance of AMI: #{image.id} - #{image.name}"
        instance = launch_instance(image, name + '_' + build_num)
        hostname = instance.dns_name
        
        puts "Building on: #{hostname}"
    
        begin
          manifest = nil
          begin
            if options.build_clean_ami? || options.install_from_source? || options.install_from_local_source? || options.install_required_packages? 
              puts "Updating all packages on the system..."
              2.times do
                ssh(hostname, "yum update -y --exclude='rhc*'; yum -y install openssh-clients", 1800)
              end
              puts "Done"
    
              if options.reboot?
                reboot(instance)
              end
    
              puts "Uploading devenv script..."
              script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/devenv/li-devenv.sh")
              scp_to(hostname, script_path, "~/")
              puts "Done"
              puts "Uploading yum client certificates..."
              script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/client-cert.pem")
              scp_to(hostname, script_path, "/var/lib/yum/")
              script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/client-key.pem")
              scp_to(hostname, script_path, "/var/lib/yum/")
              scp_to(hostname, "misc/devenv/root/.ssh/*", "/root/.ssh/")
              ssh(hostname, "chmod 0600 /root/.ssh/id_rsa; chmod 0644 /root/.ssh/id_rsa.pub /root/.ssh/known_hosts;")
              puts "Done"
              output = ''
              if options.install_from_source?
                puts "Performing clean install from source..."
                cmd = "set -e; /bin/bash li-devenv.sh #{options.use_stage_repo? ? "stage" : "candidate"} --install_from_source"
              elsif options.install_from_local_source?
                init_repo(hostname)
                SIBLING_REPOS.each do |repo_name, repo_dirs|
                  repo_dirs.each do |repo_dir|
                    break if sync_sibling_repo(repo_name, repo_dir, hostname)
                  end
                end
                puts "Performing clean install from local source..."
                cmd = "set -e; /bin/bash li-devenv.sh #{options.use_stage_repo? ? "stage" : "candidate"} --install_from_local_source"
              elsif options.install_required_packages?
                puts "Installing requires..."
                cmd = "set -e; /bin/bash li-devenv.sh #{options.use_stage_repo? ? "stage" : "candidate"} --install_build_prereqs"
                output += ssh(hostname, cmd, 600)
                cmd = "set -e; /bin/bash li-devenv.sh #{options.use_stage_repo? ? "stage" : "candidate"} --install_required_packages"
              else
                puts "Performing clean install with the latest code..."
                cmd = 'set -e ; /bin/bash ~/li-devenv.sh'
                if options.use_stage_repo?
                  cmd += ' stage'
                elsif options.use_test_repo?
                  cmd += ' test' 
                end
              end
              output, exit_code = ssh(hostname, cmd, 3600, true)
              puts "Done"
    
              puts "----------------- Install Output ------------------------"
              puts output
              puts "---------------------------------------------------------"
    
              exit exit_code unless exit_code == 0
    
              validate_instance(hostname, 4) unless options.install_required_packages?
    
              manifest = rpm_manifest(hostname)
    
              if options.register? && options.build_clean_ami?
                register_image(conn, instance, name + '-clean_' + build_num, manifest)
              end
            else
              puts "Updating all packages on the system..."
              output, exit_code = ssh(hostname, "yum clean metadata; yum update -y --exclude='rhc-devenv'; set -e; yum update -y --exclude='rhc-devenv' --disablerepo=\\* --enablerepo=li", 600, true)
              puts "Done"
    
              puts "------------------ Update Output ------------------------"
              puts output
              puts "---------------------------------------------------------"
              
              exit exit_code unless exit_code == 0
    
              validate_instance(hostname, 4)
    
              manifest = rpm_manifest(hostname)
            end
          rescue SystemExit => e
            download_artifacts(hostname) if options.terminate? || options.official?
            raise
          end
          
          output = ssh(hostname, "yum list installed", 120)
    
          puts "---------------- Installed Packages ---------------------"
          puts output
          puts "---------------------------------------------------------"
    
          image_id = nil
          if options.register?
            image = register_image(conn, instance, name + '_' + build_num, manifest)
            image_id = image.id
          end
    
          unless options.skip_verify? || options.install_required_packages?
            scp_remote_tests(hostname)
            test_impl(name + '_' + build_num, hostname, instance, conn, options, image_id)
          end
        ensure
          terminate_instance(instance) if options.terminate?
        end
      end

      def update_impl(options)
        # Warn on uncommitted changes
        `git diff-index --quiet HEAD`
        puts "WARNING - Uncommitted repository changes" if $? != 0
    
        # Figure out what needs to be built - exclude devenv for syncs
        sync_dirs = get_sync_dirs
    
        sync_dirs.each do |sync_dir|
          package_name = sync_dir[0]
          build_dir = sync_dir[1]
          spec_file = sync_dir[2]

          if package_name.include? "origin" || package_name == "stickshift-broker"
              puts "Skipping #{package_name}"
              return
          else
            build_and_install(package_name, build_dir, spec_file)
          end
        end
        
        if options.include_stale?
          stale_dirs = get_stale_dirs
          stale_dirs.each do |stale_dir|
            package_name = stale_dir[0]
            build_dir = stale_dir[1]
            spec_file = stale_dir[2]

            if package_name.include? "origin" || package_name == "stickshift-broker"
                puts "Skipping #{package_name}"
                return
            else
              build_and_install(package_name, build_dir, spec_file)
            end
          end
        end
        #run("yum update -y --exclude='rhc-devenv' --disablerepo=\\* --enablerepo=li rhc-* cartridge-* rubygem-stickshift-* rubygem-gearchanger-* rubygem-uplift-* rubygem-swingshift-*", :verbose => options.verbose?)
        run("service mcollective restart; service libra-broker restart; service libra-site restart", :verbose => options.verbose?)
      end

      def sync_impl(name, options)
        hostname = get_host_by_name_or_tag(name, options)

        # get the necessary repos cloned out to the instance
        clone_commands, working_dirs = sync_available_sibling_repos(hostname)
        update_remote_tests(hostname)

        if !options.skip_build?
          puts "Performing remote install...."
          output, exit_code = ssh(hostname, %{
##################
# Start shell code

set -e
#{options.clean_metadata? ? 'yum clean metadata' : ''}
rm -rf #{working_dirs}

#{clone_commands}

rm -rf origin-dev-tools
mv origin-dev-tools-working origin-dev-tools

pushd li-working > /dev/null
  build/devenv update#{options.verbose? ? ' --verbose' : ''} #{options.clean_metadata? ? ' --include_stale' : ''} 2>&1
popd > /dev/null

rm -rf #{working_dirs}
#{options.clean_metadata? ? "yum update -y --exclude='rhc-devenv' rhc-* cartridge-* rubygem-stickshift-* rubygem-gearchanger-* rubygem-uplift-* rubygem-swingshift-*; " : ''}

#{options.clean_metadata? ? '/bin/bash li-test/misc/devenv/li-devenv.sh --install_templates' : ''} 

# End shell code
################
}, 900, true)

          if exit_code != 0
            puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
            puts "Build failed!  Exiting."
            puts output
            puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
            exit 1
          end
          puts "Done"
        end
      end
  
      def sanity_check_impl(tag, hostname, instance, conn, options)
        validate_instance(hostname)
    
        threads = []
        failures = []
        site_titles = ["Site Sanity"]
        site_cmds = ["cd li-test/site; rake test:sanity"]
        add_ssh_cmd_to_threads(hostname, threads, failures, site_titles, site_cmds)
        titles = ["Broker Sanity",
                  "StickShift Broker Sanity",
                  "StickShift Node Unit"]
    
        cmds = ["cd li-test/broker; rake test:sanity",
                "cd li-test/stickshift/broker; rake test:sanity",
                "cd li-test/stickshift/node; rake test"]
        add_ssh_cmd_to_threads(hostname, threads, failures, titles, cmds)
        add_ssh_cmd_to_threads(hostname, threads, failures, "Cucumber Sanity", "cucumber #{CUCUMBER_OPTIONS} -t @sanity li-test/tests/")
    
        threads.each do |t|
          t[0].join
        end
    
        unless failures.empty?
          failures.uniq!
          retry_test_failures(hostname, failures, 1)
        end
        validate_instance(hostname)
      end
      
      def update_facts_impl(hostname)
        update_facts(hostname)
      end
    end # no_tasks end
  end # class end
end # module end
Express::BuilderPlugin.start
