#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))

require 'rubygems'
require 'thor'
require 'fileutils'
require 'lib/openshift'
require 'pp'

include OpenShift::AWS

class DevEnv < Thor
  include Thor::Actions
  include OpenShift::Tito
  
  no_tasks do
    def get_private_ip(instance)
      private_ip = instance.ssh("facter ipaddress")
      if !private_ip or private_ip.strip.empty?
        puts "EXITING - AMZ instance didn't return ipaddress fact"
        exit 0
      end
      private_ip
    end
    
    def set_private_ip(instance)
      private_ip = get_private_ip(instance)
      set_instance_ip(instance, private_ip)
    end
    
    def set_public_ip(instance)
      public_ip = instance.ssh("wget -qO- http://169.254.169.254/latest/meta-data/public-ipv4")
      set_instance_ip(instance, public_ip)
    end
    
    def set_instance_ip(instance, ip)
      print "Updating the controller to use the ip '#{ip}'..."
      # Both calls below are needed to fix a race condition between ssh and libra-data start times
      instance.ssh("sed -i \"s/.*public_ip.*/public_ip='#{ip}'/g\" /etc/libra/node.conf;sed -i \"s/public_ip.*/public_ip='#{ip}'/g\" /etc/libra/node_data.conf")
      puts 'Done'
    end
    
    def get_branch
      branch_str = `git status | head -n1`.chomp
      branch_str =~ /.*branch (.*)/
      branch = $1 ? $1 : 'origin/master'
      return branch
    end
    
    def temp_commit
      # Warn on uncommitted changes
      `git diff-index --quiet HEAD`
  
      if $? != 0
        # Perform a temporary commit to build client
        puts "Creating temporary commit to build client"
        `git commit -a -m "Temporary commit to build client"`
        if $? != 0
          puts "No-op."
        else
          @temp_commit = true
          puts "Done."
        end
      end
    end
    
    def reset_temp_commit
      if @temp_commit
        puts "Undoing temporary commit..."
        `git reset HEAD^`
        puts "Done."
      end
    end
    
    def update_remote_tests(instance)
      print "Updating remote tests..."
      instance.ssh("rm -rf /root/li-test; cd /root/li; git archive --prefix li-test/ --format=tar HEAD | (cd /root && tar --warning=no-timestamp -xf -); mkdir -p /tmp/rhc/junit")
      puts "Done"
    end

    def run_ssh(instance, title, cmd)
      puts "Running " + title + " Tests..."
      output, code = instance.ssh(cmd, 4800, true)
      puts output
      exit code if code != 0
      puts "Done"
    end
  end

  desc "build NAME", "Build a new devenv AMI with the given NAME"
  method_option :register, :type => :boolean, :desc => "Register the instance"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance on exit"
  method_option :use_stage_repo, :type => :boolean, :desc => "Build instance off the stage repository"
  method_option :reboot, :type => :boolean, :desc => "Reboot the instance after updating"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def build(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Establish a new connection
    conn = connect

    # Create a new builder instance
    instance = Instance.create(conn, name)

    begin
      print "Uploading devenv script..."
      script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/devenv/li-devenv.sh")
      instance.scp_to(script_path, "~/")
      puts "Done"

      print "Performing clean install with the latest code..."
      cmd = 'sh li-devenv.sh'
      cmd += ' stage' if options.use_stage_repo?
      output = instance.ssh(cmd, 1800)
      puts "Done"

      puts "----------------- Install Output ------------------------"
      puts output
      puts "---------------------------------------------------------"

      print "Updating all packages on the system..."
      instance.ssh('yum update -y', 1800)
      puts "Done"

      if options.reboot?
        print "Rebooting instance to apply new kernel..."
        instance.reboot
        puts "Done"
      end

      # Validate the node installation
      print "Validating instance..."
      unless instance.is_valid?
        puts "ERROR - instance is not valid"
        exit 1
      end
      puts "Done"

      print "Retrieving RPM manifest"
      manifest = instance.ssh('rpm -qa | grep rhc-')
      manifest = manifest.split("\n").sort.join(" / ")
      # Trim down the output to 255 characters
      manifest.gsub!(/rhc-([a-z])/, '\1')
      manifest.gsub!('.el6.noarch', '')
      manifest.gsub!('.el6_1.noarch', '')
      manifest.gsub!('cartridge', 'c-')
      manifest = manifest[0..254]
      puts "Done"

      if options.register?
        print "Registering AMI..."
        Image.register(conn, instance.amz_id, name, manifest)
        puts "Done"
      end
    ensure
      instance.terminate if options.terminate?
    end
  end

  desc "update", "Update current instance by installing RPMs from local git tree"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def update
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Warn on uncommitted changes
    `git diff-index --quiet HEAD` 
    puts "WARNING - Uncommitted repository changes" if $? != 0

    remove_dir '/tmp/tito/'

    # Figure out what needs to be built - exclude devenv for syncs
    build_dirs = get_build_dirs - ['misc/devenv']

    # Build and install them
    build_dirs.each do |build_dir|
      puts "Building in #{build_dir}"
      inside(File.expand_path("../#{build_dir}", File.dirname(__FILE__))) do
        # Build and install the RPM's locally
        exit 1 unless run('tito build --rpm --test --install', :verbose => options.verbose?)
      end
    end
    run('service mcollective restart; service libra-broker restart; service libra-site restart', :verbose => options.verbose?)
  end

  desc "sync NAME", "Synchronize a local git repo with a remote DevEnv instance.  NAME should be ssh resolvable."
  method_option :tag, :type => :boolean, :desc => "NAME is an Amazon tag"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :verifier, :type => :boolean, :desc => "Maintain verifier functionality (private IP setup)"
  method_option :skip_build, :type => :boolean, :desc => "Indicator to skip the rpm build/install"
  def sync(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    temp_commit

    if options.tag?
      instance = Instance.find(connect, name)
    else
      instance = Instance.new(nil, nil)
      instance.dns = name
    end

    # Get the current branch
    branch = get_branch

    puts "Synchronizing local changes from branch #{branch}..."
    ssh_path=File.expand_path(File.dirname(__FILE__)) + "/ssh-override"
    run("export GIT_SSH=#{ssh_path}; #{branch == 'origin/master' ? "git push -q root@#{instance.dns}:/root/li master:master --tags --force; " : ''}git push -q root@#{instance.dns}:/root/li #{branch}:master --tags --force", :verbose => options.verbose?)
    update_remote_tests(instance)
    puts "Done"

    reset_temp_commit

    if !options.skip_build?
      puts "Performing remote install...."
      instance.ssh("yum update -y rhc-*; rm -rf li-working; git clone li li-working; pushd li-working; build/devenv update; popd; rm -rf li-working", 600)
      puts "Done"
    end

    # If this is a verifier, you'll need to reset the private ip setup on each sync
    if options.verifier?
      set_private_ip(instance)
      instance.ssh("/usr/bin/puppet /usr/libexec/mcollective/update_yaml.pp")
    else
      set_public_ip(instance)
    end
  end

  desc "launch NAME", "Launches the latest DevEnv instance, tagging with NAME"
  method_option :verifier, :type => :boolean, :desc => "Add verifier functionality (private IP setup and local tests)"
  method_option :use_stage_image, :type => :boolean, :desc => "Launch a stage DevEnv image"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :express_server, :type => :boolean, :desc => "Set as express server in express.conf and leave on public_ip"
  method_option :ssh_config_verifier, :type => :boolean, :desc => "Set as verifier in .ssh/config"
  method_option :init_repo, :type => :boolean, :desc => "Initialize git repo for syncing and tests (requires --verifier)"
  method_option :instance_type, :required => false, :desc => "Amazon machine type override (default m1.large)"
  def launch(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Override the machine type to launch if necessary
    if options[:instance_type]
      $amz_options[:instance_type] = options[:instance_type]
    end

    # Get the latest devenv image and create a new instance
    conn = connect
    filter = options.use_stage_image? ? DEVENV_STAGE_REGEX : DEVENV_REGEX
    latest = get_latest_ami(conn, filter)
    puts "Launching latest DevEnv instance #{latest}"
    instance = Instance.create(conn, name, latest)
    puts "Done"
    
    private_ip = get_private_ip(instance)
    
    print "Updating the node to use the ip '#{private_ip}' for internal communication..."
    instance.ssh("sed -i \"s/.*libra_server.*/libra_server='#{private_ip}'/g\" /etc/libra/node.conf")
    puts 'Done'

    if options.verifier?
      set_instance_ip(instance, private_ip)
      instance.ssh("/usr/bin/puppet /usr/libexec/mcollective/update_yaml.pp")

      if options.init_repo?
        print "Initializing git repo for syncing..."
        instance.ssh("rm -rf /root/li; git clone --bare git://git1.ops.rhcloud.com/li.git/ /root/li")
        update_remote_tests(instance)
        puts "Done"
      else
        print "Archiving local changes..."
        `git archive --prefix li-test/ HEAD --output /tmp/li-test.tar`
        puts "Done"
        print "Updating tests to remote instance..."
        instance.scp_to("/tmp/li-test.tar", "~/", 600)
        instance.ssh('rm -rf li-test; tar -xf li-test.tar; mkdir -p /tmp/rhc/junit')
        puts "Done"
      end
    end

    puts "Validating instance..."
    unless instance.is_valid?
      puts "ERROR - instance is not valid"
      exit 1
    end
    
    if options.ssh_config_verifier?
      public_ip = instance.ssh("wget -qO- http://169.254.169.254/latest/meta-data/public-ipv4")
      
      line_num = `grep -n 'Host verifier' ~/.ssh/config`.chomp.split(':')[0]
      puts "Updating ~/.ssh/config verifier entry with public ip = #{public_ip}"
      (1..4).each do |i|
        `sed -i '#{line_num.to_i + i}s,HostName.*,HostName #{public_ip},' ~/.ssh/config`
      end
    end
    
    if options.express_server?
      public_ip = instance.ssh("wget -qO- http://169.254.169.254/latest/meta-data/public-ipv4")
      puts "Updating ~/.openshift/express.conf libra_server entry with public ip = #{public_ip}"
      `sed -i 's,^libra_server.*,libra_server=#{public_ip},' ~/.openshift/express.conf`
      set_instance_ip(instance, public_ip)
    end
    
    puts "Done"
  end

  desc "test TAG", "Runs the tests on a tagged instance and downloads the results"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance when finished"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :unofficial, :type => :boolean, :desc => "For unofficial use.  Do not send emails, etc."
  method_option :exclude_internal, :type => :boolean, :desc => "Exclude running unit and internal tests"
  method_option :exclude_verification, :type => :boolean, :desc => "Exclude running verification tests"
  method_option :exclude_web, :type => :boolean, :desc => "Exclude running Selenium tests"
  def test(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    conn = connect
    instance = Instance.find(conn, tag)

    begin
      if options.unofficial?
        set_private_ip(instance)
      end

      unless options.exclude_internal?
        cmd = "cd li-test/broker; rake test"
        run_ssh(instance, "Broker Unit", cmd)

        cmd = "cd li-test/site; rake test"
        run_ssh(instance, "Site Unit", cmd)

        cmd = "cucumber -f html --out /tmp/rhc/internals.html -f progress -t @internals li-test/tests/"
        run_ssh(instance, "Internal", cmd)
      end

      unless options.exclude_verification?
        cmd = "cucumber -f html --out /tmp/rhc/verfication.html -f progress -t @verify li-test/tests/"
        run_ssh(instance, "Verification", cmd)
      end

      unless options.exclude_web?
        cmd = "rm -rf /tmp/unzip* /tmp/webdriver-profile*; cd li-test/selenium; ./ts_web"
        run_ssh(instance, "Web Selenium", cmd)
      end

      print "Validating instance..."
      unless instance.is_valid?
        puts "ERROR - instance is not valid"
        exit 1
      end
      puts "Done"

      print "Downloading logs and screenshots..."
      `mkdir -p rhc/log`
      instance.scp_from("/tmp/rhc/cucumber*.log", "rhc/log")
      instance.scp_from("/tmp/rhc/*.html", "rhc/log")
      instance.scp_from("/tmp/rhc/failures.log", "rhc/log")
      instance.scp_from("/var/www/libra/site/httpd/logs/access_log", "rhc/log/site_access_log.txt")
      instance.scp_from("/var/www/libra/site/httpd/logs/error_log", "rhc/log/site_error_log.txt")
      instance.scp_from("/var/www/libra/site/log/development.log", "rhc/log")
      instance.scp_from("/var/www/libra/broker/httpd/logs/access_log", "rhc/log/broker_access_log.log")
      instance.scp_from("/var/www/libra/broker/httpd/logs/error_log", "rhc/log/broker_error_log.log")
      instance.scp_from("/var/www/libra/broker/log/development.log", "rhc/log")
      instance.scp_from("/var/log/mcollective.log", "rhc/log")
      instance.scp_from("/var/www/libra/broker/log/mcollective-client.log", "rhc/log")
      instance.scp_from("/var/log/httpd/access_log", "rhc/log/system_access_log.log")
      instance.scp_from("/var/log/httpd/error_log", "rhc/log/system_error_log.log")
      instance.scp_from("/var/log/messages", "rhc/log/messages.log")
      instance.scp_from("/var/log/dmesg", "rhc/log/messages.log")
      instance.scp_from("li-tests/selenium/*.png", "rhc/log")
      puts "Done"

      if !options.unofficial?
        # Mark the image as verified
        Image.verify(conn, instance.amz_image_id)
        amz_image_name = Image.get_name(conn, instance.amz_image_id)
        
        print "Sending QE ready email..."
        begin
          send_verified_email(instance.amz_image_id, amz_image_name)
        rescue Exception => e
          print "Failed sending email with message: #{e.message}"
        end
      else
        set_public_ip(instance)
      end
      
      puts "Done"

    ensure
      instance.terminate if options.terminate?
    end
  end

  desc "install_local_client", "Builds and installs the local client rpm (uses sudo)"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def install_local_client
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Warn on uncommitted changes
    temp_commit
    
    `rm -rf /tmp/tito/; pushd client; tito build --rpm --test; popd; sudo rpm -Uvh /tmp/tito/noarch/rhc-*;rm -rf /tmp/tito/`

    reset_temp_commit

    puts "Done"
  end  
end

DevEnv.start
