#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))

require 'rubygems'
require 'thor'
require 'fileutils'
require 'lib/openshift'
require 'pp'
require 'yaml'

include FileUtils

class DevEnv < Thor
  include Thor::Actions
  include OpenShift::Tito
  include OpenShift::SSH
  include OpenShift::Amazon
  include OpenShift::SauceLabs

  @@SSH_TIMEOUT = 4800
  @@SSH_TIMEOUT_OVERRIDES = { "benchmark" => 172800 }
  @@CUCUMBER_OPTIONS = '--strict -f junit --out /tmp/rhc/cucumber_results -f progress'

  no_tasks do
    def sync_repo(repo_name, hostname, ssh_path)
      temp_commit

      begin

        # Get the current branch
        branch = get_branch

        puts "Synchronizing local changes from branch #{branch} for repo #{repo_name} from #{File.basename(FileUtils.pwd)}..."

        init_repo(hostname, false)

        exitcode = run(%{
#######
# Start shell code
export GIT_SSH=#{ssh_path}
#{branch == 'origin/master' ? "git push -q root@#{hostname}:/root/#{repo_name} master:master --tags --force; " : ''}
git push -q root@#{hostname}:/root/#{repo_name} #{branch}:master --tags --force

#######
# End shell code
}, :verbose => options.verbose?)

        puts "Done"
      ensure
        reset_temp_commit
      end
    end
    
    def sync_sibling_repo(repo_name, repo_dir, hostname, ssh_path)
      exists = File.exists?(repo_dir) 
      inside(repo_dir) do
        sync_repo(repo_name, hostname, ssh_path)
      end if exists
      exists
    end

    def init_repo(hostname, replace=true)
      git_clone_commands = "set -e\n "
      git_clone_commands += "if ! [ -d /root/li ]; then\n" unless replace
      git_clone_commands += "rm -rf /root/li; git clone --bare git@github.com:openshift/li.git /root/li\n"
      git_clone_commands += "fi\n" unless replace
      SIBLING_REPOS.each do |repo_name, repo_dirs|
        git_clone_commands += "if ! [ -d /root/#{repo_name} ]; then\n" unless replace
        git_clone_commands += "rm -rf /root/#{repo_name}; git clone --bare git@github.com:openshift/#{repo_name}.git /root/#{repo_name};\n"
        git_clone_commands += "fi\n" unless replace
      end
      ssh(hostname, git_clone_commands, 240, false, 10)
    end

    def temp_commit
      # Warn on uncommitted changes
      `git diff-index --quiet HEAD`

      if $? != 0
        # Perform a temporary commit
        puts "Creating temporary commit to build"
        `git commit -a -m "Temporary commit to build"`
        if $? != 0
          puts "No-op."
        else
          @temp_commit = true
          puts "Done."
        end
      end
    end

    def reset_temp_commit
      if @temp_commit
        puts "Undoing temporary commit..."
        `git reset HEAD^`
        @temp_commit = false
        puts "Done."
      end
    end

    def update_remote_tests(hostname, branch=nil)
      print "Updating remote tests..."
      all_repo_dirs = ['/root/li']
      SIBLING_REPOS.each do |repo_name, repo_dirs|
        all_repo_dirs << "/root/#{repo_name}"
      end
      git_archive_commands = ''
      all_repo_dirs.each do |repo_dir|
        git_archive_commands += "pushd #{repo_dir} > /dev/null; git archive --prefix li-test/ --format=tar #{branch ? branch : 'HEAD'} | (cd /root && tar --warning=no-timestamp -xf -); popd > /dev/null; "
      end
      ssh(hostname, %{
set -e;
rm -rf /root/li-test
#{git_archive_commands}
cp -n /root/li-test/stickshift/controller/test/cucumber/*.feature /root/li-test/tests/.  
mkdir -p /tmp/rhc/junit
}, 60, false, 2)
      puts "Done"
    end
    
    def idle_all_gears(hostname)
      puts "Idling all gears on remote instance: #{hostname}"
      ssh(hostname, "service mcollective restart; service stickshift-proxy restart; for dir in /var/lib/stickshift/*; do if [ -d $dir ] && [ ! -h $dir ] ; then rhc-idler -n -u `basename $dir`; fi; done; service httpd graceful", 240)
      puts "Done"
    end

    def disable_charlie(hostname)
      puts "Disabling automatic shutdown on remote instance: #{hostname}"
      ssh(hostname, "echo HOURS=9999 > /etc/charlie.conf", 240)
    end

    def mcollective_logs(hostname)
      puts "Keep all mcollective logs on remote instance: #{hostname}"
      ssh(hostname, "echo keeplogs=9999 >> /etc/mcollective/server.cfg", 240)
      ssh(hostname, "/sbin/service mcollective restart", 240)
    end

    def broker_profiler(hostname, enable=true)
      puts "Setting broker profile enable: #{enable}"
      f=Tempfile.open('fixbroker')
      begin
        if enable
          f.puts '/config.profiler = {/,/}/ { s/\#//g; }'
        else
          f.puts '/config.profiler = {/,/}/ { s/\#//g; s/^/#/; }'
        end
        f.close
        scp_to(hostname, f.path, "/tmp/fixbroker.sed", 600, 10)
        ssh(hostname, "sed -i -f /tmp/fixbroker.sed /var/www/stickshift/broker/config/environments/development.rb", 240)
        ssh(hostname, "/sbin/service libra-broker restart", 240)
      ensure
        f.close
        f.unlink
      end
    end

    def scp_remote_tests(hostname)
      if FileUtils.pwd == "/var/lib/jenkins/jobs/libra_ami_stage/workspace" || FileUtils.pwd == "/var/lib/jenkins/jobs/libra_ami_verify_stage/workspace"
        init_repo(hostname)
        update_remote_tests(hostname, "stage")
      else
        puts "Archiving local changes..."
        FileUtils.rm_rf '/tmp/li-test'
        all_repo_dirs = ['.']
        SIBLING_REPOS.each do |repo_name, repo_dirs|
          repo_dirs.each do |repo_dir|
            if File.exists?(repo_dir)
              all_repo_dirs << repo_dir
              break
            end
          end
        end
        all_repo_dirs.each do |repo_dir|
          inside(repo_dir) do
            `git archive --prefix li-test/ --format=tar HEAD | (cd /tmp && tar --warning=no-timestamp -xf -)`
          end
        end
        `cd /tmp/ && tar -cvf /tmp/li-test.tar li-test`
        puts "Done"
        puts "Copying tests to remote instance: #{hostname}"
        scp_to(hostname, "/tmp/li-test.tar", "~/", 600, 10)
        puts "Done"
        puts "Extracting tests on remote instance: #{hostname}"
        ssh(hostname, 'set -e; rm -rf li-test; tar -xf li-test.tar; cp -n /root/li-test/stickshift/controller/test/cucumber/*.feature /root/li-test/tests/. ; mkdir -p /tmp/rhc/junit', 120)
        puts "Done"
      end
      
    end

    def repo_path(dir='')
      File.expand_path("../#{dir}", File.dirname(__FILE__))
    end

    def download_artifacts(hostname)
      print "Downloading logs and screenshots..."
      `rm -rf rhc/log; mkdir -p rhc/log/; pushd rhc/log > /dev/null; mkdir -p site/test/reports broker mcollective system screenshots selenium jbossas broker-profiler coverage; popd > /dev/null`
      scp_from(hostname, "/tmp/rhc/*", "rhc/log")
      scp_from(hostname, "/var/www/stickshift/site/httpd/logs/access_log", "rhc/log/site/access_log.log")
      scp_from(hostname, "/var/www/stickshift/site/httpd/logs/error_log", "rhc/log/site/error_log.log")
      scp_from(hostname, "/var/www/stickshift/site/log/*", "rhc/log/site")
      scp_from(hostname, "/root/li-test/site/test/reports/*", "rhc/log/site/test/reports")
      scp_from(hostname, "/var/www/stickshift/broker/httpd/logs/access_log", "rhc/log/broker/access_log.log")
      scp_from(hostname, "/var/www/stickshift/broker/httpd/logs/error_log", "rhc/log/broker/error_log.log")
      scp_from(hostname, "/var/www/stickshift/broker/log/*", "rhc/log/broker")
      scp_from(hostname, "/var/log/stickshift/user_action.log", "rhc/log/broker/user_action.log")
      scp_from(hostname, "/var/log/mcollective.*", "rhc/log/mcollective")
      scp_from(hostname, "/var/log/httpd/access_log", "rhc/log/system/access_log.log")
      scp_from(hostname, "/var/log/httpd/error_log", "rhc/log/system/error_log.log")
      scp_from(hostname, "/var/log/yum.log", "rhc/log/system/yum.log")
      scp_from(hostname, "/var/log/messages", "rhc/log/system/messages.log")
      scp_from(hostname, "/var/log/dmesg", "rhc/log/system/dmesg.log")
      scp_from(hostname, "/var/log/secure", "rhc/log/system/secure.log")
      scp_from(hostname, "/var/log/audit/audit.log", "rhc/log/system/audit.log")
      scp_from(hostname, "/tmp/rhc/screenshots/*", "rhc/log/screenshots")
      scp_from(hostname, "/root/li-test/selenium/output/*", "rhc/log/selenium")
      scp_from(hostname, "/var/lib/stickshift/*/*/jbossas-7/standalone/tmp/*.log", "rhc/log/jbossas")
      scp_from(hostname, "/var/lib/stickshift/*/*/jbosseap-6.0/standalone/tmp/*.log", "rhc/log/jbosseap")
      scp_from(hostname, "/tmp/rhc/benchmark.csv", "rhc/log")
      scp_from(hostname, "/tmp/broker-profiler/*", "rhc/log/broker-profiler")
      scp_from(hostname, "/tmp/rhc/*_coverage", "rhc/log/coverage")
      puts "Done"
    end

    def run_ssh(hostname, title, cmd, timeout=@@SSH_TIMEOUT)
      output, code = ssh(hostname, cmd, timeout, true)
      puts <<-eos


          -----------------------------------------------------------
                      Begin Output From #{title} Tests
          -----------------------------------------------------------

#{output}

          -----------------------------------------------------------
                       End Output From #{title} Tests
          -----------------------------------------------------------
      

      eos
      return output, code
    end

    def rpm_manifest(hostname)
      print "Retrieving RPM manifest..."
      manifest = ssh(hostname, 'rpm -qa | grep rhc-')
      manifest = manifest.split("\n").sort.join(" / ")
      # Trim down the output to 255 characters
      manifest.gsub!(/rhc-([a-z])/, '\1')
      manifest.gsub!('.el6.noarch', '')
      manifest.gsub!('.el6_1.noarch', '')
      manifest.gsub!('cartridge', 'c-')
      manifest = manifest[0..254]
      puts "Done"
      return manifest
    end

    def validate_instance(hostname)
      # Validate the node installation
      print "Validating instance..."
      num_tries = 5
      restart_try = 2
      (1..num_tries).each do |i|
        unless is_valid?(hostname)
          if i == num_tries
            puts "ERROR - instance is not valid"
            exit 1
          elsif i == restart_try
            ssh(hostname, "service libra-broker restart; service libra-site restart", 60)
          end
          sleep 5
        else
          break
        end
      end
      puts "Done"
    end

    def reboot(instance)
      print "Rebooting instance to apply new kernel..."
      instance.reboot
      puts "Done"
    end

    def add_ssh_cmd_to_threads(hostname, threads, failures, titles, cmds, retry_individually=false, timeouts=@@SSH_TIMEOUT)
      titles = [titles] unless titles.kind_of?(Array)
      cmds = [cmds] unless cmds.kind_of?(Array)
      retry_individually = [retry_individually] unless retry_individually.kind_of? Array
      timeouts = [timeouts] unless timeouts.kind_of? Array
      start_time = Time.new
      threads << [ Thread.new {
        multi = cmds.length > 1
        cmds.each_with_index do |cmd, index|
          title = titles[index]
          retry_individ = retry_individually[index]
          timeout = timeouts[index]
          output, exit_code = run_ssh(hostname, title, cmd, timeout)
          if exit_code != 0
            if output.include?("Failing Scenarios:") && output =~ /cucumber li-test\/tests\/.*\.feature:\d+/
              output.lines.each do |line|
                if line =~ /cucumber li-test\/tests\/(.*\.feature):(\d+)/
                  test = $1
                  scenario = $2
                  if retry_individ
                    failures.push(["#{title} (#{test}:#{scenario})", "cucumber #{@@CUCUMBER_OPTIONS} li-test/tests/#{test}:#{scenario}"])
                  else
                    failures.push(["#{title} (#{test})", "cucumber #{@@CUCUMBER_OPTIONS} li-test/tests/#{test}"])
                  end
                end
              end
            elsif retry_individ && output.include?("Failure:") && output.include?("rake_test_loader")
              output.lines.each do |line|
                if line =~ /\A(test_\w+)\((\w+Test)\) \[\/*(.*?_test\.rb):(\d+)\]:/
                  test_name = $1
                  class_name = $2
                  file_name = $3
                  
                  # determine if the first part of the command is a directory change 
                  # if so, include that in the retry command
                  chdir_command = ""
                  if cmd =~ /\A(cd .+?; )/
                    chdir_command = $1
                  end
                  failures.push(["#{class_name} (#{test_name})", "#{chdir_command} ruby -Ilib:test #{file_name} -n #{test_name}"])
                end
              end
            else
              failures.push([title, cmd])
            end
          end

          still_running_tests = ''
          threads.each do |t|
            t[1].delete(title)
            still_running_tests += "   #{t[1].pretty_inspect}" unless t[1].empty?
          end
          if still_running_tests.length > 0
            mins, secs = (Time.new - start_time).abs.divmod(60)
            puts "Still Running Tests (#{mins}m #{secs.to_i}s):"
            puts still_running_tests
          end
        end
      }, Array.new(titles) ]
    end

    def reset_test_dir(hostname, backup=false)
      ssh(hostname, %{
if [ -d /tmp/rhc ]
then
    if #{backup}
    then
        if `ls /tmp/rhc/run_* > /dev/null 2>&1`
        then
            rm -rf /tmp/rhc_previous_runs
            mkdir -p /tmp/rhc_previous_runs
            mv /tmp/rhc/run_* /tmp/rhc_previous_runs
        fi
        if `ls /tmp/rhc/* > /dev/null 2>&1`
        then
            for i in {1..100}
            do
                if ! [ -d /tmp/rhc_previous_runs/run_$i ]
                then
                    mkdir -p /tmp/rhc_previous_runs/run_$i
                    mv /tmp/rhc/* /tmp/rhc_previous_runs/run_$i
                    break
                fi
            done
        fi
        if `ls /tmp/rhc_previous_runs/run_* > /dev/null 2>&1`
        then
            mv /tmp/rhc_previous_runs/run_* /tmp/rhc/
            rm -rf /tmp/rhc_previous_runs
        fi
    else
        rm -rf /tmp/rhc
    fi
fi
mkdir -p /tmp/rhc/junit
}, 120, true)
    end

    def test_instance(tag, hostname, instance, conn, options, image_id=nil)
      begin
        
        validate_instance(hostname)

        disable_charlie(hostname) if options.disable_charlie?
        
        mcollective_logs(hostname) if options.mcollective_logs?

        idle_all_gears(hostname) unless options.official?
        
        reset_test_dir(hostname)

        broker_profiler(hostname) if options.profile_broker?

        test_queues = [[], [], [], []]

        if options.include_extended
          
          case options.include_extended
          when 'broker'
            test_queues[0] << ["REST API", "cucumber #{@@CUCUMBER_OPTIONS} -t @broker_api li-test/tests", {:retry_individually => true}]
            test_queues[1] << ["Broker Domain System", "cd li-test/broker; rake domain_system_test", {:retry_individually => true}]
            test_queues[2] << ["Broker Application System", "cd li-test/broker; rake application_system_test", {:retry_individually => true}]
            test_queues[3] << ["Broker Cartridge System", "cd li-test/broker; rake cartridge_system_test", {:retry_individually => true}]
            test_queues[1] << ["StickShift Broker Unit Ext 1", "cd li-test/stickshift/broker; rake test:ss_unit_ext1", {:retry_individually => true}]
          when 'runtime'
            test_queues[0] << ["Extended Runtime Group 1", "cucumber #{@@CUCUMBER_OPTIONS} -t @runtime_extended1 li-test/tests"]
            test_queues[1] << ["Extended Runtime Group 2", "cucumber #{@@CUCUMBER_OPTIONS} -t @runtime_extended2 li-test/tests"]
            test_queues[2] << ["Extended Runtime Group 3", "cucumber #{@@CUCUMBER_OPTIONS} -t @runtime_extended3 li-test/tests"]
          when 'site'
            test_queues[0] << ["Site Extended", "cd li-test/site; rake test:extended"]
          when 'rhc'
            test_queues[0] << ["RHC Extended", "cucumber #{@@CUCUMBER_OPTIONS} -t @rhc_extended li-test/tests", {:retry_individually => true}]
          else
            puts "Not supported for extended: #{options.include_extended}"
            exit 1
          end
        elsif options.include_rcov?
          test_queues[0] << ["StickShift Node Unit Coverage", "cd li-test/stickshift/node; rake rcov; cp -a coverage /tmp/rhc/stickshift_node_coverage"]
          test_queues[1] << ["Broker Unit and Functional Coverage", "cd li-test/broker; rake rcov; cp -a test/coverage /tmp/rhc/broker_coverage"]
          test_queues[2] << ["StickShift Broker Unit and Functional Coverage", "cd li-test/stickshift/broker; rake rcov; cp -a test/coverage /tmp/rhc/stickshift_broker_coverage"]
        elsif options.include_cucumber
          timeout = @@SSH_TIMEOUT
          timeout = @@SSH_TIMEOUT_OVERRIDES[options.include_cucumber] if not @@SSH_TIMEOUT_OVERRIDES[options.include_cucumber].nil?
          test_queues[0] << [options.include_cucumber, "cucumber #{@@CUCUMBER_OPTIONS} -t @#{options.include_cucumber} li-test/tests", {:timeout => timeout}]
        elsif options.include_web?

          # check sauce quotas first
          usage = sauce_usage

          if usage[:percentage] > 95 && !options[:sauce_overage]
            puts "Refusing to run Sauce Labs tests due to quota overage considerations.  Run with --sauce_overage to override."
            return
          end

          # TODO: respect sauce username and access key settings
          cmd = "service sauce-connect start"
          run_ssh(hostname, "Start sauce connect tunnel", cmd, timeout)

          if options.sauce_os && options.sauce_browser && options.sauce_browser_version
            browsers = [[options.sauce_os, options.sauce_browser, options.sauce_browser_version]]
          else
            browsers = [['Windows 2003', 'firefox', ''],
              ['Windows 2008', 'chrome', ''],
              ['Windows 2008', 'iexplore', '9'],
              ['Windows 2003', 'safari', '']]
            # not working very well
            browsers.delete_at(2)
            browsers.delete_at(2)
          end

          browsers.each do |browser|
            sauce_os = browser[0]
            sauce_browser = browser[1]
            sauce_browser_version = browser[2]
            sauce_opts = {
              "SAUCE_USERNAME" => (options.sauce_username || 'openshift_ci'),
              "SAUCE_ACCESS_KEY" => (options.sauce_access_key || '3d67e770-ce7d-482a-8c7f-07aec039d564'),
              "SAUCE_OS" => sauce_os,
              "SAUCE_BROWSER" => sauce_browser,
              "SAUCE_BROWSER_VERSION" => sauce_browser_version,
              "SAUCE_SELENIUM_VERSION" => '2.7.0',
              "SAUCE_BROWSER_URL" => "https://#{hostname}/app",
              "JENKINS_BUILD" => 'unofficial'
            }
            # If we passed a jenkins build like name, use that for the build number
            if tag.start_with?('libra_') || tag.start_with?('devenv_') || tag.start_with?('devenv-')
              sauce_opts['JENKINS_BUILD'] = tag
            else
              sauce_opts['SAUCE_USERNAME'] = options.sauce_username
              sauce_opts['SAUCE_ACCESS_KEY'] = options.sauce_access_key
            end

            env_string = sauce_opts.keys.map{|k| %Q(#{k}="#{sauce_opts[k]}")}.join(' ')

            puts "Running Sauce tests with the following options:"
            puts sauce_opts.to_yaml

            pos = 0
            Dir.foreach('selenium/testcases') do |filename|
              if filename =~ /^tc_(.*)\.rb$/
                test = $1
                test_queues[pos] << ["Web Selenium (#{sauce_os} - #{sauce_browser} #{sauce_browser_version}) (#{test})", "cd li-test/selenium; #{env_string} ruby ts_web #{test}"]
                if pos == test_queues.length - 1
                  pos = 0
                else 
                  pos += 1
                end
              end
            end
          end
        else

          unless options.exclude_broker?
            test_queues[0] << ["Broker Unit", "cd li-test/broker; rake test:units"]
            test_queues[1] << ["Broker Functional", "cd li-test/broker; rake test:functionals"]
            test_queues[0] << ["Broker Integration", "cd li-test/broker; rake test:integration"]
            test_queues[1] << ["StickShift Broker Functional", "cd li-test/stickshift/broker; rake test:functionals"]
            test_queues[0] << ["StickShift Broker Integration", "cd li-test/stickshift/broker; rake test:integration"]

            test_queues[2] << ["StickShift Broker Unit 1", "cd li-test/stickshift/broker; rake test:ss_unit1"]
            test_queues[2] << ["StickShift Broker Unit 2", "cd li-test/stickshift/broker; rake test:ss_unit2"]
            test_queues[3] << ["Broker Cucumber", "cucumber --strict -f html --out /tmp/rhc/broker_cucumber.html -f progress -t @broker li-test/tests"]
          end

          unless options.exclude_runtime?
            test_queues[0] << ["Runtime Unit", "cd li-test/stickshift/node; rake unit_test"]
            (1..4).each do |i|
              test_queues[i-1] << ["Runtime Group #{i.to_s}", "cucumber #{@@CUCUMBER_OPTIONS} -t @runtime#{i.to_s} li-test/tests"]
            end
          end

          unless options.exclude_site?
            test_queues[0] << ["Site Check Applications", "cd li-test/site; rake test:check:applications"]
            test_queues[1].unshift ["Site Check Base", "cd li-test/site; rake test:check:base"]
            test_queues[1] << ["Site Check Cartridges", "cd li-test/site; rake test:check:cartridges"]
            test_queues[2] << ["Site Check Miscellaneous 1", "cd li-test/site; rake test:check:misc1"]
            test_queues[3] << ["Site Check REST API Integration", "cd li-test/site; rake test:check:restapi_integration"]
          end

          unless options.exclude_rhc?

          end

        end

        threads = []
        failures = []

        retry_threshold = 0
        test_queues.each do |test_queue|
          titles = []
          cmds = []
          retry_individually = []
          timeouts = []
          test_queue.each do |test|
            titles << test[0]
            cmds << test[1]
            opts = test[2] || {}
            retry_individually << opts[:retry_individually] ? true : false
            timeouts << opts[:timeout] ? opts[:timeout] : @@SSH_TIMEOUT
            retry_threshold += 8
          end
          add_ssh_cmd_to_threads(hostname, threads, failures, titles, cmds, retry_individually, timeouts)
        end

        threads.each do |t|
          t[0].join
        end

        failures.uniq!

        begin
          if failures.length > 0 && failures.length <= retry_threshold 
            idle_all_gears(hostname)
            retry_test_failures(hostname, failures, 2)
          elsif failures.length > retry_threshold
            exit 1
          end

          # These are special tests that cannot be written to work concurrently
          if options.include_extended
            idle_all_gears(hostname)

            singleton_queue = ['Singletons', "cucumber #{@@CUCUMBER_OPTIONS} -t @singleton li-test/tests"]
            output, exit_code = run_ssh(hostname, singleton_queue[0], singleton_queue[1])
            retry_test_failures(hostname, [singleton_queue], 2) if 0 != exit_code
          end

          validate_instance(hostname)
        ensure
          if options.include_web?
            cmd = "service sauce-connect stop"
            run_ssh(hostname, "Stop sauce connect tunnel", cmd, timeout)
          end
        end

        if options.official?
          image_id = image_id ? image_id : instance.image_id
          # Mark the image as verified
          image = conn.images[image_id]
          verify_image(image)

          print "Sending QE ready email..."
          begin
            send_verified_email(image_id, image.name)
          rescue Exception => e
            print "Failed sending email with message: #{e.message}"
          end
        elsif !options.terminate?
          idle_all_gears(hostname)
        end

        broker_profiler(hostname, enable=false) if options.profile_broker?

        puts "Done"

      ensure
        if options.terminate?
          download_artifacts(hostname)
          terminate_instance(instance)
        end
      end
    end
    
    def retry_test_failures(hostname, failures, num_retries=1, timeout=@@SSH_TIMEOUT)
      failures.reverse!
      puts "All Failures: #{failures.pretty_inspect}"
      reset_test_dir(hostname, true)
      failures.each do |failure|
        title = failure[0]
        cmd = failure[1]
        (1..num_retries).each do |i|
          puts "Retry attempt #{i} for: #{title}"
          output, exit_code = run_ssh(hostname, title, cmd, timeout)
          if exit_code != 0
            if i == num_retries
              exit exit_code
            else
              reset_test_dir(hostname, true)
            end
          else
            break
          end
        end
      end
    end

    def build_and_install(package_name, build_dir, spec_file)
      if package_name.include? "origin" || package_name == "stickshift-broker"
          puts "Skipping #{package_name}"
          return
      end
      remove_dir '/tmp/tito/'
      FileUtils.mkdir_p '/tmp/tito/'
      puts "Building in #{build_dir}"
      inside(File.expand_path("../#{build_dir}", File.dirname(__FILE__))) do
        # Build and install the RPM's locally
        unless run("tito build --rpm --test", :verbose => options.verbose?)
          # Tag to trick tito to build
          commit_id = `git log --pretty=format:%%H --max-count=1 %s" % .`
          spec_file_name = File.basename(spec_file)
          version = get_version(spec_file_name)
          next_version = next_tito_version(version, commit_id)
          puts "current spec file version #{version} next version #{next_version}"
          unless run("tito tag --accept-auto-changelog --use-version='#{next_version}'; tito build --rpm --test", :verbose => options.verbose?)
            FileUtils.rm_rf '/tmp/devenv/sync/'
            exit 1
          end
        end
        Dir.glob('/tmp/tito/x86_64/*.rpm').each {|file|
          FileUtils.mkdir_p "/tmp/tito/noarch/"
          FileUtils.mv file, "/tmp/tito/noarch/"
        }
        unless run("rpm -Uvh --force /tmp/tito/noarch/*.rpm", :verbose => options.verbose?)
          unless run("rpm -e --justdb --nodeps #{package_name}; yum --enablerepo=ruby193 install -y /tmp/tito/noarch/*.rpm", :verbose => options.verbose?)
            FileUtils.rm_rf '/tmp/devenv/sync/'
            exit 1
          end
        end
      end
    end
  end

  desc "write_sync_history", "Write out the sync history so updates won't happen for already installed changes"

  def write_sync_history()
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
    get_sync_dirs
  end

  desc "watch", "Watch for changes to your source directory and copy them to the remote image.  Will look for ~/.openshiftdev/watch.lua for an override configuration.  Not a full replacement for 'sync' - intended to speed Rails development. Requires the lsyncd package installed."
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def watch
    raise Thor::Error, "You must install lsyncd ('sudo yum install lsyncd') in order to run the 'watch' command" if not run "which lsyncd > /dev/null", :verbose => false
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    config = File.join ENV['HOME'], '.openshiftdev/watch.lua'
    if File.exists? config
      say "Using your custom sync config '#{config}'"
    else
      say "Creating the default sync config"
      template = IO.read(repo_path('build/watch_default.lua')).gsub('{LOCAL_DIR}', "#{repo_path}")
      if options.verbose?
        puts "Lsyncd template"
        puts "----------"
        puts template
        puts "----------"
      end
      Tempfile.open('lsynctemplate') { |f| f.puts template; config = f.path }
    end

    # Rsync cannot set owner or group, so we should inherit
    ssh("verifier", "find /var/www/stickshift -type d | xargs chmod g+s", 1800)
    ssh("verifier", "find /usr/lib/ruby/site_ruby -type d | xargs chmod g+s", 1800)

    say "Watching your development directories, hit CTRL+C to stop"
    run "lsyncd #{options.verbose? ? '-log all' : ''} #{config}"
  end
  
  desc "print_packages", "Print a space separated list of packages"
  def print_packages
    packages = get_packages(true)
    packages_str = ""
    packages.keys.sort.each do |package_name|
      packages_str += " #{package_name}"
    end
    puts packages_str
  end
  
  desc "print_ignore_packages", "Print a space separated list of packages to ignore"
  def print_ignore_packages
    packages_str = ""
    IGNORE_PACKAGES.each do |package_name|
      packages_str += " #{package_name}"
    end
    puts packages_str
  end

  desc "build NAME BUILD_NUM", "Build a new devenv AMI with the given NAME"
  method_option :register, :type => :boolean, :desc => "Register the instance"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance on exit"
  method_option :use_stage_repo, :type => :boolean, :desc => "Build instance off the stage repository"
  method_option :reboot, :type => :boolean, :desc => "Reboot the instance after updating"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :official, :type => :boolean, :desc => "For official use.  Send emails, etc."
  method_option :exclude_broker, :type => :boolean, :desc => "Exclude broker tests"
  method_option :exclude_runtime, :type => :boolean, :desc => "Exclude runtime tests"
  method_option :exclude_site, :type => :boolean, :desc => "Exclude site tests"
  method_option :exclude_rhc, :type => :boolean, :desc => "Exclude rhc tests"
  method_option :include_web, :type => :boolean, :desc => "Include running Selenium tests"
  method_option :include_rcov, :type => :boolean, :desc => "Include coverage analysis on unit tests"
  method_option :include_extended, :required => false, :desc => "Include extended tests"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  method_option :build_clean_ami, :type => :boolean, :desc => "Indicates whether to start from a base RHEL image"
  method_option :install_from_source, :type => :boolean, :desc => "Indicates whether to build based off origin/master"
  method_option :install_from_local_source, :type => :boolean, :desc => "Indicates whether to build based on your local source"
  method_option :install_required_packages, :type => :boolean, :desc => "Create an instance with all the packages required by OpenShift"
  method_option :skip_verify, :type => :boolean, :desc => "Skip running tests to verify the build"
  method_option :instance_type, :required => false, :desc => "Amazon machine type override (default c1.medium)"

  def build(name, build_num)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
    
    # Override the machine type to launch if necessary
    if options[:instance_type]
      $amz_options[:instance_type] = options[:instance_type]
    end

    # Establish a new connection
    conn = connect(options.region)

    image = nil
    if options.install_required_packages?
      # Create a new builder instance
      if (options.region?nil)
        image = conn.images[AMI["us-east-1"]]
      elsif AMI[options.region].nil?
        puts "No AMI specified for region:" + options.region
        exit 1
      else
        image = conn.images[AMI[options.region]]
      end
    elsif options.build_clean_ami? || options.install_from_source? || options.install_from_local_source?
      # Get the latest devenv base image and create a new instance
      if options.use_stage_repo?
        filter = DEVENV_STAGE_BASE_WILDCARD
      else
        filter = DEVENV_BASE_WILDCARD
      end
      image = get_latest_ami(conn, filter)
    else
      # Get the latest devenv clean image and create a new instance
      if options.use_stage_repo?
        filter = DEVENV_STAGE_CLEAN_WILDCARD
      else
        filter = DEVENV_CLEAN_WILDCARD
      end
      image = get_latest_ami(conn, filter)
    end

    instance = launch_instance(image, name + '_' + build_num)
    hostname = instance.dns_name
    
    puts "Building on: #{hostname}"

    begin
      manifest = nil
      begin
        if options.build_clean_ami? || options.install_from_source? || options.install_from_local_source? || options.install_required_packages?
          print "Updating all packages on the system..."
          2.times do
            ssh(hostname, "yum update -y --exclude='rhc*'; yum -y install openssh-clients", 1800)
          end
          puts "Done"

          if options.reboot?
            reboot(instance)
          end

          print "Uploading devenv script..."
          script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/devenv/li-devenv.sh")
          scp_to(hostname, script_path, "~/")
          puts "Done"
          print "Uploading yum client certificates..."
          script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/client-cert.pem")
          scp_to(hostname, script_path, "/var/lib/yum/")
          script_path = File.expand_path(File.dirname(__FILE__) + "/../misc/client-key.pem")
          scp_to(hostname, script_path, "/var/lib/yum/")
          scp_to(hostname, "misc/devenv/root/.ssh/*", "/root/.ssh/")
          ssh(hostname, "chmod 0600 /root/.ssh/id_rsa; chmod 0644 /root/.ssh/id_rsa.pub /root/.ssh/known_hosts;")
          puts "Done"
          output = ''
          if options.install_from_source?
            print "Performing clean install from source..."
            cmd = "set -e; /bin/bash li-devenv.sh #{options.use_stage_repo? ? "stage" : "candidate"} --install_from_source"
          elsif options.install_from_local_source?
            init_repo(hostname)
            ssh_path = File.expand_path(File.dirname(__FILE__)) + "/ssh-override"
            sync_repo('li', hostname, ssh_path)
            SIBLING_REPOS.each do |repo_name, repo_dirs|
              repo_dirs.each do |repo_dir|
                break if sync_sibling_repo(repo_name, repo_dir, hostname, ssh_path)
              end
            end
            print "Performing clean install from local source..."
            cmd = "set -e; /bin/bash li-devenv.sh #{options.use_stage_repo? ? "stage" : "candidate"} --install_from_local_source"
          elsif options.install_required_packages?
            print "Installing requires..."
            cmd = "set -e; /bin/bash li-devenv.sh #{options.use_stage_repo? ? "stage" : "candidate"} --install_build_prereqs"
            output += ssh(hostname, cmd, 600)
            cmd = "set -e; /bin/bash li-devenv.sh #{options.use_stage_repo? ? "stage" : "candidate"} --install_required_packages"
          else
            print "Performing clean install with the latest code..."
            cmd = 'set -e ; /bin/bash ~/li-devenv.sh'
            cmd += ' stage' if options.use_stage_repo?
          end
          output, exit_code = ssh(hostname, cmd, 3600, true)
          puts "Done"

          puts "----------------- Install Output ------------------------"
          puts output
          puts "---------------------------------------------------------"
          
          exit exit_code unless exit_code == 0
        
          validate_instance(hostname) unless options.install_required_packages?

          manifest = rpm_manifest(hostname)

          if options.register? && options.build_clean_ami?
            register_image(conn, instance, name + '-clean_' + build_num, manifest)
          end
        else
          print "Updating all packages on the system..."
          output, exit_code = ssh(hostname, "yum clean metadata; yum update -y --exclude='rhc-devenv'; set -e; yum update -y --exclude='rhc-devenv' --disablerepo=\\* --enablerepo=li --enablerepo=ruby193", 600, true)
          puts "Done"

          puts "------------------ Update Output ------------------------"
          puts output
          puts "---------------------------------------------------------"
          
          exit exit_code unless exit_code == 0

          validate_instance(hostname)

          manifest = rpm_manifest(hostname)
        end
      rescue SystemExit => e
        download_artifacts(hostname) if options.terminate?
        raise
      end
      
      output = ssh(hostname, "yum list installed", 120)

      puts "---------------- Installed Packages ---------------------"
      puts output
      puts "---------------------------------------------------------"

      image_id = nil
      if options.register?
        image = register_image(conn, instance, name + '_' + build_num, manifest)
        image_id = image.id
      end

      unless options.skip_verify? || options.install_required_packages?
        scp_remote_tests(hostname)
        test_instance(name + '_' + build_num, hostname, instance, conn, options, image_id)
      end
    ensure
      terminate_instance(instance) if options.terminate?
    end
  end

  desc "update", "Update current instance by installing RPMs from local git tree"
  method_option :include_stale, :type => :boolean, :desc => "Include packages that have been tagged but not synced to the repo"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def update
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Warn on uncommitted changes
    `git diff-index --quiet HEAD`
    puts "WARNING - Uncommitted repository changes" if $? != 0

    # Figure out what needs to be built - exclude devenv for syncs
    sync_dirs = get_sync_dirs

    sync_dirs.each do |sync_dir|
      package_name = sync_dir[0]
      build_dir = sync_dir[1]
      spec_file = sync_dir[2]
      build_and_install(package_name, build_dir, spec_file)
    end
    
    if options.include_stale?
      stale_dirs = get_stale_dirs
      stale_dirs.each do |stale_dir|
        package_name = stale_dir[0]
        build_dir = stale_dir[1]
        spec_file = stale_dir[2]
        build_and_install(package_name, build_dir, spec_file)
      end
    end
    run("yum update -y --exclude='rhc-devenv' --disablerepo=\\* --enablerepo=li --enablerepo=ruby193 rhc-* cartridge-* rubygem-stickshift-* rubygem-gearchanger-* rubygem-uplift-* rubygem-swingshift-*", :verbose => options.verbose?)
    run("service mcollective restart; service libra-broker restart; service libra-site restart", :verbose => options.verbose?)
  end

  desc "sync NAME", "Synchronize a local git repo with a remote DevEnv instance.  NAME should be ssh resolvable."
  method_option :tag, :type => :boolean, :desc => "NAME is an Amazon tag"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :skip_build, :type => :boolean, :desc => "Indicator to skip the rpm build/install"
  method_option :clean_metadata, :type => :boolean, :desc => "Cleans metadata before running yum commands"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  def sync(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Get the hostname from a tag lookup or assume it's SSH accessible directly
    conn = connect(options.region)
    hostname = options.tag? ? find_instance(conn, name, true).dns_name : name

    ssh_path=File.expand_path(File.dirname(__FILE__)) + "/ssh-override"

    sync_repo('li', hostname, ssh_path)

    avail_sibling_repo_names = []

    SIBLING_REPOS.each do |repo_name, repo_dirs|
      repo_dirs.each do |repo_dir|
        if sync_sibling_repo(repo_name, repo_dir, hostname, ssh_path)
          avail_sibling_repo_names.push(repo_name)
          break
        end
      end
    end
    update_remote_tests(hostname)

    clone_commands = ''
    working_dirs = ''
    avail_sibling_repo_names.each do |repo_name|
      working_dirs += "#{repo_name}-working "
      clone_commands += "git clone #{repo_name} #{repo_name}-working; "
    end
    
    if !options.skip_build?
      puts "Performing remote install...."
      output, exit_code = ssh(hostname, %{
##################
# Start shell code

set -e
#{options.clean_metadata? ? 'yum clean metadata' : ''}
rm -rf li-working #{working_dirs}

#{clone_commands}

# li repo
git clone li li-working

pushd li-working > /dev/null
  build/devenv update#{options.verbose? ? ' --verbose' : ''} #{options.clean_metadata? ? ' --include_stale' : ''} 2>&1
popd > /dev/null

rm -rf li-working #{working_dirs}
#{options.clean_metadata? ? "yum update -y --enablerepo=ruby193 --exclude='rhc-devenv' rhc-* cartridge-* rubygem-stickshift-* rubygem-gearchanger-* rubygem-uplift-* rubygem-swingshift-*; " : ''}

#{options.clean_metadata? ? '/bin/bash li-test/misc/devenv/li-devenv.sh --install_templates' : ''} 

# End shell code
################
}, 900, true)

      if exit_code != 0
        puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        puts "Build failed!  Exiting."
        puts output
        puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        exit 1
      end
      puts "Done"
    end
  end

  desc "terminate TAG", "Terminates the instance with the specified tag"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"

  def terminate(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
    conn = connect(options.region)
    instance = find_instance(conn, tag, true, false)
    terminate_instance(instance, true) if instance
  end

  desc "build_origin NAME", "Launches the latest origin instance, tagging with NAME"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :launch_new, :type => :boolean, :required => false, :desc => "Launch a new instance?"
  method_option :express_server, :type => :boolean, :desc => "Set as express server in express.conf and leave on public_ip"
  method_option :ssh_config_verifier, :type => :boolean, :desc => "Set as verifier in .ssh/config"
  method_option :instance_type, :required => false, :desc => "Amazon machine type override (default m1.medium)"
  method_option :with_extras, :type => :string, :required => false, :desc => "Extra (brew) rpms to install"
  method_option :build_cd, :type => :boolean, :required => false, :desc => "Build a livecd"
  def build_origin(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Override the machine type to launch if necessary
    if options[:instance_type]
      $amz_options[:instance_type] = options[:instance_type]
    else
      $amz_options[:instance_type] = "m1.medium"
    end

    # Get the latest devenv image and create a new instance
    conn = connect("us-east-1")
    image_name = "ami-0316d86a"
    ami = get_specific_public_ami(conn,image_name)
    if ami.nil?
      puts "No image name '#{image_name}' found!"
      exit(1)
    else
      puts "Launching latest Fedora instance #{ami.id} - #{ami.name}"
    end

    if options[:with_extras]
      unless File.exist? options[:with_extras]
        puts "Dir containing extra rpms not found. Exiting."
	exit
      end
    end

    
    $amz_options[:block_device_mappings] = {"/dev/sdb" => "ephemeral0"}
    if options[:launch_new]
      instance = launch_instance(ami, name, 1, "ec2-user")
    else
      instance = find_instance(conn, name, true, true, "ec2-user")
    end
    hostname = instance.dns_name
    puts "Done"
    puts "Hostname: #{hostname}"

    ret = 0
    out,ret = ssh(hostname, "su -c \"yum -y update\"", 60 * 10, true, 1, "ec2-user")
    out,ret = ssh(hostname, "su -c \"yum install -y git vim rubygem-rake\"", 60 * 10, true, 1, "ec2-user") if ret == 0
    out,ret = ssh(hostname, "su -c \"yum install -y git vim rubygem-rake\"", 60 * 10, true, 1, "ec2-user") if ret == 0
    out,ret = ssh(hostname, "su -c \"umount -l /data ; /sbin/mke2fs /dev/xvdb && mkdir -p /data && mount /dev/xvdb /data && chown -R ec2-user:ec2-user /data/\"", 60 * 10, true, 1, "ec2-user") if ret == 0
    out,ret = ssh(hostname, "cd /data && git clone https://github.com/openshift/crankcase.git /data/crankcase" , 60 * 10, true, 1, "ec2-user") if ret == 0
    out,ret = ssh(hostname, "cd /data/crankcase && git checkout features/mcollective" , 60 * 10, true, 1, "ec2-user") if ret == 0

    if ret != 0
      puts "Exiting aith error code #{ret}"
      exit ret
    end
    
    if options[:with_extras]
      if File.exist? options[:with_extras]
        out,ret = ssh(hostname, "mkdir -p /data/crankcase/build/extras" , 60, true, 1, "ec2-user")
        files = Dir.glob("#{options[:with_extras]}/*.rpm")
        files.each do |file|
          scp_to(hostname, file, "/data/crankcase/build/extras/", 60*10, 5, "ec2-user")
        end
      else
        puts "Dir containing extra rpms not found. Exiting."
	exit
      end
    end

    out,ret = ssh(hostname, "su -c \"cd /data/crankcase/build/extras && yum install -y *.rpm\"", 60 * 20, true, 1 , "ec2-user")
    out,ret = ssh(hostname, "cd /data/crankcase/build && rake build_setup", 60 * 20, true, 1 , "ec2-user") if ret == 0
    out,ret = ssh(hostname, "cd /data/crankcase/build && rake devbroker", 60 * 20, true, 1 , "ec2-user") if ret == 0
    out,ret = ssh(hostname, "cd /data && chown -R ec2-user:ec2-user *", 60 * 2,true,1 , "ec2-user") if ret == 0

    if ret != 0
      puts "Exiting with error code #{ret}"
      exit ret
    end

    if options.ssh_config_verifier?
      public_ip = instance.public_ip_address
      ssh_config = "~/.ssh/config"
      pem_file = File.expand_path("~/.ssh/libra.pem")
      if not File.exist?(pem_file)
        # copy it from local repo
        cmd = "cp misc/libra.pem #{pem_file}"
        puts cmd
        system(cmd)
        system("chmod 600 #{pem_file}")
      end
      config_file = File.expand_path(ssh_config)

      config_template = <<END
Host verifier
  HostName 10.1.1.1
  User      root
  IdentityFile ~/.ssh/libra.pem
END

      if not FileTest.exists?(config_file)
        puts "File '#{ssh_config}' does not exists, creating..."
        system("touch #{ssh_config}")
        cmd = "chmod 600 #{ssh_config}"
        system(cmd)
        file_mode = 'w'
        File.open(config_file, file_mode) { |f| f.write(config_template) }
      else
        if not system("grep -n 'Host verifier' #{config_file}")
          file_mode = 'a'
          File.open(config_file, file_mode) { |f| f.write(config_template) }
        end

      end

      line_num = `grep -n 'Host verifier' ~/.ssh/config`.chomp.split(':')[0]
      puts "Updating ~/.ssh/config verifier entry with public ip = #{public_ip}"
      (1..4).each do |i|
        `sed -i -e '#{line_num.to_i + i}s,HostName.*,HostName #{public_ip},' ~/.ssh/config`
      end
    end

    if options.express_server?
      public_ip = instance.public_ip_address
      puts "Updating ~/.openshift/express.conf libra_server entry with public ip = #{public_ip}"
      `sed -i -e 's,^libra_server.*,libra_server=#{public_ip},' ~/.openshift/express.conf`
    end

    home_dir=File.join(ENV['HOME'], '.openshiftdev/home.d')
    if File.exists?(home_dir)
      Dir.glob(File.join(home_dir, '???*'), File::FNM_DOTMATCH).each {|file|
        puts "Installing ~/#{File.basename(file)}"
        scp_to(hostname, file, "~/", File.stat(file).mode, 10, "ec2-user")
      }
    end
    
    puts "Public IP:       #{instance.public_ip_address}"
    puts "Public Hostname: #{hostname}"
    puts "Site URL:        https://#{hostname}"

    if options[:build_cd]
      puts "Launching live-cd build..."
      out,ret = ssh(hostname, "export PATH=/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH && cd /data/crankcase/build && rake devcd", 60 * 60 * 2,false,1 , "ec2-user")
    end
    puts "Done."
  end

  desc "launch NAME", "Launches the latest DevEnv instance, tagging with NAME"
  method_option :verifier, :type => :boolean, :desc => "Add verifier functionality (private IP setup and local tests)"
  method_option :use_stage_image, :type => :boolean, :desc => "Launch a stage DevEnv image"
  method_option :use_clean_image, :type => :boolean, :desc => "Launch a clean DevEnv image"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :express_server, :type => :boolean, :desc => "Set as express server in express.conf and leave on public_ip"
  method_option :ssh_config_verifier, :type => :boolean, :desc => "Set as verifier in .ssh/config"
  method_option :instance_type, :required => false, :desc => "Amazon machine type override (default m1.large)"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  method_option :image_name, :required => false, :desc => "AMI ID or DEVENV name to launch"

  def launch(name)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    # Override the machine type to launch if necessary
    if options[:instance_type]
      $amz_options[:instance_type] = options[:instance_type]
    end

    # Get the latest devenv image and create a new instance
    conn = connect(options.region)
    if options.use_stage_image?
      filter = DEVENV_STAGE_WILDCARD
    elsif options.use_clean_image?
      filter = DEVENV_CLEAN_WILDCARD
    else
      filter = DEVENV_WILDCARD
    end
    if options[:image_name]
      filter = options[:image_name]
      ami = get_specific_ami(conn, filter)
    else
      ami = get_latest_ami(conn, filter)
    end
    if ami.nil?
      puts "No image name '#{options[:image_name]}' found!"
      exit(1)
    else
      puts "Launching latest DevEnv instance #{ami.id} - #{ami.name}"
    end
    instance = launch_instance(ami, name)
    hostname = instance.dns_name
    puts "Done"
    puts "Hostname: #{hostname}"

    puts "Sleeping for 30 seconds to let node stabilize..."
    sleep 30
    puts "Done"

    update_facts(hostname)

    if options.verifier?
      print "Initializing git repo for syncing..."
      init_repo(hostname)
      puts "Done"
      update_remote_tests(instance.dns_name)
    end

    validate_instance(hostname)

    if options.ssh_config_verifier?
      public_ip = instance.public_ip_address
      ssh_config = "~/.ssh/config"
      pem_file = File.expand_path("~/.ssh/libra.pem")
      if not File.exist?(pem_file)
        # copy it from local repo
        cmd = "cp misc/libra.pem #{pem_file}"
        puts cmd
        system(cmd)
        system("chmod 600 #{pem_file}")
      end
      config_file = File.expand_path(ssh_config)

      config_template = <<END
Host verifier
  HostName 10.1.1.1
  User      root
  IdentityFile ~/.ssh/libra.pem
END

      if not FileTest.exists?(config_file)
        puts "File '#{ssh_config}' does not exists, creating..."
        system("touch #{ssh_config}")
        cmd = "chmod 600 #{ssh_config}"
        system(cmd)
        file_mode = 'w'
        File.open(config_file, file_mode) { |f| f.write(config_template) }
      else
        if not system("grep -n 'Host verifier' #{config_file}")
          file_mode = 'a'
          File.open(config_file, file_mode) { |f| f.write(config_template) }
        end

      end

      line_num = `grep -n 'Host verifier' ~/.ssh/config`.chomp.split(':')[0]
      puts "Updating ~/.ssh/config verifier entry with public ip = #{public_ip}"
      (1..4).each do |i|
        `sed -i -e '#{line_num.to_i + i}s,HostName.*,HostName #{public_ip},' ~/.ssh/config`
      end
    end

    if options.express_server?
      public_ip = instance.public_ip_address
      puts "Updating ~/.openshift/express.conf libra_server entry with public ip = #{public_ip}"
      `sed -i -e 's,^libra_server.*,libra_server=#{public_ip},' ~/.openshift/express.conf`
    end

    home_dir=File.join(ENV['HOME'], '.openshiftdev/home.d')
    if File.exists?(home_dir)
      Dir.glob(File.join(home_dir, '???*'), File::FNM_DOTMATCH).each {|file|
        puts "Installing ~/#{File.basename(file)}"
        scp_to(hostname, file, "~/", File.stat(file).mode, 10)
      }
    end

    puts "Public IP:       #{instance.public_ip_address}"
    puts "Public Hostname: #{hostname}"
    puts "Site URL:        https://#{hostname}"
    puts "Done"
  end

  desc "sauce_usage", "Prints out usage information for sauce tests"
  method_option :sauce_username, :required => false, :desc => "Sauce Labs username (default '#{SAUCE_USER}')"
  method_option :sauce_access_key, :required => false, :desc => "Sauce Labs access key (default '#{SAUCE_SECRET}')"
  def sauce_usage
    usage = super options
    puts "Sauce Labs Usage: #{usage[:percentage]}% (#{usage[:used]} minutes of #{usage[:quota]})"
    return usage
  end

  desc "test TAG", "Runs the tests on a tagged instance and downloads the results"
  method_option :terminate, :type => :boolean, :desc => "Terminate the instance when finished"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :official, :type => :boolean, :desc => "For official use.  Send emails, etc."
  method_option :exclude_broker, :type => :boolean, :desc => "Exclude broker tests"
  method_option :exclude_runtime, :type => :boolean, :desc => "Exclude runtime tests"
  method_option :exclude_site, :type => :boolean, :desc => "Exclude site tests"
  method_option :exclude_rhc, :type => :boolean, :desc => "Exclude rhc tests"
  method_option :include_cucumber, :required => false, :desc => "Include a specific cucumber test (verify, internal, node, api, etc)"
  method_option :include_rcov, :type => :boolean, :desc => "Include coverage analysis on unit tests"
  method_option :include_extended, :required => false, :desc => "Include extended tests"
  method_option :disable_charlie, :type => :boolean, :desc=> "Disable idle shutdown timer on dev instance (charlie)"
  method_option :mcollective_logs, :type => :boolean, :desc=> "Don't allow mcollective logs to be deleted on rotation"
  method_option :profile_broker, :type => :boolean, :desc=> "Enable profiling code on broker"
  method_option :include_web, :type => :boolean, :desc => "Include running Selenium tests"
  method_option :sauce_username, :required => false, :desc => "Sauce Labs username (default '#{SAUCE_USER}')"
  method_option :sauce_access_key, :required => false, :desc => "Sauce Labs access key (default '#{SAUCE_SECRET}')"
  method_option :sauce_overage, :type => :boolean, :desc => "Run Sauce Labs tests even if we are over our monthly minute quota"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"

  def test(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    conn = connect(options.region)

    instance = find_instance(conn, tag, true)
    hostname = instance.dns_name

    test_instance(tag, hostname, instance, conn, options)
  end

  desc "sanity_check TAG", "Runs a set of sanity check tests on a tagged instance"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :region, :required => false, :desc => "Amazon region override (default us-east-1)"
  def sanity_check(tag)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    conn = connect(options.region)

    instance = find_instance(conn, tag, true)
    hostname = instance.dns_name
    
    validate_instance(hostname)

    threads = []
    failures = []
    site_titles = ["Site Sanity"]
    site_cmds = ["cd li-test/site; rake test:sanity"]
    add_ssh_cmd_to_threads(hostname, threads, failures, site_titles, site_cmds)
    titles = ["Broker Sanity",
              "StickShift Broker Sanity",
              "StickShift Node Unit"]

    cmds = ["cd li-test/broker; rake test:sanity",
            "cd li-test/stickshift/broker; rake test:sanity",
            "cd li-test/stickshift/node; rake test"]
    add_ssh_cmd_to_threads(hostname, threads, failures, titles, cmds)
    add_ssh_cmd_to_threads(hostname, threads, failures, "Cucumber Sanity", "cucumber #{@@CUCUMBER_OPTIONS} -t @sanity li-test/tests/")

    threads.each do |t|
      t[0].join
    end

    unless failures.empty?
      failures.uniq!
      retry_test_failures(hostname, failures, 1)
    end
    validate_instance(hostname)
  end

  desc "setup_multi_node_broker", "Sets up verifier as a multi-node broker"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"

  def setup_multi_node_broker
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    #internal_hostname = get_internal_hostname("verifier")
    internal_ip = get_private_ip("verifier")
    ssh("verifier", "sed -i 's,^plugin.qpid.host.ha.*=.*,plugin.qpid.host.ha=#{internal_ip},' /etc/mcollective/client.cfg;" \
                  "sed -i 's,^plugin.qpid.host.ha.*=.*,plugin.qpid.host.ha=#{internal_ip},' /etc/mcollective/server.cfg;" \
                  "sed -i 's,^ssl-cert-name.*=.*,ssl-cert-name=#{internal_ip},' /etc/qpidd.conf;" \
                  "sed -i 's,^server_id.*=.*,server_id=#{internal_ip},' /etc/stickshift/devenv/qpid/make-certs.sh;" \
                  "sed -i 's,^owner_domain_name.*=.*,owner_domain_name=#{internal_ip},' /etc/stickshift/devenv/qpid/make-certs.sh;" \
                  "sed -i 's,^#-A,-A,' /etc/sysconfig/iptables;" \
                  "sed -i 's,^BROKER_HOST.*=.*,BROKER_HOST=#{internal_ip},' /etc/stickshift/stickshift-node.conf;" \
                  "pushd /etc/stickshift/devenv/qpid/ > /dev/null;" \
                  "./make-certs.sh;" \
                  "/bin/cp test/client_db/* /etc/qpid/pki/client_db/; /bin/cp test/server_db/* /etc/qpid/pki/server_db/;" \
                  "popd > /dev/null;" \
                  "restorecon -R /etc/qpid/pki/; chmod +r /etc/qpid/pki/client_db/* /etc/qpid/pki/server_db/*;" \
                  "service iptables restart; service qpidd restart; service mcollective restart", 240)

    puts ssh("verifier", "mco ping")
  end

  desc "add_multi_node_devenv", "Adds a node to a multi node devenv setup"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"

  def add_multi_node_devenv(hostname)
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    internal_hostname = get_internal_hostname("verifier")
    internal_ip = get_private_ip("verifier")

    puts `pushd /tmp > /dev/null; rm -rf /tmp/test; scp -r verifier:/etc/stickshift/devenv/qpid/test/ .; scp -r test/client_db/* #{hostname}:/etc/qpid/pki/client_db/; scp -r test/server_db/* #{hostname}:/etc/qpid/pki/server_db/; popd > /dev/null`
    puts `pushd /tmp > /dev/null; rm -rf /tmp/clients; scp -r verifier:/etc/mcollective/ssl/clients/ .; scp -r clients/* #{hostname}:/etc/mcollective/ssl/clients/; popd > /dev/null`

    ssh(hostname, "sed -i 's,^plugin.qpid.host.ha.*=.*,plugin.qpid.host.ha=#{internal_ip},' /etc/mcollective/server.cfg;" \
                  "restorecon -R /etc/qpid/pki/; chmod +r /etc/qpid/pki/client_db/* /etc/qpid/pki/server_db/*;" \
                  "sed -i 's,^BROKER_HOST.*=.*,BROKER_HOST=#{internal_ip},' /etc/stickshift/stickshift-node.conf;" \
                  "service qpidd stop; service mcollective restart", 240)

    puts ssh("verifier", "mco ping")
  end

  desc "install_local_client", "Builds and installs the local client rpm (uses sudo)"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"

  def install_local_client
    options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR

    if File.exists?('../rhc')
      inside('../rhc') do
        temp_commit

        puts "building rhc..."
        `tito build --rpm --test`
        puts "installing rhc..."
        `sudo rpm -Uvh --force /tmp/tito/noarch/rhc-*; rm -rf /tmp/tito; mkdir -p /tmp/tito`

        reset_temp_commit

        puts "Done"
      end
    else
      puts "Couldn't find ../rhc."
    end
  end

  desc "sync_groups GROUPNAME", "Copies the security group permission from specified region to other regions"
  method_option :clean, :type => :boolean, :desc => "Revokes any existing permissions and starts fresh"
  method_option :region, :required => false, :default => 'us-east-1', :desc => "Amazon region to copy (default us-east-1)"

  def sync_groups(group_name)
    conn = connect
    origin_sg = conn.regions[options.region].security_groups.filter('group-name', group_name).first
    if(origin_sg.nil?)
      puts "Group #{group_name} not found in region #{options.region}"
      exit 1
    end
    conn.regions.each do |region|
      #skip the region of origin
      next if(region.name == options.region)

      puts "Synching #{region.name}"
      sg = conn.regions[region.name].security_groups.filter('group-name', group_name).first
      #If group does not exist then create it
      if(sg.nil?)
        sg = conn.regions[region.name].security_groups.create(group_name)
        #open access within the group
        sg.authorize_ingress(:tcp, 0..65535, sg)
        sg.authorize_ingress(:udp, 0..65535, sg)
        sg.authorize_ingress(:icmp, -1, sg)
      elsif (options.clean)
        puts "Revoking existing permissions"
        sg.ingress_ip_permissions.each do |i|
          i.revoke()
        end
        #open access within the group
        sg.authorize_ingress(:tcp, 0..65535, sg)
        sg.authorize_ingress(:udp, 0..65535, sg)
        sg.authorize_ingress(:icmp, -1, sg)
      end
      puts "Adding permissions"
      origin_sg.ingress_ip_permissions.each do |i|
        i.ip_ranges.each do |ip|
          puts "#{i.protocol}  \tport_range=#{i.port_range}\t" +
          "ip_range=#{ip} "
          begin
            sg.authorize_ingress(i.protocol , i.port_range, ip )
          rescue AWS::EC2::Errors::InvalidPermission::Duplicate
            puts "Permission already exists."
          end
        end
        i.groups.each do |g|
          if(g.owner_id != sg.owner_id)
            puts "#{i.protocol}  \tport_range=#{i.port_range}\t" +
            "group name=#{g.name} owner=#{g.owner_id} id=#{g.group_id} "
            if(g.exists?)
              begin
                sg.authorize_ingress(i.protocol , i.port_range, g )
              rescue AWS::EC2::Errors::InvalidPermission::Duplicate
                puts "Permission already exists."
              end
            else
              puts "ERROR: Group name=#{g.name} owner=#{g.owner_id} id=#{g.group_id} " +
              "does not exist or is in a different region."
            end
          end
        end
      end
    end
  end
end

DevEnv.start
