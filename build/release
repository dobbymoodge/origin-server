#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))

require 'rubygems'
require 'thor'
require 'lib/openshift'

class Release < Thor
  include Thor::Actions
  include OpenShift::Tito
  
  method_option :temp_dir, :type => :string, :default => '/tmp', :desc => "A location to write temporary files to"
  def initialize(*args)
    super(*args)
  end
  
  no_tasks do
    def git_pull
      run("git pull", :verbose => options.verbose?)
      SIBLING_REPOS.each do |repo_name, repo_dirs|
        repo_dirs.each do |repo_dir|
          if File.exists?(repo_dir)
            inside(repo_dir) do
              run("git pull", :verbose => options.verbose?)
            end
            break
          end
        end
      end
    end

    def next_patch_version(version)
      last_index_of_dot = version.rindex('.')
      version[0..last_index_of_dot] + (version[last_index_of_dot+1..-1].to_i + 1).to_s
    end

    def next_minor_version(version)
      index_of_dot = version.index('.')
      second_index_of_dot = version.index('.', index_of_dot + 1)
      last_index_of_dot = version.rindex('.')
      if version[last_index_of_dot+1..-1].to_i > 1
        version[0..index_of_dot] + (version[index_of_dot + 1..second_index_of_dot].to_i + 1).to_s + ".0"
      end
    end

    def get_version(file)
      version = /Version: *(.*)/.match(File.read(file))[1].strip
    end

    def update_gemfile_version(spec_file, gem_name, gemfile, verbose)
      version = get_version(spec_file)
      nv = next_patch_version(version)
      run("/bin/sed -i 's,#{gem_name} (.*,#{gem_name} (#{nv}),' #{gemfile}", :verbose => verbose)
    end

    def get_updated_build_dirs(verbose, push_changes=false)
      gem_updates = false
      
      all_packages = get_packages
      build_dirs = get_build_dirs

      build_dirs.each do |build_info|
        package_name = build_info[0]
        build_dir = build_info[1]
        spec_file = build_info[2]

        if package_name == 'rubygem-stickshift-common'
          update_gemfile_version(spec_file, 'stickshift-common', "broker/Gemfile.lock", verbose)
          update_gemfile_version(spec_file, 'stickshift-common', "#{build_dir}/../broker/Gemfile.lock", verbose)
          update_gemfile_version(spec_file, 'stickshift-common', "#{build_dir}/../node/Gemfile.lock", verbose)
          gem_updates = true
        end

        if package_name == 'rubygem-stickshift-node' || package_name == 'rubygem-stickshift-common'
          pkg = all_packages['rubygem-stickshift-node']
          build_dir = pkg[0]
          spec_file = pkg[1]
          update_gemfile_version(spec_file, 'stickshift-node', "#{build_dir}/Gemfile.lock", verbose)
          update_gemfile_version(spec_file, 'stickshift-node', "#{build_dir}/../broker/Gemfile.lock", verbose)
          gem_updates = true
        end

        if package_name == 'rubygem-stickshift-controller'
          update_gemfile_version(spec_file, 'stickshift-controller', "broker/Gemfile.lock", verbose)
          update_gemfile_version(spec_file, 'stickshift-controller', "#{build_dir}/../broker/Gemfile.lock", verbose)
          gem_updates = true
        end

        if package_name == 'rubygem-gearchanger-m-collective-plugin'
          update_gemfile_version(spec_file, 'gearchanger-m-collective-plugin', "broker/Gemfile.lock", verbose)
          gem_updates = true
        end

        if package_name == 'rubygem-swingshift-streamline-plugin'
          update_gemfile_version(spec_file, 'swingshift-streamline-plugin', "broker/Gemfile.lock", verbose)
          gem_updates = true
        end

        if package_name == 'rubygem-uplift-dynect-plugin'
          update_gemfile_version(spec_file, 'uplift-dynect-plugin', "broker/Gemfile.lock", verbose)
          gem_updates = true
        end

      end
      
      if gem_updates
        if push_changes
          branch = get_branch
          run("git add broker/Gemfile.lock; git commit -m 'Updating gem versions'; git push origin #{branch}", :verbose => options.verbose?)
          inside('../crankcase') do
            branch = get_branch
            run("git add stickshift/node/Gemfile.lock stickshift/broker/Gemfile.lock; git commit -m 'Updating gem versions'; git push origin #{branch}", :verbose => options.verbose?)
          end
          build_dirs = get_build_dirs
        end
      end
      build_dirs
    end
  end

  desc "check", "Check the directories that need to be released"
  def check
    branch = get_branch
    orig_branches = checkout_branch(branch)
    begin
      git_pull
      build_dir_list = get_build_dirs.map do |build_info|
        build_info[1]
      end
      puts "Changes detected in the following directories: #{build_dir_list.pretty_inspect}"
    ensure
      reset_orig_branches(orig_branches)
    end
  end
  
  desc "update_gem_versions", "Update the gem versions for gems going to be released"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :push_changes, :type => :boolean, :desc => "Push the changes to the current branch"
  def update_gem_versions
    get_updated_build_dirs(options.verbose?, options.push_changes?)
  end
  
  desc "release_jenkins_plugin", "Brew build the jenkins plugin"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def release_jenkins_plugin(commit_message, committer_name="Dan McPherson", committer_email="dmcphers@redhat.com")
    if File.exists?("../jenkins-cloud")
      inside("../jenkins-cloud") do
        run("git pull", :verbose => options.verbose?)
        exit unless run("mvn package -DskipTests", :verbose => options.verbose?)
      end
      inside("..") do
        FileUtils.rm_rf "jenkins-plugin-openshift/"
        exit unless run("rhpkg clone -b libra-rhel-6.2 jenkins-plugin-openshift", :verbose => options.verbose?)
      end
      inside("../jenkins-plugin-openshift/") do
        FileUtils.cp "../jenkins-cloud/target/openshift.hpi", "./openshift.hpi"
        version = /^(Version: )(.*)/.match(File.read("jenkins-plugin-openshift.spec"))[2].strip
        nv = next_patch_version(version)
        run("sed -i 's/Version:.*#{version}.*/Version: #{nv}/' jenkins-plugin-openshift.spec", :verbose => options.verbose?)
        date = `date +'%a %b %d %Y'`.chomp
        puts "sed -i 's/%changelog.*/%changelog\\n* #{date} #{committer_name} <#{committer_email}> - #{nv}\\n- #{commit_message}/' jenkins-plugin-openshift.spec"
        run("sed -i 's/%changelog.*/%changelog\\n* #{date} #{committer_name} <#{committer_email}> - #{nv}\\n- #{commit_message}/' jenkins-plugin-openshift.spec", :verbose => options.verbose?)
        if run("rhpkg commit -p -m '#{commit_message}'", :verbose => options.verbose?)
          run("rhpkg build", :verbose => options.verbose?)
        end
      end
    else
      puts "Jenkins plugin not found at ../jenkins-cloud"
    end
  end

  desc "build", "Tag and build new RPMs for any changes"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def build
  
    unless run("if [ -n \"${http_proxy+x}\" ]; then exit 1; fi", :verbose => options.verbose?)
      puts "ERROR - you need to unset http_proxy first"; exit 1
    end

    unless run("klist | grep REDHAT.COM@REDHAT.COM", :verbose => options.verbose?)
      puts "ERROR - you need to kinit first"; exit 1
    end

    branch = get_branch
    orig_branches = checkout_branch(branch)
    begin

      # Update the repo
      git_pull
    
      build_dirs = get_updated_build_dirs(options.verbose?, true)

      build_dirs.each do |build_info|
        build_dir = build_info[1]
        inside(File.expand_path("../#{build_dir}", File.dirname(__FILE__))) do
          puts "Releasing #{build_dir}"

          # Cleanup any tito data
          unless run("rm -rf #{options.temp_dir}/tito/cvswork/", :verbose => options.verbose?)
            puts "ERROR - tito temp cleanup failed"; exit 1
          end

          # Tag the package and push the tags
          unless run("tito tag --accept-auto-changelog", :verbose => options.verbose?)
            puts "ERROR - tito tagging failed"; exit 1
            exit 1
          end

          branch = get_branch
          unless run("git pull && git push origin #{branch} && git push --tags", :verbose => options.verbose?)
            puts "ERROR - tito tag push failed"; exit 1
          end

          # Detect which tito command is available
          `tito release --help`
          cmd_exit = $?.exitstatus
          if cmd_exit == 0
            # The release command is supported - use it
            tito_cmd = "tito release brew < #{options.temp_dir}/answerfile"
          else
            raise "Your version of tito is no longer supported after the Brew migration to git"
          end

          # Build the RPM in brew
          run("echo -e 'y\nn' > #{options.temp_dir}/answerfile", :verbose => options.verbose?)
          unless run(tito_cmd, :verbose => options.verbose?)
            puts "ERROR - tito cvs release failed"
          end
          puts "Done"
        end
      end
    ensure
      reset_orig_branches(orig_branches)
    end
    
    if File.exists?("../jenkins-cloud")
      inside("../jenkins-cloud") do
        git_pull_output = `git pull`.chomp
        unless git_pull_output.include?("Already up-to-date.")
          puts ""
          puts "#########################################"
          puts "INFO: There is a change to the jenkins plugin.  You can release it with 'build/release release_jenkins_plugin'"
          puts "#########################################"
          puts ""
        end
      end
    end
  end

  desc "sync", "Download a build from Brew (using Mash) and sync it to the OpenShift repos"
  method_option :stage, :type => :string, :desc => "Comma-delimited list of packages to sync.  Exclude NVR for latest versions.  (e.g. --stage='rhc, rhc-site-0.73.3-1')"
  method_option :stage_all, :type => :boolean, :desc => "Tag all the latest packages for stage"
  method_option :clean_ami, :type => :boolean, :desc => "Indicates whether to build a clean ami"
  method_option :no_ami, :type => :boolean, :desc => "Indicates whether to not build an ami"
  method_option :source_ami, :type => :boolean, :desc => "Indicates whether to build a source ami"
  def sync
    orig_branches = checkout_branch(options[:stage] || options.stage? ? "stage" : "master")
    begin
      # do RHEL 6.x first
      mash_and_rsync "libra-rhel-6.2", false, options

      # now RHEL 5.x, skipping rhc gem build/deploy
      mash_and_rsync "libra-rhel-5.8", true, options

      unless options.no_ami?
        create_ami options
      end
    ensure
      reset_orig_branches(orig_branches)
    end
  end
  
  desc "bump_minor_versions", "Bump the minor version in all specs > .1 patch level"
  method_option :push_changes, :type => :boolean, :desc => "Push the changes to the current branch"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def bump_minor_versions
    orig_branches = checkout_branch("master")
    begin
      all_packages = get_packages
      IGNORE_PACKAGES.each do |package|
        all_packages.delete(package)
      end
      all_packages.each do |package_name, pkg|
        build_dir = pkg[0]
        spec_file = pkg[1]
        version = get_version(spec_file)
        new_version = next_minor_version(version)
        run("/bin/sed -i 's,^Version:.*,Version: #{new_version},' #{spec_file}", :verbose => options.verbose?)
      end
      if options.push_changes?
        run("git add *.spec; git commit -m 'bumping spec versions'; git push origin master", :verbose => options.verbose?)
        SIBLING_REPOS.each do |repo_name, repo_dirs|
          repo_dirs.each do |repo_dir|
            if File.exists?(repo_dir)
              inside(repo_dir) do
                run("git add *.spec; git commit -m 'bumping spec versions'; git push origin master", :verbose => options.verbose?)
              end
              break
            end
          end
        end
      end
    ensure
      reset_orig_branches(orig_branches)
    end
  end
  
  desc "build_ami", "Build an ami based on the current li repo"
  method_option :stage, :type => :string, :desc => "Indicates whether to use the stage repo"
  method_option :clean_ami, :type => :boolean, :desc => "Indicates whether to build a clean ami"
  method_option :source_ami, :type => :boolean, :desc => "Indicates whether to build a source ami"
  def build_ami
    create_ami options
  end

  # sync impl methods
  no_tasks do
    def checkout_branch(branch="master")
      orig_branch = get_branch
      orig_branches = {}
      if orig_branch != branch
        orig_branches[FileUtils.pwd] = orig_branch
        run("git checkout #{branch}")
      end
      SIBLING_REPOS.each do |repo_name, repo_dirs|
        repo_dirs.each do |repo_dir|
          if File.exists?(repo_dir)
            inside(repo_dir) do
              orig_branch = get_branch
              if orig_branch != branch
                orig_branches[repo_dir] = orig_branch
                run("git checkout #{branch}")
              end
            end
            break
          end
        end
      end
      orig_branches
    end
    
    def reset_orig_branches(orig_branches)
      orig_branches.each do |repo_dir, branch|
        inside(repo_dir) do
          run("git checkout #{branch}")
        end
      end
    end
    
    
    def mash_and_rsync(tag_base, skip_gem, options)
      # Mash / RSync parameters
      mash_config = (options[:stage] || options.stage_all?) ? "#{tag_base}-stage" : "#{tag_base}-candidate"
      repo_host = "mirror1.stg.rhcloud.com"
      repo_dir = "/export/gpxe/trees"
      repo = "#{repo_host}:#{repo_dir}"
      rsync = nil
      if options[:stage] || options.stage_all?
        rsync = "rsync -aHv --progress --no-g --omit-dir-times --chmod=Dug=rwX"
      else
        rsync = "rsync -aHv --delete-after --progress --no-g --omit-dir-times --chmod=Dug=rwX"
      end
  
      # derive pkg_suffix from tag_base
      if tag_base =~ /^.*rhel-(\d)\.(\d)$/
        pkg_suffix = "el#{$1}_#{$2}"
      else
        pkg_suffix = "el6_2"
      end
      
      pkg_suffix = "el5" if pkg_suffix == "el5_8"
  
      # Check the Brew installation
      `brew --help`
      unless $? == 0
        puts "ERROR - Brew not installed.  Read misc/docs/BREW for setup steps"
        exit 2
      end
  
      # Check the mash installation
      unless File.exists?("/etc/mash/#{mash_config}.mash")
        puts "ERROR - Mash configuration missing.  Read misc/docs/BREW for setup steps"
        exit 2
      end
  
      # Make sure we have write access to /var/cache/mash
      begin
        File.new("/var/cache/mash/.rhcignore", "w")
        File.delete("/var/cache/mash/.rhcignore")
      rescue Errno::EACCES
        puts "ERROR - user doesn't have write access to /var/cache/mash - mash needs write access to this directory"
        exit 2
      end
  
      # See if we are doing a stage sync - if so, tag the packages listed
      if (options[:stage] and !options[:stage].empty?) or options.stage_all?

        all_packages = get_packages
        nvr_regex = /(.*)-(\d+)\.(\d+)\.(\d+)-?(\d)?/

        packages = nil
        if options[:stage]
          packages = options[:stage].split(",").map do |package|
            package.strip!
            pkg = package
            if nvr_regex.match(package)
              pkg = $1
            end
            unless all_packages[pkg]
              puts "Couldn't find '#{pkg}' on local system.  You probably don't have one of these repos #{SIBLING_REPOS}"
              exit 1
            end
            package
          end
        else
          packages = all_packages.keys
          packages -= IGNORE_PACKAGES
        end
        
        packages.each do |package|
          # Check for the supplied NVR value (e.g. 0.45.1)
          if nvr_regex.match(package)
            pkg = $1 
            # Confirm the package is valid
            nvr_package = nil
            build_info = all_packages[pkg]
            build_dir = build_info[0]
            inside(build_dir) do
              nvr_package = `git tag | grep #{package} | tail -n1`.chomp
            end
  
            unless nvr_package.empty?
              package = nvr_package
            else
              puts "ERROR - invalid package supplied #{package}"
              exit 1
            end
          else
            # No NVR was specified - lookup the latest
            tags = []
            build_info = all_packages[package]
            build_dir = build_info[0]
            inside(build_dir) do
              tags = `git tag | grep #{package}-[0-9]`.chomp.split("\n")
            end
  
            # Sort the tags by NVR and take the last entry
            package = tags.sort_by {|tag| nvr_regex.match(tag); $1 ? [$1, $2.to_i, $3.to_i, $4.to_i, $5.to_i] : []}[-1]
          end
  
          puts "Tagging package #{package}..."
          puts `brew tag-pkg #{mash_config} #{package}.#{pkg_suffix}`
        end
      end
  
      # Run mash twice since it usually fails the first time
      puts "Running mash sync"
      mash_cmd = "/usr/bin/mash -o #{options.temp_dir}/#{mash_config} -c /etc/mash/li-mash.conf #{mash_config}"
      puts mash_cmd
      run(mash_cmd, :verbose => options.verbose?)
      unless run(mash_cmd, :verbose => options.verbose?)
        puts "ERROR - mash sync failed"
        exit 1
      end
  
      # If createrepo understands --compress-type flag, it will create repodata in RHEL5-unfriendly format
      # recreate repo metadata if we are targeting RHEL5 and createrepo is sufficiently equipped
      if pkg_suffix =~ /^el5/
        `/usr/bin/createrepo -h | grep -q compress-type`
        cmd_exit = $?.exitstatus
        if cmd_exit == 0
          repos = `/usr/bin/find #{options.temp_dir}/#{mash_config} -type d -name repodata | /bin/sed 's,/repodata$,,'`.chomp.split("\n")
          repos.each do |repo_dir|
            `/usr/bin/createrepo -s sha --compress-type bz2 #{repo_dir}`
          end
        end
      end

      unless skip_gem
        # Build the gem locally since it's not stored centrally like RPMs in Brew
        puts "Building client gem..."
        if File.exists?('../os-client-tools/express')
          inside(File.expand_path(File.dirname(File.expand_path(__FILE__)) + "/../../os-client-tools/express")) do
            unless run('./build_pure.sh', :verbose => options.verbose?)
              puts "ERROR - client gem building failed"
              exit 1
            end
          end
          puts "Done"
        else
          puts "Couldn't find ../os-client-tools/express.  Skipping build client gem step."
        end

      end

      puts "Syncing RPMs to repo..."
      unless run("#{rsync} #{options.temp_dir}/#{mash_config}/#{mash_config}/* #{repo}/#{mash_config}/", :verbose => options.verbose?)
        puts "ERROR - RPM sync failed."
        exit 1
      end
      
      unless skip_gem
        # sync rhc gem
        puts "Syncing client gem to repo..."
        if File.exists?('../os-client-tools/express')
          unless run("#{rsync} ../os-client-tools/express/pkg/*.gem #{repo}/#{mash_config}/client/gems/", :verbose => options.verbose?)
            puts "ERROR - Gem sync failed."
            exit 1
          end
          puts "Done"
        else
          puts "Couldn't find ../os-client-tools/express.  Skipping rsync client gem step."
        end
      end
  
      unless skip_gem
        puts "Updating gem indexes..."
        unless run("ssh #{repo_host} 'gem generate_index -d #{repo_dir}/#{mash_config}/client'", :verbose => options.verbose?)
          puts "ERROR - Gem index update failed."
          exit 1
        end
        puts "Done"
      end
    end
  
    def create_ami(options)
      # Jenkins parameters
      proxy = "squid.corp.redhat.com:8080"
      jenkins = "https://ci.dev.openshift.redhat.com/jenkins"
      token = "libra1"
  
      if options.stage?
        puts "Kicking off stage verification..."
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/libra_ami_stage/buildWithParameters?token=#{token}\\&BUILD_CLEAN_AMI=#{options.clean_ami? ? "true" : "false"}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
        puts "Done"
      else
        puts "Kicking off AMI build..."
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/libra_ami/buildWithParameters?token=#{token}\\&BUILD_CLEAN_AMI=#{options.clean_ami? ? "true" : "false"}\\&INSTALL_FROM_SOURCE=#{options.source_ami? ? "true" : "false"}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
        puts "Done"
      end
    end
  end
end

Release.start
