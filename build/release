#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))

require 'rubygems'
require 'thor'
require 'lib/openshift'

class Release < Thor
  include Thor::Actions
  include OpenShift::Tito
  
  no_tasks do
    def git_pull
      run("git pull", :verbose => options.verbose?)
      if File.exists?('../os-client-tools')
        inside('../os-client-tools') do
          run("git pull", :verbose => options.verbose?)
        end
      end
    end
  end

  desc "check", "Check the directories that need to be released"
  def check
    git_pull
    puts "Changes detected in the following directories: #{get_build_dirs.pretty_inspect}"
  end

  desc "build", "Tag and build new RPMs for any changes"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def build
  
    unless run("if [ -n \"${http_proxy+x}\" ]; then exit 1; fi", :verbose => options.verbose?)
      puts "ERROR - you need to unset http_proxy first"; exit 1
    end

    unless run("klist | grep REDHAT.COM@REDHAT.COM", :verbose => options.verbose?)
      puts "ERROR - you need to kinit first"; exit 1
    end
     
    # Update the repo
    git_pull

    get_build_dirs.each do |build_dir|
      inside(File.expand_path("../#{build_dir}", File.dirname(__FILE__))) do
        puts "Releasing #{build_dir}"

        # Cleanup any tito data
        unless run("rm -rf /tmp/tito/cvswork/rhc*", :verbose => options.verbose?)
          puts "ERROR - tito temp cleanup failed"; exit 1
        end

        # Tag the package and push the tags
        unless run("tito tag --accept-auto-changelog", :verbose => options.verbose?)
          puts "ERROR - tito tagging failed"; exit 1
          exit 1
        end

        unless run("git pull && git push && git push --tags", :verbose => options.verbose?)
          puts "ERROR - tito tag push failed"; exit 1
        end

        # Detect which tito command is available
        `tito release --help`
        cmd_exit = $?.exitstatus
        if cmd_exit == 0
          # The release command is supported - use it
          tito_cmd = "tito release --type=cvs < /tmp/answerfile"
        else
          # An older version of tito is present, use build
          tito_cmd = "tito build --cvs-release < /tmp/answerfile"
        end

        # Build the RPM in brew
        run('echo -e "y\nn" > /tmp/answerfile', :verbose => options.verbose?)
        unless run(tito_cmd, :verbose => options.verbose?)
          puts "ERROR - tito cvs release failed"
        end
        puts "Done"
      end
    end
  end

  desc "sync", "Download a build from Brew (using Mash) and sync it to the OpenShift repos"
  method_option :stage, :type => :string, :desc => "Comma-delimited list of packages to sync.  Exclude NVR for latest versions.  (e.g. --stage='rhc, rhc-site-0.73.3-1')"
  method_option :clean_ami, :type => :boolean, :desc => "Indicates whether to build a clean ami"
  method_option :no_ami, :type => :boolean, :desc => "Indicates whether to not build an ami"
  def sync

    # Mash / RSync parameters
    pkg_suffix = "el6_1"
    mash_config = options[:stage] ? "libra-rhel-6.1-stage" : "libra-rhel-6.1-candidate"
    repo_host = "209.132.178.9"
    repo_dir = "/srv/web/gpxe/trees"
    repo = "root@#{repo_host}:#{repo_dir}"
    rsync = nil
    if options[:stage]
      rsync = "rsync -avz -e ssh"
    else
      rsync = "rsync --delete -avz -e ssh"
    end

    # Jenkins parameters
    proxy = "squid.corp.redhat.com:8080"
    jenkins = "https://ci.dev.openshift.redhat.com/jenkins"
    token = "libra1"

    # Check the Brew installation
    `brew --help`
    unless $? == 0
      puts "ERROR - Brew not installed.  Read misc/docs/BREW for setup steps"
      exit 2
    end

    # Check the mash installation
    unless File.exists?("/etc/mash/#{mash_config}.mash")
      puts "ERROR - Mash configuration missing.  Read misc/docs/BREW for setup steps"
      exit 2
    end

    # Make sure we have write access to /var/cache/mash
    begin
      File.new("/var/cache/mash/.rhcignore", "w")
      File.delete("/var/cache/mash/.rhcignore")
    rescue Errno::EACCES
      puts "ERROR - user doesn't have write access to /var/cache/mash - mash needs write access to this directory"
      exit 2
    end

    # See if we are doing a stage sync - if so, tag the packages listed
    if options[:stage] and !options[:stage].empty?
      options[:stage].split(",").each do |package|
        package.strip!

        nvr_regex = /(.*)-(\d+)\.(\d+)\.(\d+)-?(\d)?/

        # Check for the supplied NVR value (e.g. 0.45.1)
        if nvr_regex.match(package)
          # Confirm the package is valid
          nvr_package = nil
          if package =~ /^rhc-(\d)/
            if File.exists?('../os-client-tools')
              inside('../os-client-tools') do
                nvr_package = `git tag | grep #{package} | tail -n1`.chomp
              end
            else            
              puts "Couldn't find ../os-client-tools."
              exit 1
            end
          else
            nvr_package = `git tag | grep #{package} | tail -n1`.chomp
          end

          unless nvr_package.empty?
            package = nvr_package
          else
            puts "ERROR - invalid package supplied #{package}"
            exit 1
          end
        else
          # No NVR was specified - lookup the latest
          tags = []
          if package == 'rhc'
            if File.exists?('../os-client-tools')
              inside('../os-client-tools') do
                tags = `git tag | grep -e rhc-[0-9]`.chomp.split("\n")
              end
            else            
              puts "Couldn't find ../os-client-tools."
              exit 1
            end
          else
            tags = `git tag | grep #{package}-`.chomp.split("\n")
          end

          # Sort the tags by NVR and take the last entry
          package = tags.sort_by {|tag| nvr_regex.match(tag); $1 ? [$1, $2.to_i, $3.to_i, $4.to_i, $5.to_i] : []}[-1]
        end

        puts "Tagging package #{package}..."
        puts `brew tag-pkg #{mash_config} #{package}.#{pkg_suffix}`
      end
    end

    # Run mash twice since it usually fails the first time
    puts "Running mash sync"
    mash_cmd = "/usr/bin/mash -o /tmp/#{mash_config} -c /etc/mash/li-mash.conf #{mash_config}"
    puts mash_cmd
    run(mash_cmd, :verbose => options.verbose?)
    unless run(mash_cmd, :verbose => options.verbose?)
      puts "ERROR - mash sync failed"
      exit 1
    end

    # Build the gem locally since it's not stored centrally like RPMs in Brew
    puts "Building client gem..."
    if File.exists?('../os-client-tools/express')
      inside(File.expand_path(File.dirname(File.expand_path(__FILE__)) + "/../../os-client-tools/express")) do
        unless run('./build_pure.sh', :verbose => options.verbose?)
          puts "ERROR - client gem building failed"
          exit 1
        end
      end
      puts "Done"
    else
      puts "Couldn't find ../os-client-tools/express.  Skipping build client gem step."
    end

    puts "Syncing RPMs and gems to repo..."
    unless run("#{rsync} /tmp/#{mash_config}/#{mash_config}/* #{repo}/#{mash_config}/", :verbose => options.verbose?)
      puts "ERROR - RPM sync failed.  Make sure you have root access on #{repo_host}"
      exit 1
    end
    
    if File.exists?('../os-client-tools/express')
      unless run("#{rsync} ../os-client-tools/express/pkg/*.gem #{repo}/#{mash_config}/client/gems/", :verbose => options.verbose?)
        puts "ERROR - Gem sync failed.  Make sure you have root access on #{repo_host}"
        exit 1
      end
      puts "Done"
    else
      puts "Couldn't find ../os-client-tools/express.  Skipping rsync client gem step."
    end

    puts "Updating gem indexes..."
    unless run("ssh root@#{repo_host} 'gem generate_index -d #{repo_dir}/#{mash_config}/client'", :verbose => options.verbose?)
      puts "ERROR - Gem index update failed."
      exit 1
    end
    puts "Done"

    unless options.no_ami?
      if options[:stage]
        puts "Kicking off stage verification..."
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/libra_ami_stage/build?token=#{token}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
        puts "Done"
      else
        puts "Kicking off AMI build..."
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/libra_ami#{options.clean_ami? ? "" : "_update"}/build?token=#{token}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
        puts "Done"
      end
    end
  end
end

Release.start
