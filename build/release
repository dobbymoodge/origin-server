#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))

require 'rubygems'
require 'thor'
require 'lib/openshift'

class Release < Thor
  include Thor::Actions
  include OpenShift::Tito
  
  method_option :temp_dir, :type => :string, :default => '/tmp', :desc => "A location to write temporary files to"
  def initialize(*args)
    super(*args)
  end
  
  no_tasks do
    def git_pull
      run("git pull", :verbose => options.verbose?)
      if File.exists?('../os-client-tools')
        inside('../os-client-tools') do
          run("git pull", :verbose => options.verbose?)
        end
      end
    end
    
    def next_version(version)
      last_index_of_dot = version.rindex('.')
      version[0..last_index_of_dot] + (version[last_index_of_dot+1..-1].to_i + 1).to_s
    end
    
    def get_updated_build_dirs(verbose, push_changes=false)
      build_dirs = get_build_dirs
      gem_updates = false
      if build_dirs.include?("stickshift/common")
        version = /(Version: )(.*)/.match(File.read("stickshift/common/stickshift-common.spec"))[2].strip
        nv = next_version(version)
        run("/bin/sed -i 's,stickshift-common (.*,stickshift-common (#{nv}),' broker/Gemfile.lock", :verbose => verbose)
        #run("/bin/sed -i 's,stickshift-common (.*,stickshift-common (#{nv}),' stickshift/controller/Gemfile.lock", :verbose => verbose)
        run("/bin/sed -i 's,stickshift-common (.*,stickshift-common (#{nv}),' stickshift/broker/Gemfile.lock", :verbose => verbose)
        run("/bin/sed -i 's,stickshift-common (.*,stickshift-common (#{nv}),' stickshift/node/Gemfile.lock", :verbose => verbose)
        gem_updates = true
      end
      
      if build_dirs.include?("stickshift/controller") || build_dirs.include?("stickshift/common")
        version = /(Version: )(.*)/.match(File.read("stickshift/controller/stickshift-controller.spec"))[2].strip
        nv = next_version(version)
        run("/bin/sed -i 's,stickshift-controller (.*,stickshift-controller (#{nv}),' broker/Gemfile.lock", :verbose => verbose)
        #run("/bin/sed -i 's,stickshift-controller (.*,stickshift-controller (#{nv}),' stickshift/controller/Gemfile.lock", :verbose => verbose)
        run("/bin/sed -i 's,stickshift-controller (.*,stickshift-controller (#{nv}),' stickshift/broker/Gemfile.lock", :verbose => verbose)
        gem_updates = true
      end
      
      if build_dirs.include?("stickshift/node") || build_dirs.include?("stickshift/common")
        version = /(Version: )(.*)/.match(File.read("stickshift/node/stickshift-node.spec"))[2].strip
        nv = next_version(version)
        run("/bin/sed -i 's,stickshift-node (.*,stickshift-node (#{nv}),' stickshift/node/Gemfile.lock", :verbose => verbose)
        run("/bin/sed -i 's,stickshift-node (.*,stickshift-node (#{nv}),' stickshift/broker/Gemfile.lock", :verbose => verbose)
        gem_updates = true
      end
      
      if gem_updates
        branch = get_branch
        if push_changes
          run("git add broker/Gemfile.lock stickshift/node/Gemfile.lock stickshift/broker/Gemfile.lock; git commit -m 'Updating gem versions'; git push origin #{branch}", :verbose => options.verbose?)
          build_dirs = get_build_dirs
        end
      end
      build_dirs
    end
  end

  desc "check", "Check the directories that need to be released"
  def check
    git_pull
    puts "Changes detected in the following directories: #{get_build_dirs.pretty_inspect}"
  end
  
  desc "update_gem_versions", "Update the gem versions for gems going to be released"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :push_changes, :type => :boolean, :desc => "Push the changes to the current branch"
  def update_gem_versions
    get_updated_build_dirs(options.verbose?, options.push_changes?)
  end
  
  desc "release_jenkins_plugin", "Brew build the jenkins plugin"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def release_jenkins_plugin(commit_message, committer_name="Dan McPherson", committer_email="dmcphers@redhat.com")
    if File.exists?("../jenkins-cloud")
      inside("../jenkins-cloud") do
        run("git pull", :verbose => options.verbose?)
        exit unless run("mvn package -DskipTests", :verbose => options.verbose?)
      end
      inside("..") do
        FileUtils.rm_rf "jenkins-plugin-openshift/"
        exit unless run("rhpkg clone -b libra-rhel-6.2 jenkins-plugin-openshift", :verbose => options.verbose?)
      end
      inside("../jenkins-plugin-openshift/") do
        FileUtils.cp "../jenkins-cloud/target/openshift.hpi", "./openshift.hpi"
        version = /^(Version: )(.*)/.match(File.read("jenkins-plugin-openshift.spec"))[2].strip
        nv = next_version(version)
        run("sed -i 's/Version:.*#{version}.*/Version: #{nv}/' jenkins-plugin-openshift.spec", :verbose => options.verbose?)
        date = `date +'%a %b %d %Y'`.chomp
        puts "sed -i 's/%changelog.*/%changelog\\n* #{date} #{committer_name} <#{committer_email}> - #{nv}\\n- #{commit_message}/' jenkins-plugin-openshift.spec"
        run("sed -i 's/%changelog.*/%changelog\\n* #{date} #{committer_name} <#{committer_email}> - #{nv}\\n- #{commit_message}/' jenkins-plugin-openshift.spec", :verbose => options.verbose?)
        if run("rhpkg commit -p -m '#{commit_message}'", :verbose => options.verbose?)
          run("rhpkg build", :verbose => options.verbose?)
        end
      end
    else
      puts "Jenkins plugin not found at ../jenkins-cloud"
    end
  end

  desc "build", "Tag and build new RPMs for any changes"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def build
  
    unless run("if [ -n \"${http_proxy+x}\" ]; then exit 1; fi", :verbose => options.verbose?)
      puts "ERROR - you need to unset http_proxy first"; exit 1
    end

    unless run("klist | grep REDHAT.COM@REDHAT.COM", :verbose => options.verbose?)
      puts "ERROR - you need to kinit first"; exit 1
    end
     
    # Update the repo
    git_pull
    
    build_dirs = get_updated_build_dirs(options.verbose?, true)

    build_dirs.each do |build_dir|
      inside(File.expand_path("../#{build_dir}", File.dirname(__FILE__))) do
        puts "Releasing #{build_dir}"

        # Cleanup any tito data
        unless run("rm -rf #{options.temp_dir}/tito/cvswork/", :verbose => options.verbose?)
          puts "ERROR - tito temp cleanup failed"; exit 1
        end

        # Tag the package and push the tags
        unless run("tito tag --accept-auto-changelog", :verbose => options.verbose?)
          puts "ERROR - tito tagging failed"; exit 1
          exit 1
        end

        branch = get_branch
        unless run("git pull && git push origin #{branch} && git push --tags", :verbose => options.verbose?)
          puts "ERROR - tito tag push failed"; exit 1
        end

        # Detect which tito command is available
        `tito release --help`
        cmd_exit = $?.exitstatus
        if cmd_exit == 0
          # The release command is supported - use it
          tito_cmd = "tito release brew < #{options.temp_dir}/answerfile"
        else
          raise "Your version of tito is no longer supported after the Brew migration to git"
        end

        # Build the RPM in brew
        run("echo -e 'y\nn' > #{options.temp_dir}/answerfile", :verbose => options.verbose?)
        unless run(tito_cmd, :verbose => options.verbose?)
          puts "ERROR - tito cvs release failed"
        end
        puts "Done"
      end
    end
    if File.exists?("../jenkins-cloud")
      inside("../jenkins-cloud") do
        git_pull_output = `git pull`.chomp
        unless git_pull_output.include?("Already up-to-date.")
          puts ""
          puts "#########################################"
          puts "INFO: There is a change to the jenkins plugin.  You can release it with 'build/release release_jenkins_plugin'"
          puts "#########################################"
          puts ""
        end
      end
    end
  end

  desc "sync", "Download a build from Brew (using Mash) and sync it to the OpenShift repos"
  method_option :stage, :type => :string, :desc => "Comma-delimited list of packages to sync.  Exclude NVR for latest versions.  (e.g. --stage='rhc, rhc-site-0.73.3-1')"
  method_option :clean_ami, :type => :boolean, :desc => "Indicates whether to build a clean ami"
  method_option :no_ami, :type => :boolean, :desc => "Indicates whether to not build an ami"
  method_option :source_ami, :type => :boolean, :desc => "Indicates whether to build a source ami"
  def sync
    # do RHEL 6.x first
    mash_and_rsync "libra-rhel-6.2", false, options

    # now RHEL 5.x, skipping rhc gem build/deploy
    mash_and_rsync "libra-rhel-5.8", true, options

    unless options.no_ami?
      create_ami options
    end
  end
  
  desc "build_ami", "Build an ami based on the current li repo"
  method_option :stage, :type => :string, :desc => "Indicates whether to use the stage repo"
  method_option :clean_ami, :type => :boolean, :desc => "Indicates whether to build a clean ami"
  method_option :source_ami, :type => :boolean, :desc => "Indicates whether to build a source ami"
  def build_ami
    create_ami options
  end

  # sync impl methods
  no_tasks do
    def mash_and_rsync(tag_base, skip_gem, options)
      # Mash / RSync parameters
      mash_config = options[:stage] ? "#{tag_base}-stage" : "#{tag_base}-candidate"
      repo_host = "mirror1.stg.rhcloud.com"
      repo_dir = "/export/gpxe/trees"
      repo = "#{repo_host}:#{repo_dir}"
      rsync = nil
      if options[:stage]
        rsync = "rsync -aHv --progress --no-g --omit-dir-times --chmod=Dug=rwX"
      else
        rsync = "rsync -aHv --delete-after --progress --no-g --omit-dir-times --chmod=Dug=rwX"
      end
  
      # derive pkg_suffix from tag_base
      if tag_base =~ /^.*rhel-(\d)\.(\d)$/
        pkg_suffix = "el#{$1}_#{$2}"
      else
        pkg_suffix = "el6_2"
      end
      
      pkg_suffix = "el5" if pkg_suffix == "el5_8"
  
      # Check the Brew installation
      `brew --help`
      unless $? == 0
        puts "ERROR - Brew not installed.  Read misc/docs/BREW for setup steps"
        exit 2
      end
  
      # Check the mash installation
      unless File.exists?("/etc/mash/#{mash_config}.mash")
        puts "ERROR - Mash configuration missing.  Read misc/docs/BREW for setup steps"
        exit 2
      end
  
      # Make sure we have write access to /var/cache/mash
      begin
        File.new("/var/cache/mash/.rhcignore", "w")
        File.delete("/var/cache/mash/.rhcignore")
      rescue Errno::EACCES
        puts "ERROR - user doesn't have write access to /var/cache/mash - mash needs write access to this directory"
        exit 2
      end
  
      # See if we are doing a stage sync - if so, tag the packages listed
      if options[:stage] and !options[:stage].empty?
        options[:stage].split(",").each do |package|
          package.strip!
  
          nvr_regex = /(.*)-(\d+)\.(\d+)\.(\d+)-?(\d)?/
  
          # Check for the supplied NVR value (e.g. 0.45.1)
          if nvr_regex.match(package)
            # Confirm the package is valid
            nvr_package = nil
            if package =~ /^rhc-(\d)/
              if File.exists?('../os-client-tools')
                inside('../os-client-tools') do
                  nvr_package = `git tag | grep #{package} | tail -n1`.chomp
                end
              else            
                puts "Couldn't find ../os-client-tools."
                exit 1
              end
            else
              nvr_package = `git tag | grep #{package} | tail -n1`.chomp
            end
  
            unless nvr_package.empty?
              package = nvr_package
            else
              puts "ERROR - invalid package supplied #{package}"
              exit 1
            end
          else
            # No NVR was specified - lookup the latest
            tags = []
            if package == 'rhc'
              if File.exists?('../os-client-tools')
                inside('../os-client-tools') do
                  tags = `git tag | grep -e rhc-[0-9]`.chomp.split("\n")
                end
              else            
                puts "Couldn't find ../os-client-tools."
                exit 1
              end
            else
              tags = `git tag | grep #{package}-`.chomp.split("\n")
            end
  
            # Sort the tags by NVR and take the last entry
            package = tags.sort_by {|tag| nvr_regex.match(tag); $1 ? [$1, $2.to_i, $3.to_i, $4.to_i, $5.to_i] : []}[-1]
          end
  
          puts "Tagging package #{package}..."
          puts `brew tag-pkg #{mash_config} #{package}.#{pkg_suffix}`
        end
      end
  
      # Run mash twice since it usually fails the first time
      puts "Running mash sync"
      mash_cmd = "/usr/bin/mash -o #{options.temp_dir}/#{mash_config} -c /etc/mash/li-mash.conf #{mash_config}"
      puts mash_cmd
      run(mash_cmd, :verbose => options.verbose?)
      unless run(mash_cmd, :verbose => options.verbose?)
        puts "ERROR - mash sync failed"
        exit 1
      end
  
      # If createrepo understands --compress-type flag, it will create repodata in RHEL5-unfriendly format
      # recreate repo metadata if we are targeting RHEL5 and createrepo is sufficiently equipped
      if pkg_suffix =~ /^el5/
        `/usr/bin/createrepo -h | grep -q compress-type`
        cmd_exit = $?.exitstatus
        if cmd_exit == 0
          repos = `/usr/bin/find #{options.temp_dir}/#{mash_config} -type d -name repodata | /bin/sed 's,/repodata$,,'`.chomp.split("\n")
          repos.each do |repo_dir|
            `/usr/bin/createrepo -s sha --compress-type bz2 #{repo_dir}`
          end
        end
      end

      unless skip_gem
        # Build the gem locally since it's not stored centrally like RPMs in Brew
        puts "Building client gem..."
        if File.exists?('../os-client-tools/express')
          inside(File.expand_path(File.dirname(File.expand_path(__FILE__)) + "/../../os-client-tools/express")) do
            unless run('./build_pure.sh', :verbose => options.verbose?)
              puts "ERROR - client gem building failed"
              exit 1
            end
          end
          puts "Done"
        else
          puts "Couldn't find ../os-client-tools/express.  Skipping build client gem step."
        end

      end

      puts "Syncing RPMs to repo..."
      unless run("#{rsync} #{options.temp_dir}/#{mash_config}/#{mash_config}/* #{repo}/#{mash_config}/", :verbose => options.verbose?)
        puts "ERROR - RPM sync failed."
        exit 1
      end
      
      unless skip_gem
        # sync rhc gem
        puts "Syncing client gem to repo..."
        if File.exists?('../os-client-tools/express')
          unless run("#{rsync} ../os-client-tools/express/pkg/*.gem #{repo}/#{mash_config}/client/gems/", :verbose => options.verbose?)
            puts "ERROR - Gem sync failed."
            exit 1
          end
          puts "Done"
        else
          puts "Couldn't find ../os-client-tools/express.  Skipping rsync client gem step."
        end

        # sync rhc-rest gem
        puts "Syncing rhc-rest gem to repo..."
        if File.exists?('../os-client-tools/rhc-rest')
          unless run("#{rsync} ../os-client-tools/rhc-rest/pkg/*.gem #{repo}/#{mash_config}/client/gems/", :verbose => options.verbose?)
            puts "ERROR - Gem sync failed."
            exit 1
          end
          puts "Done"
        else
          puts "Couldn't find ../os-client-tools/rhc-rest.  Skipping rsync client gem step."
        end
      end
  
      unless skip_gem
        puts "Updating gem indexes..."
        unless run("ssh #{repo_host} 'gem generate_index -d #{repo_dir}/#{mash_config}/client'", :verbose => options.verbose?)
          puts "ERROR - Gem index update failed."
          exit 1
        end
        puts "Done"
      end
    end
  
    def create_ami(options)
      # Jenkins parameters
      proxy = "squid.corp.redhat.com:8080"
      jenkins = "https://ci.dev.openshift.redhat.com/jenkins"
      token = "libra1"
  
      if options.stage?
        puts "Kicking off stage verification..."
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/libra_ami_stage/buildWithParameters?token=#{token}\\&BUILD_CLEAN_AMI=#{options.clean_ami? ? "true" : "false"}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
        puts "Done"
      else
        puts "Kicking off AMI build..."
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/libra_ami/buildWithParameters?token=#{token}\\&BUILD_CLEAN_AMI=#{options.clean_ami? ? "true" : "false"}\\&INSTALL_FROM_SOURCE=#{options.source_ami? ? "true" : "false"}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
        puts "Done"
      end
    end
  end
end

Release.start
