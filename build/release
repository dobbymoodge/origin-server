#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))

require 'rubygems'
require 'thor'
require 'lib/openshift'

class Release < Thor
  include Thor::Actions
  include OpenShift::Tito
  include OpenShift::Brew

  method_option :temp_dir, :type => :string, :default => '/tmp', :desc => "A location to write temporary files to"
  def initialize(*args)
    super(*args)
  end
  
  no_tasks do
    def git_pull
      run("git pull", :verbose => options.verbose?)
      SIBLING_REPOS.each do |repo_name, repo_dirs|
        repo_dirs.each do |repo_dir|
          if File.exists?(repo_dir)
            inside(repo_dir) do
              run("git pull", :verbose => options.verbose?)
            end
            break
          end
        end
      end
    end

    def get_updated_build_dirs(verbose, push_changes=false)
      gem_updates = false
      
      all_packages = get_packages
      build_dirs = get_build_dirs

      build_dirs.each do |build_info|
        package_name = build_info[0]
        build_dir = build_info[1]
        spec_file = build_info[2]

        if package_name == 'rubygem-stickshift-common'
          update_gemfile_version(spec_file, 'stickshift-common', "broker/Gemfile.lock", verbose)
          update_gemfile_version(spec_file, 'stickshift-common', "#{build_dir}/../broker/Gemfile.lock", verbose)
          update_gemfile_version(spec_file, 'stickshift-common', "#{build_dir}/../node/Gemfile.lock", verbose)
          gem_updates = true
        end

        if package_name == 'rubygem-stickshift-node' || package_name == 'rubygem-stickshift-common'
          pkg = all_packages['rubygem-stickshift-node']
          build_dir = pkg[0]
          spec_file = pkg[1]
          update_gemfile_version(spec_file, 'stickshift-node', "#{build_dir}/Gemfile.lock", verbose)
          update_gemfile_version(spec_file, 'stickshift-node', "#{build_dir}/../broker/Gemfile.lock", verbose)
          gem_updates = true
        end

        if package_name == 'rubygem-stickshift-controller'
          update_gemfile_version(spec_file, 'stickshift-controller', "broker/Gemfile.lock", verbose)
          update_gemfile_version(spec_file, 'stickshift-controller', "#{build_dir}/../broker/Gemfile.lock", verbose)
          gem_updates = true
        end

        if package_name == 'rubygem-gearchanger-m-collective-plugin'
          update_gemfile_version(spec_file, 'gearchanger-m-collective-plugin', "broker/Gemfile.lock", verbose)
          gem_updates = true
        end
        
        if package_name == 'rubygem-gearchanger-mcollective-plugin'
          update_gemfile_version(spec_file, 'gearchanger-mcollective-plugin', "broker/Gemfile.lock", verbose)
          gem_updates = true
        end

        if package_name == 'rubygem-swingshift-streamline-plugin'
          update_gemfile_version(spec_file, 'swingshift-streamline-plugin', "broker/Gemfile.lock", verbose)
          gem_updates = true
        end

        if package_name == 'rubygem-uplift-dynect-plugin'
          update_gemfile_version(spec_file, 'uplift-dynect-plugin', "broker/Gemfile.lock", verbose)
          gem_updates = true
        end

      end
      
      if gem_updates
        if push_changes
          branch = get_branch
          run("git add broker/Gemfile.lock; git commit -m 'Updating gem versions'; git push origin #{branch}", :verbose => options.verbose?)
          inside('../crankcase') do
            branch = get_branch
            run("git add stickshift/node/Gemfile.lock stickshift/broker/Gemfile.lock; git commit -m 'Updating gem versions'; git push origin #{branch}", :verbose => options.verbose?)
          end
          build_dirs = get_build_dirs
        end
      end
      build_dirs
    end
  end

  desc "check", "Check the directories that need to be released"
  def check
    branch = get_branch
    orig_branches = checkout_branch(branch)
    begin
      git_pull
      build_dir_list = get_build_dirs.map do |build_info|
        build_info[1]
      end
      puts "Changes detected in the following directories: #{build_dir_list.pretty_inspect}"
    ensure
      reset_orig_branches(orig_branches)
    end
  end
  
  desc "update_gem_versions", "Update the gem versions for gems going to be released"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  method_option :push_changes, :type => :boolean, :desc => "Push the changes to the current branch"
  def update_gem_versions
    get_updated_build_dirs(options.verbose?, options.push_changes?)
  end
  
  desc "release_jenkins_plugin", "Brew build the jenkins plugin"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def release_jenkins_plugin(commit_message, committer_name="Dan McPherson", committer_email="dmcphers@redhat.com")
    if File.exists?("../jenkins-cloud-plugin")
      inside("../jenkins-cloud-plugin") do
        run("git pull", :verbose => options.verbose?)
        exit unless run("mvn package -DskipTests", :verbose => options.verbose?)
      end
      inside("..") do
        FileUtils.rm_rf "jenkins-plugin-openshift/"
        exit unless run("rhpkg clone -b libra-rhel-6.3 jenkins-plugin-openshift", :verbose => options.verbose?)
      end
      inside("../jenkins-plugin-openshift/") do
        FileUtils.cp "../jenkins-cloud-plugin/target/openshift.hpi", "./openshift.hpi"
        version = /^(Version: )(.*)/.match(File.read("jenkins-plugin-openshift.spec"))[2].strip
        nv = next_patch_version(version)
        run("sed -i 's/Version:.*#{version}.*/Version: #{nv}/' jenkins-plugin-openshift.spec", :verbose => options.verbose?)
        date = `date +'%a %b %d %Y'`.chomp
        puts "sed -i 's/%changelog.*/%changelog\\n* #{date} #{committer_name} <#{committer_email}> - #{nv}\\n- #{commit_message}/' jenkins-plugin-openshift.spec"
        run("sed -i 's/%changelog.*/%changelog\\n* #{date} #{committer_name} <#{committer_email}> - #{nv}\\n- #{commit_message}/' jenkins-plugin-openshift.spec", :verbose => options.verbose?)
        if run("rhpkg commit -p -m '#{commit_message}'", :verbose => options.verbose?)
          run("rhpkg build", :verbose => options.verbose?)
        end
      end
    else
      puts "Jenkins plugin not found at ../jenkins-cloud-plugin"
    end
  end

  desc "build", "Tag and build new RPMs for any changes"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def build
  
    unless run("if [ -n \"${http_proxy+x}\" ]; then exit 1; fi", :verbose => options.verbose?)
      puts "ERROR - you need to unset http_proxy first"; exit 1
    end

    unless run("klist | grep REDHAT.COM@REDHAT.COM", :verbose => options.verbose?)
      puts "ERROR - you need to kinit first"; exit 1
    end

    branch = get_branch
    orig_branches = checkout_branch(branch, options.verbose?)
    begin

      # Update the repo
      git_pull

      build_dirs = get_updated_build_dirs(options.verbose?, true)
      tag_failures = []

      build_dirs.each do |build_info|
        build_dir = build_info[1]
        working_dir = File.expand_path("../#{build_dir}", File.dirname(__FILE__))
        inside(working_dir) do
          puts "Tagging #{build_dir}"
          # Tag the package
          unless run("tito tag --accept-auto-changelog", :verbose => options.verbose?)
            tag_failures << build_dir
          end
          puts "Done"
        end
      end

      tag_failures.each do |build_dir|
        build_dirs.delete_if { build_info | build_info[1] == build_dir }
      end

      li_repo = {'li' => [FileUtils.pwd]}
      repos = li_repo.merge(SIBLING_REPOS)
      push_failures = ''
      repos.each do |repo_name, repo_dirs|
        repo_dirs.each do |repo_dir|
          if File.exists?(repo_dir)
            inside(repo_dir) do
              puts "Pushing #{repo_dir}"
              branch = get_branch
              push_cmd = "git fetch --tags && git pull && git push origin #{branch} && git push --tags"
              unless run(push_cmd, :verbose => options.verbose?)
                push_failures += "pushd #{repo_dir} > /dev/null; #{push_cmd}; popd > /dev/null;\n"
              end
            end
            break
          end
        end
      end

      run("echo -e 'y\nn' > #{options.temp_dir}/answerfile", :verbose => options.verbose?)
      tito_cmd = "tito release brew < #{options.temp_dir}/answerfile"
      build_failures = ''
      build_dirs.each do |build_info|
        build_dir = build_info[1]
        working_dir = File.expand_path("../#{build_dir}", File.dirname(__FILE__))
        inside(working_dir) do
          if push_failures.empty?
            puts "Releasing #{build_dir}"

            # Detect which tito command is available
            `tito release --help`
            cmd_exit = $?.exitstatus
            raise "Your version of tito is no longer supported after the Brew migration to git" if cmd_exit != 0
          end

          # Build the RPM in brew
          if push_failures.empty? && run(tito_cmd, :verbose => options.verbose?)
            puts "Done"
          else
            build_failures += "pushd #{working_dir} > /dev/null; #{tito_cmd}; popd > /dev/null;\n"
          end
        end
      end
      if !tag_failures.empty?
        puts "************BEGIN TAG FAILURES****************"
        puts "Note: Packages that failed to tag should continue to show up in build/release check"
        puts tag_failures.pretty_inspect
        puts "*************END TAG FAILURES*****************\n"
      end
      if !push_failures.empty?
        puts "************BEGIN PUSH FAILURES****************"
        puts push_failures
        puts "*************END PUSH FAILURES*****************\n"
      end
      if !build_failures.empty?
        puts "************BEGIN BUILD FAILURES****************"
        puts build_failures
        puts "*************END BUILD FAILURES*****************\n"
      end
    ensure
      reset_orig_branches(orig_branches, options.verbose?)
    end
    
    if File.exists?("../jenkins-cloud-plugin")
      inside("../jenkins-cloud-plugin") do
        git_pull_output = `git pull`.chomp
        unless git_pull_output.include?("Already up-to-date.")
          puts ""
          puts "#########################################"
          puts "INFO: There is a change to the jenkins plugin.  You can release it with 'build/release release_jenkins_plugin'"
          puts "#########################################"
          puts ""
        end
      end
    end
  end

  desc "sync", "Download a build from Brew (using Mash) and sync it to the OpenShift repos"
  method_option :stage, :type => :string, :desc => "Comma-delimited list of packages to sync.  Exclude NVR for latest versions.  (e.g. --stage='rhc, rhc-site-0.73.3-1')"
  method_option :stage_all, :type => :boolean, :desc => "Tag all the latest packages for stage"
  method_option :clean_ami, :type => :boolean, :desc => "Indicates whether to build a clean ami"
  method_option :no_ami, :type => :boolean, :desc => "Indicates whether to not build an ami"
  method_option :source_ami, :type => :boolean, :desc => "Indicates whether to build a source ami"
  def sync
    orig_branches = checkout_branch(options[:stage] || options.stage? ? "stage" : "master")
    begin
      # do RHEL 6.x first
      rhc_devenv_found = mash_and_rsync "libra-rhel-6.3", false, options

      unless options.no_ami?
        create_ami(options, rhc_devenv_found)
      end
    ensure
      reset_orig_branches(orig_branches)
    end
  end
  
  desc "tag_pkgs_stg AFTER_DATE", "Tag packages that are from external sources into the stage repo since AFTER_DATE"
  method_option :check, :type => :boolean, :desc => "Don't do anything yet, just show what would be done"
  method_option :include_internal, :type => :boolean, :desc => "Boolean indicating whether to include internal packages"
  def tag_pkgs_stg(after_date)
    stg_brew_tag = "libra-rhel-6.3-stage"
    cand_brew_tag = "libra-rhel-6.3-candidate"
    orig_branches = checkout_branch("master")
    git_pull

    if after_date.nil? or after_date.empty?
      puts "ERROR: No date paramter passed!"
      puts "Example: build/release tag_external_pkgs_stg 1970-01-30 [--check]"
      exit 1
    else
      external_pkgs_tag_stg = get_packages_to_tag(cand_brew_tag, stg_brew_tag, after_date, options.include_internal?)
    end

    if options.check?
      puts "### If this were run without --check, the following packages would be tagged into #{stg_brew_tag}:"
      external_pkgs_tag_stg.each { |pkg| puts pkg }
    else
      puts "### Tagging the following packages into #{stg_brew_tag}:"
      external_pkgs_tag_stg.each do |pkg| 
        puts pkg 
        `brew tag-pkg #{stg_brew_tag} #{pkg}`
      end
    end

    reset_orig_branches(orig_branches)
  end

  desc "bump_minor_versions", "Bump the minor version in all specs > .1 patch level"
  method_option :push_changes, :type => :boolean, :desc => "Push the changes to the current branch"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def bump_minor_versions
    orig_branches = checkout_branch("master", options.verbose?)
    begin
      all_packages = get_packages
      IGNORE_PACKAGES.each do |package|
        all_packages.delete(package)
      end
      all_packages.each do |package_name, pkg|
        build_dir = pkg[0]
        spec_file = pkg[1]
        version = get_version(spec_file)
        new_version = next_minor_version(version)
        if new_version
          run("/bin/sed -i 's,^Version:.*,Version: #{new_version},' #{spec_file}", :verbose => options.verbose?)
        end
        
      end
      if options.push_changes?
        run("git add *.spec; git commit -m 'bumping spec versions'; git push origin master", :verbose => options.verbose?)
        SIBLING_REPOS.each do |repo_name, repo_dirs|
          repo_dirs.each do |repo_dir|
            if File.exists?(repo_dir)
              inside(repo_dir) do
                run("git add *.spec; git commit -m 'bumping spec versions'; git push origin master", :verbose => options.verbose?)
              end
              break
            end
          end
        end
      end
    ensure
      reset_orig_branches(orig_branches)
    end
  end

  desc "build_ami", "Build an ami based on the current li repo"
  method_option :stage, :type => :boolean, :desc => "Indicates whether to use the stage repo"
  method_option :clean_ami, :type => :boolean, :desc => "Indicates whether to build a clean ami"
  method_option :source_ami, :type => :boolean, :desc => "Indicates whether to build a source ami"
  def build_ami
    create_ami options
  end

  # sync impl methods
  no_tasks do
    def checkout_branch(branch="master", verbose=false)
      puts "#######################"
      puts "Operating on branch: #{branch}"
      puts "#######################"
      orig_branch = get_branch
      orig_branches = {}
      begin
        if orig_branch != branch
          orig_branches[FileUtils.pwd] = orig_branch
          unless run("git checkout #{branch}", :verbose => verbose)
            puts "Unable to checkout branch '#{branch}' for repo 'li'"
            exit 1
          end
        end
        SIBLING_REPOS.each do |repo_name, repo_dirs|
          repo_dirs.each do |repo_dir|
            if File.exists?(repo_dir)
              inside(repo_dir) do
                orig_branch = get_branch
                if orig_branch != branch
                  orig_branches[repo_dir] = orig_branch
                  unless run("git checkout #{branch}", :verbose => verbose)
                    puts "Unable to checkout branch '#{branch}' for repo '#{repo_name}'"
                    exit 1
                  end
                end
              end
              break
            end
          end
        end
      rescue Exception => e
        reset_orig_branches(orig_branches, verbose)
        raise
      end
      orig_branches
    end
    
    def reset_orig_branches(orig_branches, verbose=false)
      orig_branches.each do |repo_dir, branch|
        inside(repo_dir) do
          run("git checkout #{branch}", :verbose => verbose)
        end
      end
    end
    
    
    def mash_and_rsync(tag_base, skip_gem, options)
      # Mash / RSync parameters
      mash_config = (options[:stage] || options.stage_all?) ? "#{tag_base}-stage" : "#{tag_base}-candidate"
      repo_host = "mirror1.ops.rhcloud.com"
      repo_dir = "/export/gpxe/trees"
      repo = "#{repo_host}:#{repo_dir}"
      rsync = nil
      if options[:stage] || options.stage_all?
        rsync = "rsync -aHv --progress --no-p --no-g --omit-dir-times --chmod=Dug=rwX"
      else
        rsync = "rsync -aHv --delete-after --progress --no-p --no-g --omit-dir-times --chmod=Dug=rwX"
      end

      # variable to keep track of if we've built a new rhc-devenv
      rhc_devenv_found = false
  
      # derive pkg_suffix from tag_base
      if tag_base =~ /^.*rhel-(\d)\.(\d)$/
        pkg_suffix = "el#{$1}_#{$2}"
      else
        pkg_suffix = "el6_2"
      end
  
      # Check the Brew installation
      `brew --help`
      unless $? == 0
        puts "ERROR - Brew not installed.  Read misc/docs/BREW for setup steps"
        exit 2
      end
  
      # Check the mash installation
      unless File.exists?("/etc/mash/#{mash_config}.mash")
        puts "ERROR - Mash configuration missing.  Read misc/docs/BREW for setup steps"
        exit 2
      end
  
      # Make sure we have write access to /var/cache/mash
      begin
        File.new("/var/cache/mash/.rhcignore", "w")
        File.delete("/var/cache/mash/.rhcignore")
      rescue Errno::EACCES
        puts "ERROR - user doesn't have write access to /var/cache/mash - mash needs write access to this directory"
        exit 2
      end
  
      # See if we are doing a stage sync - if so, tag the packages listed
      if (options[:stage] and !options[:stage].empty?) or options.stage_all?

        all_packages = get_packages
        nvr_regex = /(.*)-(\d+)\.(\d+)\.(\d+)-?(\d)?/

        packages = nil
        if options[:stage]
          packages = options[:stage].split(",").map do |package|
            package.strip!
            pkg = package
            if nvr_regex.match(package)
              pkg = $1
            end
            unless all_packages[pkg]
              puts "Couldn't find '#{pkg}' on local system.  You probably don't have one of these repos #{SIBLING_REPOS}"
              exit 1
            end
            package
          end
        else
          packages = all_packages.keys
          packages -= IGNORE_PACKAGES
        end
        
        packages.each do |package|
          # Check for the supplied NVR value (e.g. 0.45.1)
          if nvr_regex.match(package)
            pkg = $1 
            # Confirm the package is valid
            nvr_package = nil
            build_info = all_packages[pkg]
            build_dir = build_info[0]
            inside(build_dir) do
              nvr_package = `git tag | grep ^#{package} | tail -n1`.chomp
            end
  
            unless nvr_package.empty?
              package = nvr_package
            else
              puts "ERROR - invalid package supplied #{package}"
              exit 1
            end
          else
            # No NVR was specified - lookup the latest
            tags = []
            build_info = all_packages[package]
            build_dir = build_info[0]
            inside(build_dir) do
              tags = `git tag | grep ^#{package}-[0-9]`.chomp.split("\n")
            end
  
            # Sort the tags by NVR and take the last entry
            package = tags.sort_by {|tag| nvr_regex.match(tag); $1 ? [$1, $2.to_i, $3.to_i, $4.to_i, $5.to_i] : []}[-1]
          end
  
          puts "Tagging package #{package}..."
          puts `brew tag-pkg #{mash_config} #{package}.#{pkg_suffix}`
        end
      end
  
      # Run mash twice since it usually fails the first time
      puts "Running mash sync"
      mash_cmd = "/usr/bin/mash -o #{options.temp_dir}/#{mash_config} -c /etc/mash/li-mash.conf #{mash_config}"
      puts mash_cmd
      run(mash_cmd, :verbose => options.verbose?)
      unless run(mash_cmd, :verbose => options.verbose?)
        puts "ERROR - mash sync failed"
        exit 1
      end

      unless skip_gem
        # Build the gem locally since it's not stored centrally like RPMs in Brew
        puts "Building client gem..."
        if File.exists?('../rhc')
          inside(File.expand_path(File.dirname(File.expand_path(__FILE__)) + "/../../rhc")) do
            unless run('./build.sh', :verbose => options.verbose?)
              puts "ERROR - client gem building failed"
              exit 1
            end
          end
          puts "Done"
        else
          puts "Couldn't find ../rhc.  Skipping build client gem step."
        end

      end

      puts "Syncing RPMs to repo..."
      #
      # Ugly bash hack to set the value of ruby's $? as well as get output to 
      # terminal while rsync runs.
      rsync_output = `_f() { #{rsync} #{options.temp_dir}/#{mash_config}/#{mash_config}/* #{repo}/#{mash_config}/ | tee /dev/tty; return ${PIPESTATUS[0]}; }; _f`
      if $? != 0
        puts "ERROR - RPM sync failed"
        exit 1
      end
      
      rhc_devenv_found = rsync_output.include?('rhc-devenv')
      
      ### FIXME - Comment this out until new patch is verified, then remove
      #unless run("#{rsync} #{options.temp_dir}/#{mash_config}/#{mash_config}/* #{repo}/#{mash_config}/", :verbose => options.verbose?)
      #  puts "ERROR - RPM sync failed."
      #  exit 1
      #end
      
      unless skip_gem
        # sync rhc gem
        puts "Syncing client gem to repo..."
        if File.exists?('../rhc')
          unless run("#{rsync} ../rhc/pkg/*.gem #{repo}/#{mash_config}/client/gems/", :verbose => options.verbose?)
            puts "ERROR - Gem sync failed."
            exit 1
          end
          puts "Done"
        else
          puts "Couldn't find ../rhc.  Skipping rsync client gem step."
        end
      end
  
      unless skip_gem
        puts "Updating gem indexes..."
        unless run("ssh #{repo_host} 'gem generate_index -d #{repo_dir}/#{mash_config}/client'", :verbose => options.verbose?)
          puts "ERROR - Gem index update failed."
          exit 1
        end
        puts "Done"
      end
      rhc_devenv_found
    end
  
    def create_ami(options, devenv_update=false)
      # Jenkins parameters
      proxy = "squid.corp.redhat.com:8080"
      jenkins = "https://ci.dev.openshift.redhat.com/jenkins"
      token = "libra1"
      
      clean_ami = (options.clean_ami? || devenv_update)
  
      puts "Kicking off AMI build..."
      if options.stage?
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/libra_ami_stage/buildWithParameters?token=#{token}\\&BUILD_CLEAN_AMI=#{clean_ami.to_s}\\&BUILD_UPDATE_AMI=#{(!clean_ami).to_s}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
      else
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/libra_ami/buildWithParameters?token=#{token}\\&BUILD_CLEAN_AMI=#{clean_ami.to_s}\\&BUILD_UPDATE_AMI=#{(!clean_ami && !options.source_ami?).to_s}\\&INSTALL_FROM_SOURCE=#{(options.source_ami?).to_s}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
      end
      puts "Done"
    end
  end
end

Release.start
