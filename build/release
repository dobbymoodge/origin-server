#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))

require 'rubygems'
require 'thor'
require 'fileutils'
require 'dev_tools_constants'
require File.join('lib', '..', '..', '..', "#{DEV_TOOLS_REPO}", 'build', 'lib', 'openshift')
require 'lib/openshift/brew'

class Release < Thor
  include Thor::Actions
  include OpenShift::Tito
  include OpenShift::Brew

  method_option :temp_dir, :type => :string, :default => '/tmp', :desc => "A location to write temporary files to"
  def initialize(*args)
    super(*args)
  end
  
  no_tasks do
    def git_pull
      SIBLING_REPOS.each do |repo_name, repo_dirs|
        repo_dirs.each do |repo_dir|
          if File.exists?(repo_dir)
            inside(repo_dir) do
              run("git pull", :verbose => options.verbose?)
            end
            break
          end
        end
      end
    end
    

    def fail_if_uncommitted_changes
      SIBLING_REPOS.each do |repo_name, repo_dirs| 
        repo_dirs.each do |repo_dir| 
          if File.exists?(repo_dir) 
            inside(repo_dir) do 
              raise "You have uncommited changes in #{repo_dir}, cannot bump versions" unless run('git diff --quiet')
            end
          end
        end
      end
    end
  end

  desc "check", "Check the directories that need to be released"
  def check
    branch = get_branch
    orig_branches = checkout_branch(branch)
    begin
      git_pull
      build_dir_list = get_build_dirs.map do |build_info|
        build_info[1]
      end
      puts "Changes detected in the following directories: #{build_dir_list.pretty_inspect}"
    ensure
      reset_orig_branches(orig_branches)
    end
  end
  
  desc "release_jenkins_plugin COMMIT_MESSAGE COMMITTER_NAME COMMITTER_EMAIL", "Brew build the jenkins plugin"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def release_jenkins_plugin(commit_message, committer_name="Dan McPherson", committer_email="dmcphers@redhat.com")
    if File.exists?("../jenkins-cloud-plugin")
      inside("../jenkins-cloud-plugin") do
        run("git pull", :verbose => options.verbose?)
        exit unless run("mvn package -DskipTests", :verbose => options.verbose?)
      end
      inside("..") do
        FileUtils.rm_rf "jenkins-plugin-openshift/"
        exit unless run("rhpkg clone -b #{BASE_RELEASE_BRANCH} jenkins-plugin-openshift", :verbose => options.verbose?)
      end
      inside("../jenkins-plugin-openshift/") do
        FileUtils.cp "../jenkins-cloud-plugin/target/openshift.hpi", "./openshift.hpi"
        version = /^(Version: )(.*)/.match(File.read("jenkins-plugin-openshift.spec"))[2].strip
        nv = next_patch_version(version)
        run("sed -i 's/Version:.*#{version}.*/Version: #{nv}/' jenkins-plugin-openshift.spec", :verbose => options.verbose?)
        date = `date +'%a %b %d %Y'`.chomp
        puts "sed -i 's/%changelog.*/%changelog\\n* #{date} #{committer_name} <#{committer_email}> - #{nv}\\n- #{commit_message}/' jenkins-plugin-openshift.spec"
        run("sed -i 's/%changelog.*/%changelog\\n* #{date} #{committer_name} <#{committer_email}> - #{nv}\\n- #{commit_message}/' jenkins-plugin-openshift.spec", :verbose => options.verbose?)
        if run("rhpkg commit -p -m '#{commit_message}'", :verbose => options.verbose?)
          run("rhpkg build", :verbose => options.verbose?)
        end
      end
    else
      puts "Jenkins plugin not found at ../jenkins-cloud-plugin"
    end
  end

  desc "build", "Tag and build new RPMs for any changes"
  method_option :release_package, :type => :string, :desc => "name of package to release", :default => ""
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def build

    unless run("if [ -n \"${http_proxy+x}\" ]; then exit 1; fi", :verbose => options.verbose?)
      puts "ERROR - you need to unset http_proxy first"; exit 1
    end

    unless run("klist | grep REDHAT.COM@REDHAT.COM", :verbose => options.verbose?)
      puts "ERROR - you need to kinit first"; exit 1
    end

    unless run("rpmdev-bumpspec --version", :verbose => options.verbose?)
      puts "ERROR - you need the rpmdevtools package installed"; exit 1
    end

    branch = get_branch
    orig_branches = checkout_branch(branch, options.verbose?)
    begin
      fail_if_uncommitted_changes
      
      build_dirs = []

      # Update the repo
      git_pull
    
      unless options.release_package.empty?
        found_single_release = false
        
        packages = get_packages
        packages.each do | pkg_name, build_info |
          if pkg_name == options.release_package
            found_single_release = true
            build_dirs = [ [pkg_name, build_info[0], build_info[1]] ]
            break
          end
        end

        unless found_single_release 
          puts "ERROR: package #{options.release_package} not a valid build target"
          exit 1
        end
      else
        build_dirs = get_build_dirs
      end
  
      tag_failures = []
      requires_rebuild = []

      build_dirs.each do |build_info|
        build_dir = build_info[1]
        working_dir = File.expand_path("../#{build_dir}", File.dirname(__FILE__))
        inside(working_dir) do
          puts "Tagging #{build_dir}"

          # packages without versioning steps
          unless run('tito tag --accept-auto-changelog')
            tag_failures << build_dir
          end

          puts "Done"
        end
      end

      (tag_failures + requires_rebuild).each do |build_dir|
        build_dirs.delete_if { | build_info | build_info[1] == build_dir }
      end

      push_failures = ''
      SIBLING_REPOS.each do |repo_name, repo_dirs|
        repo_dirs.each do |repo_dir|
          if File.exists?(repo_dir)
            inside(repo_dir) do
              puts "Pushing #{repo_dir}"
              branch = get_branch
              push_cmd = "git fetch --tags && git pull && git push origin #{branch} && git push --tags"
              unless run(push_cmd, :verbose => options.verbose?)
                push_failures += "pushd #{repo_dir} > /dev/null; #{push_cmd}; popd > /dev/null;\n"
              end
            end
            break
          end
        end
      end

      run("echo -e 'y\nn' > #{options.temp_dir}/answerfile", :verbose => options.verbose?)
          

      build_failures = ''
      chain_build_failures = ''
      chain_sets_need_build = []
      
      # I hate to traverse this more times but this information is needed in
      # advance of the tito commands so we can bump specs of all members of a 
      # chain set
      build_dirs.each do |build_info|
        if CHAIN_BUILD_INITIATORS.include?(build_info[0])

          CHAIN_BUILD_SETS.each do |chain_set|
            if chain_set.include?(build_info[0])
              chain_sets_need_build << chain_set
            end
          end
        end
      end


      build_dirs.each do |build_info|
        build_dir = build_info[1]
        working_dir = File.expand_path("../#{build_dir}", File.dirname(__FILE__))
        inside(working_dir) do
          if push_failures.empty?
            puts "Releasing #{build_dir}"

            # Detect which tito command is available
            `tito release --help`
            cmd_exit = $?.exitstatus
            raise "Your version of tito is no longer supported after the Brew migration to git" if cmd_exit != 0
          end

          # Chain builds are special, will handle their tito release elsewhere
          unless chain_sets_need_build.flatten.uniq.include?(build_info[0])
            
            # Need to handle the case where packages that are normally in a
            # chain build (but are not because the chain_build_iniator was not
            # found to need building) land in the -dirty brew build target so 
            # they are built against the correct set of dependencies instead of
            # last PROD package set
            if CHAIN_BUILD_SETS.flatten.uniq.include?(build_info[0])
              if GEM_SOURCE0_PACKAGES.include?(build_info[0])
                tito_cmd = "tito release brew-gem-dirty < #{options.temp_dir}/answerfile"
              else
                tito_cmd = "tito release brew-dirty < #{options.temp_dir}/answerfile"
              end
            else
              if GEM_SOURCE0_PACKAGES.include?(build_info[0])
                tito_cmd = "tito release brew-gem < #{options.temp_dir}/answerfile"
              else
                tito_cmd = "tito release brew < #{options.temp_dir}/answerfile"
              end

            end

            # Build the RPM in brew
            if push_failures.empty? && run(tito_cmd, :verbose => options.verbose?)
              puts "Done"
            else
              build_failures += "pushd #{working_dir} > /dev/null; #{tito_cmd}; popd > /dev/null;\n"
            end
          end
        end
      end

      unless chain_sets_need_build.empty?
        # Hate traversing this *again* but unsure if there's a more clean 
        # solution ... comments/patches welcome.
        full_pkg_set = get_packages()
        
        chain_set_failures = []

        # --no-build option requires tito v0.4.9-2 or higher, needed for chainbuilds
        tito_cmd = "tito release brew --no-build < #{options.temp_dir}/answerfile"
       
        chain_sets_need_build.uniq.each do | chain_set | 
          puts "Brew chainbuilding for: #{chain_set.join(" : ")}"
            
          chain_set.each do | pkg |
            working_dir = File.expand_path("../#{full_pkg_set[pkg][0]}", File.dirname(__FILE__))
            inside(working_dir) do
              if push_failures.empty? && run(tito_cmd, :verbose => options.verbose?)
                puts "Done"
              else
                build_failures += "pushd #{working_dir} > /dev/null; #{tito_cmd}; popd > /dev/null;\n"
                chain_set_failures << chain_set
              end
            end
          end

          chain_scm_urls = []

          unless chain_set_failures.include? chain_set
            chain_set.each do | pkg |
              head_commit_id = `git ls-remote \
                                git://pkgs.devel.redhat.com/rpms/#{pkg} \
                                refs/heads/libra-rhel-6`.split()[0]
              
              if $?.exitstatus != 0
                chain_build_failures += "Chainset failed: #{chain_set.join(" : ")} ::\n"
                chain_build_failures += "## git ls-remote failed for #{pkg} ::\n"
                chain_build_failures += "## git ls-remote git://pkgs.devel.redhat.com/rpms/#{pkg} refs/heads/libra-rhel-6\n" 

                chain_scm_urls.clear
                break
              end

              chain_scm_urls << "git://pkgs.devel.redhat.com/rpms/#{pkg}?##{head_commit_id}"
            end
          end

          chain_set_failures.each do | failed_set |
            
            chain_build_failures += "#### Chainset failed: #{failed_set.join(" : ")}::\n"
            chain_build_failures += "#### To fix, run the following commands in order, verifying each:\n"
            chain_build_failures += "#### one passes before moving to the next\n"
            failed_set.each do | pkg |
              working_dir = File.expand_path("../#{full_pkg_set[pkg][0]}", File.dirname(__FILE__))
              chain_build_failures += "# pushd #{working_dir} > /dev/null; #{tito_cmd}; popd > /dev/null;\n"
            end
            chain_build_failures += "# for i in #{failed_set.join(" ")} ; do scm+=\"\$(printf \"%s \" \"\$(printf \"%s : \" \"git://pkgs.devel.redhat.com/rpms/$i/?#\$(git ls-remote git://pkgs.devel.redhat.com/rpms/$i refs/heads/libra-rhel-6 | awk '{print $1}')\")\")\"; done;\n"
            chain_build_failures += "# brew chain-build --nowait libra-rhel-6-dirty $\{scm%:*\}\n"

          end

          unless chain_scm_urls.empty?
            cmd = "brew chain-build --nowait libra-rhel-6-dirty #{chain_scm_urls.join(" : ")}"
            if push_failures.empty? && run(cmd, :verbose => options.verbose?)
              puts "Done"
            else
              chain_build_failures += "#{cmd}\n" if ($?.exitstatus != 0) 
            end
          end
        end
      end

      unless requires_rebuild.empty?
        puts "************BEGIN REQUIRES REBUILD****************"
        puts "Note: These packages will need to be force built by hand."
        puts requires_rebuild.pretty_inspect
        puts "*************END REQUIRES REBUILD*****************\n"
      end
      unless tag_failures.empty?
        puts "************BEGIN TAG FAILURES****************"
        puts "Note: Packages that failed to tag should continue to show up in build/release check.  Since tito failed there may be uncommited changes in your repo.  Clear these by running 'git reset HEAD --hard' from each repo."
        puts tag_failures.pretty_inspect
        puts "*************END TAG FAILURES*****************\n"
      end
      unless push_failures.empty?
        puts "************BEGIN PUSH FAILURES****************"
        puts push_failures
        puts "*************END PUSH FAILURES*****************\n"
      end
      unless build_failures.empty?
        puts "************BEGIN BUILD FAILURES****************"
        puts build_failures
        puts "*************END BUILD FAILURES*****************\n"
      end
      unless chain_build_failures.empty?
        puts "************BEGIN CHAIN BUILD FAILURES****************"
        puts chain_build_failures
        puts "*************END CHAIN BUILD FAILURES*****************\n"
      end

    ensure
      reset_orig_branches(orig_branches, options.verbose?)
    end
    
    if File.exists?("../jenkins-cloud-plugin")
      inside("../jenkins-cloud-plugin") do
        git_pull_output = `git pull`.chomp
        unless git_pull_output.include?("Already up-to-date.")
          puts ""
          puts "#########################################"
          puts "INFO: There is a change to the jenkins plugin.  You can release it with 'build/release release_jenkins_plugin'"
          puts "#########################################"
          puts ""
        end
      end
    end
  end

  desc "sync", "Download a build from Brew (using Mash) and sync it to the OpenShift repos"
  method_option :stage, :type => :boolean, :desc => "Sync the stage repo"
  method_option :test, :type => :boolean, :desc => "Run against libra's -test repo"
  method_option :no_ami, :type => :boolean, :desc => "Indicates whether to not build an ami"
  method_option :source_ami, :type => :boolean, :desc => "Indicates whether to build a source ami"
  def sync
    orig_branches = checkout_branch(options.stage? ? "stage" : "master")
    begin
      # do RHEL 6.x first
      mash_and_rsync BASE_RELEASE_BRANCH, false, options

      unless options.no_ami?
        create_ami(options)
      end
    ensure
      reset_orig_branches(orig_branches)
    end
  end
  
  desc "tag_pkgs [AFTER_DATE]", "Tag packages into the candidate or stage repo, specify AFTER_DATE(YYYY-MM-DD) optionally" 
  method_option :include_internal, :type => :boolean, :desc => "Boolean indicating whether to include internal packages"
  method_option :check, :type => :boolean, :desc => "Don't do anything yet, just show what would be done"
  method_option :stage, :type => :boolean, :desc => "Target brew tag is stage"
  method_option :candidate, :type => :boolean, :desc => "Target brew tag is candidate"
  method_option :from, :type => :string, :desc => "Source brew tag (test, cadidate, stage)"
  method_option :to, :type => :string, :desc => "Target brew tag (test, cadidate, stage)"
  method_option :pkgs, :type => :string, :desc => "Comma separated list of brew pkgs"
  def tag_pkgs(after_date = nil)
    tag_failures = ""
    valid_tags = ["stage","candidate","test"]
    if options.stage?
      target_brew_tag = "#{BASE_RELEASE_BRANCH}-stage"
      src_brew_tag = "#{BASE_RELEASE_BRANCH}-candidate"
    elsif options.candidate?
      target_brew_tag = "#{BASE_RELEASE_BRANCH}-candidate"
      src_brew_tag = "#{BASE_RELEASE_BRANCH}-test"
    elsif not options.to.nil? and not options.from.nil?
      if options.from == options.to
        puts "ERROR: target tag must be different from source tag"
        exit 1
      end

      unless valid_tags.include? options.to and valid_tags.include? options.from
        puts "ERROR: Invalid tag offered as --to or --from:"
        puts "Valid Options: #{valid_tags.join(', ')}"
        exit 1
      end

      if options.pkgs.nil?
        puts "ERROR: must pass --pkgs with --from and --to args"
        exit 1
      end

      src_brew_tag = BASE_RELEASE_BRANCH+"-#{options.from}"
      target_brew_tag = BASE_RELEASE_BRANCH+"-#{options.to}"

    else
      puts "ERROR: must specify target brew tag with --stage or --candidate"
      puts "Optionally (eg.): --from test --to candidate"
      exit 1
    end 

    orig_branches = checkout_branch("master")

    begin
      
      git_pull
      if options.from.nil? and options.to.nil?
        if after_date.nil? 
          # Define a month timeline to trim down the package list to process
          # from brew's output
          after_date = (Time.new - 60*60*24*30).strftime("%Y-%m-%d")
        end

        pkgs_need_tagging = get_packages_to_tag(src_brew_tag, target_brew_tag, after_date, options.include_internal?)

        if options.check?
          puts "### If this were run without --check, the following packages would be tagged into #{target_brew_tag}:"
          pkgs_need_tagging.each { |pkg| puts pkg }
        else
          puts "### Tagging the following packages into #{target_brew_tag}:"
          puts pkgs_need_tagging
          puts "######### BEGIN: Brew Tag Output #########"
          tag_failures += brew_move_pkg(src_brew_tag, target_brew_tag, pkgs_need_tagging.join(" "))
          puts "######### END: Brew Tag Output #########"
        end
      else
        puts "######### BEGIN: Brew Tag Output #########"
        tag_failures += brew_move_pkg(src_brew_tag, target_brew_tag, options.pkgs.gsub(","," "))
        puts "######### END: Brew Tag Output #########"
      end
      
      unless tag_failures.empty?
        puts "************BEGIN TAG FAILURES****************"
        puts tag_failures
        puts "*************END TAG FAILURES*****************\n"
        puts "NOTE: If batch failures occur, rerun a with --check to see which failed."
        puts "NOTE: Also check build/release tag_sanity --all if needed"
      end

    ensure
      reset_orig_branches(orig_branches)
    end
  end

  desc "tag_sanity", "Check the sanity of libra-rhel-6 tag tree"
  method_option :prod, :type => :boolean, :desc => "Run against prod brew tag"
  method_option :stage, :type => :boolean, :desc => "Run against stage brew tag"
  method_option :candidate, :type => :boolean, :desc => "Run against candidate brew tag"
  method_option :all, :type => :boolean, :desc => "Run against all brew tags"
  method_option :clean, :type => :boolean, :desc => "Clean non-sane tags"
  def tag_sanity

    unless options.all or options.prod or options.candidate or options.stage
      puts "ERROR: Must provide --all, --prod, --stage, or --candidate"
      puts "NOTE: If you need to clean tags, use --clean"
      exit 1
    end

    tag_sanity_failures = ""
    cleanable_tags = Array.new
    clean_failures = ""

    # Check for rpmdevtools installation (need rpmdev-vercmp)
    unless run("rpm -q rpmdevtools > /dev/null 2>&1", :verbose => options.verbose?)
      puts "ERROR - you need the rpmdevtools package installed"; exit 1
    end

    # Check the Brew installation
    `brew --help`
    unless $? == 0
      puts "ERROR - Brew not installed.  Read misc/docs/BREW for setup steps"
      exit 2
    end


    # Warn people, this is not a fast process because we're querying brew a *lot*
    puts "Sanity check starting .... "
    puts "NOTE: This can take several minutes"

    if options.prod or options.all
      p_hash = {}
      s_hash = {}

      # Check sanity of stage vs prod (stage is upstream, prod is downstream)
      prod_pkgs = `brew latest-pkg --quiet --all #{BASE_RELEASE_BRANCH} | \
                    awk '{ print $1 }'`.split
      stage_pkgs = `brew latest-pkg --quiet --all #{BASE_RELEASE_BRANCH}-stage | \
                    awk '{ print $1 }'`.split

      prod_pkgs.each do |pkg| 
        p_hash["#{pkg.split('-')[0...-2].join('-')}"] = "#{pkg.split('-')[-2..-1].join('-')}" 
      end  
      stage_pkgs.each do |pkg| 
        s_hash["#{pkg.split('-')[0...-2].join('-')}"] = "#{pkg.split('-')[-2..-1].join('-')}" 
      end  

      puts "Sanity checking #{BASE_RELEASE_BRANCH} - #{prod_pkgs.size} pkgs"
      p_hash.each do |pkg_name, pkg_ver_rel|
        
        us_pkg = "#{pkg_name}-#{s_hash[pkg_name]}"
        ds_pkg = "#{pkg_name}-#{pkg_ver_rel}"
        
        if us_pkg.empty? or us_pkg.nil?
          tag_sanity_failures += "### TAG SANITY FAILURE stage vs. prod\n"
          tag_sanity_failures += "#{ds_pkg} exists in #{BASE_RELEASE_BRANCH} not in #{BASE_RELEASE_BRANCH}-stage"
        else
          # rpmdev-vercmp - Exit status is 0 if the EVR's are equal, 11 if EVR1 is 
          # newer, and 12 if EVR2 is newer.
          `rpmdev-vercmp #{us_pkg} #{ds_pkg} > /dev/null 2>&1`
          if $?.exitstatus == 12
            tag_sanity_failures += "### TAG SANITY FAILURE stage vs. prod\n"
            tag_sanity_failures += "#{BASE_RELEASE_BRANCH} - #{ds_pkg}\n"
            tag_sanity_failures += "#{BASE_RELEASE_BRANCH}-stage - #{us_pkg}\n"
            cleanable_tags.push(["#{BASE_RELEASE_BRANCH}-stage", us_pkg])
          end
        end
      end
    end
    
    if options.stage or options.all
      s_hash = {}
      c_hash = {}

      # Check sanity of candidate vs stage (candidate is upstream, stage is downstream)
      stage_pkgs = `brew latest-pkg --quiet --all #{BASE_RELEASE_BRANCH}-stage | \
                    awk '{ print $1 }'`.split
      candidate_pkgs = `brew latest-pkg --quiet --all \
                  #{BASE_RELEASE_BRANCH}-candidate | awk '{ print $1 }'`.split

      stage_pkgs.each do |pkg| 
        s_hash["#{pkg.split('-')[0...-2].join('-')}"] = "#{pkg.split('-')[-2..-1].join('-')}" 
      end  
      candidate_pkgs.each do |pkg| 
        c_hash["#{pkg.split('-')[0...-2].join('-')}"] = "#{pkg.split('-')[-2..-1].join('-')}" 
      end  

      puts "Sanity checking #{BASE_RELEASE_BRANCH}-stage - #{stage_pkgs.size} pkgs"
      s_hash.each do |pkg_name, pkg_ver_rel|
        
        us_pkg = "#{pkg_name}-#{c_hash[pkg_name]}"
        ds_pkg = "#{pkg_name}-#{pkg_ver_rel}"
        
        if us_pkg.empty? or us_pkg.nil?
          tag_sanity_failures += "### TAG SANITY FAILURE candidate vs. stage\n"
          tag_sanity_failures += "#{ds_pkg} exists in #{BASE_RELEASE_BRANCH}-stage not in #{BASE_RELEASE_BRANCH}-candidate"
        else
          # rpmdev-vercmp - Exit status is 0 if the EVR's are equal, 11 if EVR1 is 
          # newer, and 12 if EVR2 is newer.
          `rpmdev-vercmp #{us_pkg} #{ds_pkg} > /dev/null 2>&1`
          if $?.exitstatus == 12
            tag_sanity_failures += "### TAG SANITY FAILURE candidate vs. stage\n"
            tag_sanity_failures += "#{BASE_RELEASE_BRANCH}-stage - #{ds_pkg}\n"
            tag_sanity_failures += "#{BASE_RELEASE_BRANCH}-candidate - #{us_pkg}\n"
            cleanable_tags.push(["#{BASE_RELEASE_BRANCH}-candidate", us_pkg])
          end
        end
      end
    end


    if options.candidate or options.all
      c_hash = {}
      t_hash = {}

      # Check sanity of test vs candidate (test is upstream, candidate is downstream)
      candidate_pkgs = `brew latest-pkg --quiet --all \
                  #{BASE_RELEASE_BRANCH}-candidate | awk '{ print $1 }'`.split
      test_pkgs = `brew latest-pkg --quiet --all \
                  #{BASE_RELEASE_BRANCH}-test | awk '{ print $1 }'`.split

      candidate_pkgs.each do |pkg| 
        c_hash["#{pkg.split('-')[0...-2].join('-')}"] = "#{pkg.split('-')[-2..-1].join('-')}" 
      end  
      test_pkgs.each do |pkg| 
        t_hash["#{pkg.split('-')[0...-2].join('-')}"] = "#{pkg.split('-')[-2..-1].join('-')}" 
      end  

      puts "Sanity checking #{BASE_RELEASE_BRANCH}-candidate - #{candidate_pkgs.size} pkgs"
      c_hash.each do |p_name, p_ver_rel|
        
        us_pkg = "#{p_name}-#{t_hash[p_name]}"
        ds_pkg = "#{p_name}-#{p_ver_rel}"
        
        if us_pkg.empty? or us_pkg.nil?
          tag_sanity_failures += "### TAG SANITY FAILURE test vs.candidate\n"
          tag_sanity_failures += "#{ds_pkg} exists in #{BASE_RELEASE_BRANCH}-candidate not in #{BASE_RELEASE_BRANCH}-test"
        else
          # rpmdev-vercmp - Exit status is 0 if the EVR's are equal, 11 if EVR1 is 
          # newer, and 12 if EVR2 is newer.
          `rpmdev-vercmp #{us_pkg} #{ds_pkg} > /dev/null 2>&1`
          if $?.exitstatus == 12
            tag_sanity_failures += "### TAG SANITY FAILURE test vs. candidate\n"
            tag_sanity_failures += "#{BASE_RELEASE_BRANCH}-candidate - #{ds_pkg}\n"
            tag_sanity_failures += "#{BASE_RELEASE_BRANCH}-test - #{us_pkg}\n"
            cleanable_tags.push(["#{BASE_RELEASE_BRANCH}-test", us_pkg])
          end
        end
      end
    end

    unless tag_sanity_failures.empty?
      puts "Done - Tag inconsistencies found"
      puts "************BEGIN TAG FAILURES****************"
      puts tag_sanity_failures
      puts "*************END TAG FAILURES*****************\n\n"

      unless options.clean
        puts "***********BEGIN CHECK CLEAN OUTPUT************"
        puts "If this were run with --clean the following would be removed"
        puts "from their listed tags in brew"
        puts "***********************************************"

        cleanable_tags.each do | tag_name, pkg_name |
          puts "#{tag_name} - #{pkg_name}"
        end

        puts "***********END CHECK CLEAN OUTPUT************"
      end
    end
    
    if options.clean
      puts "******************BEGIN CLEAN******************"
      puts "Cleaning non-sane brew tags"
      puts "***********************************************"
      
      cleanable_tags.each do | tag_name, pkg_name |
        pkg_base_name = "#{pkg_name.split('-')[0...-2].join('-')}"
        brew_clean_cmd = "brew untag-pkg --all #{tag_name} #{pkg_base_name}"
        `#{brew_clean_cmd}`
        if $?.exitstatus == 0
          puts "Untagging all #{pkg_base_name} from #{tag_name}"
        else
          clean_failures += "# #{brew_clean_cmd}\n"
        end
      end
      puts "***********END CLEAN************"
    end

    unless clean_failures.empty?
      puts "************BEGIN CLEAN FAILURES****************"
      puts clean_failures
      puts "*************END CLEAN FAILURES*****************\n"
    end

    if tag_sanity_failures.empty?
      puts "Done - Tags are sane."
    end
  end


  desc "bump_minor_versions", "Bump the minor version in all specs > .1 patch level"
  method_option :push_changes, :type => :boolean, :desc => "Push the changes to the current branch"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def bump_minor_versions
    fail_if_uncommitted_changes

    orig_branches = checkout_branch("master", options.verbose?)
    begin
      all_packages = get_packages
      IGNORE_PACKAGES.each do |package|
        all_packages.delete(package)
      end

      all_packages.each do |package_name, pkg|
        build_dir = pkg[0]
        spec_file = pkg[1]
        version = get_version(spec_file)
        new_version = next_minor_version(version)
        if new_version
          run("/bin/sed -i 's,^Version:.*,Version: #{new_version},' #{spec_file}", :verbose => options.verbose?)
        end
      end
      if options.push_changes?
        SIBLING_REPOS.each do |repo_name, repo_dirs|
          repo_dirs.each do |repo_dir|
            if File.exists?(repo_dir)
              inside(repo_dir) do
                run("git add .; git commit -m 'Bumping spec versions'; git push origin master", :verbose => options.verbose?)
              end
              break
            end
          end
        end
      end
    ensure
      reset_orig_branches(orig_branches)
    end
  end

  desc "build_ami", "Build an ami"
  method_option :stage, :type => :boolean, :desc => "Indicates whether to use the stage repo"
  method_option :source_ami, :type => :boolean, :desc => "Indicates whether to build a source ami"
  def build_ami
    create_ami(options)
  end

  # sync impl methods
  no_tasks do
    def checkout_branch(branch="master", verbose=false)
      puts "#######################"
      puts "Operating on branch: #{branch}"
      puts "#######################"
      orig_branches = {}
      begin
        SIBLING_REPOS.each do |repo_name, repo_dirs|
          repo_dirs.each do |repo_dir|
            if File.exists?(repo_dir)
              inside(repo_dir) do
                orig_branch = get_branch
                if orig_branch != branch
                  orig_branches[repo_dir] = orig_branch
                  unless run("git checkout #{branch}", :verbose => verbose)
                    puts "Unable to checkout branch '#{branch}' for repo '#{repo_name}'"
                    exit 1
                  end
                end
              end
              break
            end
          end
        end
      rescue Exception => e
        reset_orig_branches(orig_branches, verbose)
        raise
      end
      orig_branches
    end
    
    def reset_orig_branches(orig_branches, verbose=false)
      orig_branches.each do |repo_dir, branch|
        inside(repo_dir) do
          run("git checkout #{branch}", :verbose => verbose)
        end
      end
    end
    
    
    def mash_and_rsync(tag_base, skip_gem, options)
      # Mash / RSync parameters
      if options.test?
        mash_config = "#{tag_base}-test"
      elsif options.stage? 
        mash_config = "#{tag_base}-stage"  
      else 
        mash_config = "#{tag_base}-candidate"
      end

      repo_host = "mirror1.ops.rhcloud.com"
      repo_dir = "/export/gpxe/trees"
      repo = "#{repo_host}:#{repo_dir}"
      rsync = "rsync -aHv --progress --no-p --no-g --omit-dir-times --chmod=Dug=rwX"

      # variable to keep track of if we've built a new rhc-devenv
      rhc_devenv_found = false
  
      # derive pkg_suffix from tag_base
      if tag_base =~ /^.*rhel-(\d)\.(\d)$/
        pkg_suffix = "el#{$1}_#{$2}"
      else
        pkg_suffix = "el6oso"
      end
  
      # Check the Brew installation
      `brew --help`
      unless $? == 0
        puts "ERROR - Brew not installed.  Read misc/docs/BREW for setup steps"
        exit 2
      end
  
      # Check the mash installation
      unless File.exists?("/etc/mash/#{mash_config}.mash")
        puts "ERROR - Mash configuration missing.  Read misc/docs/BREW for setup steps"
        exit 2
      end
  
      # Make sure we have write access to /var/cache/mash
      begin
        File.new("/var/cache/mash/.rhcignore", "w")
        File.delete("/var/cache/mash/.rhcignore")
      rescue Errno::EACCES
        puts "ERROR - user doesn't have write access to /var/cache/mash - mash needs write access to this directory"
        exit 2
      end
  
      # Run mash twice since it usually fails the first time
      puts "Running mash sync"
      mash_cmd = "/usr/bin/mash -o #{options.temp_dir}/#{mash_config} -c /etc/mash/li-mash.conf #{mash_config}"
      puts mash_cmd
      run(mash_cmd, :verbose => options.verbose?)
      unless run(mash_cmd, :verbose => options.verbose?)
        puts "ERROR - mash sync failed"
        exit 1
      end

      # Change the directory group permissions so others on the machine can do things.
      puts "Fixing up permissions for the next guy"
      permissions_cmd = "chgrp -R mock #{options.temp_dir}/#{mash_config}/* /var/tmp/mash/mash-#{mash_config}/.createrepo-cache"
      puts permissions_cmd
      run(permissions_cmd, :verbose => options.verbose?)
      unless run(permissions_cmd, :verbose => options.verbose?)
        puts "ERROR - changing permissions failed"
        exit 1
      end

      unless skip_gem
        # Build the gem locally since it's not stored centrally like RPMs in Brew
        puts "Building client gem..."
        if File.exists?('../rhc')
          inside(File.expand_path(File.dirname(File.expand_path(__FILE__)) + "/../../rhc")) do
            unless run('./build.sh', :verbose => options.verbose?)
              puts "ERROR - client gem building failed"
              exit 1
            end
          end
          puts "Done"
        else
          puts "Couldn't find ../rhc.  Skipping build client gem step."
        end

      end

      puts "Syncing RPMs to repo..."
      #
      # Ugly bash hack to set the value of ruby's $? as well as get output to 
      # terminal while rsync runs.
      rsync_output = `_f() { #{rsync} #{options.temp_dir}/#{mash_config}/#{mash_config}/* #{repo}/#{mash_config}/ | tee /dev/tty; return ${PIPESTATUS[0]}; }; _f`
      if $? != 0
        puts "ERROR - RPM sync failed"
        exit 1
      end
      
      rhc_devenv_found = rsync_output.include?('rhc-devenv')
      
      ### FIXME - Comment this out until new patch is verified, then remove
      #unless run("#{rsync} #{options.temp_dir}/#{mash_config}/#{mash_config}/* #{repo}/#{mash_config}/", :verbose => options.verbose?)
      #  puts "ERROR - RPM sync failed."
      #  exit 1
      #end
      
      unless skip_gem
        # sync rhc gem
        puts "Syncing client gem to repo..."
        if File.exists?('../rhc')
          unless run("#{rsync} ../rhc/*.gem #{repo}/#{mash_config}/client/gems/", :verbose => options.verbose?)
            puts "ERROR - Gem sync failed."
            exit 1
          end
          puts "Done"
        else
          puts "Couldn't find ../rhc.  Skipping rsync client gem step."
        end
      end
  
      unless skip_gem
        puts "Updating gem indexes..."
        unless run("ssh #{repo_host} 'gem generate_index -d #{repo_dir}/#{mash_config}/client'", :verbose => options.verbose?)
          puts "ERROR - Gem index update failed."
          exit 1
        end
        puts "Done"
      end
      rhc_devenv_found
    end
  
    def create_ami(options)
      # Jenkins parameters
      proxy = "squid.corp.redhat.com:8080"
      jenkins = "https://ci.dev.openshift.redhat.com/jenkins"
  
      puts "Kicking off AMI build..."
      if options.test?
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/libra_ami_test/buildWithParameters?token=#{JENKINS_BUILD_TOKEN}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
         
      elsif options.stage?
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/create_ami/buildWithParameters?token=#{JENKINS_BUILD_TOKEN}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
      else
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/libra_ami/buildWithParameters?token=#{JENKINS_BUILD_TOKEN}\\&INSTALL_FROM_SOURCE=#{(options.source_ami?).to_s}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
      end
      puts "Done"
    end
  end
end

Release.start
