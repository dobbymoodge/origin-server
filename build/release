#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))

require 'rubygems'
require 'thor'
require 'fileutils'
require 'dev_tools_constants'
require File.join('lib', '..', '..', '..', "#{DEV_TOOLS_REPO}", 'build', 'lib', 'openshift')
require 'lib/openshift/brew'

class Release < Thor
  include Thor::Actions
  include OpenShift::Tito
  include OpenShift::Brew

  method_option :temp_dir, :type => :string, :default => '/tmp', :desc => "A location to write temporary files to"
  def initialize(*args)
    super(*args)
  end
  
  no_tasks do
    def git_pull
      SIBLING_REPOS.each do |repo_name, repo_dirs|
        repo_dirs.each do |repo_dir|
          if File.exists?(repo_dir)
            inside(repo_dir) do
              run("git pull", :verbose => options.verbose?)
            end
            break
          end
        end
      end
    end
    

    def fail_if_uncommitted_changes
      SIBLING_REPOS.each do |repo_name, repo_dirs| 
        repo_dirs.each do |repo_dir| 
          if File.exists?(repo_dir) 
            inside(repo_dir) do 
              raise "You have uncommited changes in #{repo_dir}, cannot bump versions" unless run('git diff --quiet')
            end
          end
        end
      end
    end
  end

  desc "check", "Check the directories that need to be released"
  def check
    branch = get_branch
    orig_branches = checkout_branch(branch)
    begin
      git_pull
      build_dir_list = get_build_dirs.map do |build_info|
        build_info[1]
      end
      puts "Changes detected in the following directories: #{build_dir_list.pretty_inspect}"
    ensure
      reset_orig_branches(orig_branches)
    end
  end
  
  desc "release_jenkins_plugin", "Brew build the jenkins plugin"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def release_jenkins_plugin(commit_message, committer_name="Dan McPherson", committer_email="dmcphers@redhat.com")
    if File.exists?("../jenkins-cloud-plugin")
      inside("../jenkins-cloud-plugin") do
        run("git pull", :verbose => options.verbose?)
        exit unless run("mvn package -DskipTests", :verbose => options.verbose?)
      end
      inside("..") do
        FileUtils.rm_rf "jenkins-plugin-openshift/"
        exit unless run("rhpkg clone -b #{BASE_RELEASE_BRANCH} jenkins-plugin-openshift", :verbose => options.verbose?)
      end
      inside("../jenkins-plugin-openshift/") do
        FileUtils.cp "../jenkins-cloud-plugin/target/openshift.hpi", "./openshift.hpi"
        version = /^(Version: )(.*)/.match(File.read("jenkins-plugin-openshift.spec"))[2].strip
        nv = next_patch_version(version)
        run("sed -i 's/Version:.*#{version}.*/Version: #{nv}/' jenkins-plugin-openshift.spec", :verbose => options.verbose?)
        date = `date +'%a %b %d %Y'`.chomp
        puts "sed -i 's/%changelog.*/%changelog\\n* #{date} #{committer_name} <#{committer_email}> - #{nv}\\n- #{commit_message}/' jenkins-plugin-openshift.spec"
        run("sed -i 's/%changelog.*/%changelog\\n* #{date} #{committer_name} <#{committer_email}> - #{nv}\\n- #{commit_message}/' jenkins-plugin-openshift.spec", :verbose => options.verbose?)
        if run("rhpkg commit -p -m '#{commit_message}'", :verbose => options.verbose?)
          run("rhpkg build", :verbose => options.verbose?)
        end
      end
    else
      puts "Jenkins plugin not found at ../jenkins-cloud-plugin"
    end
  end

  desc "build", "Tag and build new RPMs for any changes"
  method_option :release_package, :type => :string, :desc => "name of package to release", :default => ""
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def build

    unless run("if [ -n \"${http_proxy+x}\" ]; then exit 1; fi", :verbose => options.verbose?)
      puts "ERROR - you need to unset http_proxy first"; exit 1
    end

    unless run("klist | grep REDHAT.COM@REDHAT.COM", :verbose => options.verbose?)
      puts "ERROR - you need to kinit first"; exit 1
    end

    branch = get_branch
    orig_branches = checkout_branch(branch, options.verbose?)
    begin
      fail_if_uncommitted_changes
      
      build_dirs = []

      # Update the repo
      git_pull
    
      unless options.release_package.empty?
        found_single_release = false
        
        packages = get_packages
        packages.each do | pkg_name, build_info |
          if pkg_name == options.release_package
            found_single_release = true
            build_dirs = [ [pkg_name, build_info[0], build_info[1]] ]
            break
          end
        end

        unless found_single_release 
          puts "ERROR: package #{options.release_package} not a valid build target"
          exit 1
        end
      else
        build_dirs = get_build_dirs
      end
  
      tag_failures = []
      requires_rebuild = []

      build_dirs.each do |build_info|
        build_dir = build_info[1]
        working_dir = File.expand_path("../#{build_dir}", File.dirname(__FILE__))
        inside(working_dir) do
          puts "Tagging #{build_dir}"

          # packages without versioning steps
          unless run('tito tag --accept-auto-changelog')
            tag_failures << build_dir
          end

          puts "Done"
        end
      end

      (tag_failures + requires_rebuild).each do |build_dir|
        build_dirs.delete_if { | build_info | build_info[1] == build_dir }
      end

      push_failures = ''
      SIBLING_REPOS.each do |repo_name, repo_dirs|
        repo_dirs.each do |repo_dir|
          if File.exists?(repo_dir)
            inside(repo_dir) do
              puts "Pushing #{repo_dir}"
              branch = get_branch
              push_cmd = "git fetch --tags && git pull && git push origin #{branch} && git push --tags"
              unless run(push_cmd, :verbose => options.verbose?)
                push_failures += "pushd #{repo_dir} > /dev/null; #{push_cmd}; popd > /dev/null;\n"
              end
            end
            break
          end
        end
      end

      run("echo -e 'y\nn' > #{options.temp_dir}/answerfile", :verbose => options.verbose?)
      tito_cmd = "tito release brew < #{options.temp_dir}/answerfile"
      build_failures = ''
      build_dirs.each do |build_info|
        build_dir = build_info[1]
        working_dir = File.expand_path("../#{build_dir}", File.dirname(__FILE__))
        inside(working_dir) do
          if push_failures.empty?
            puts "Releasing #{build_dir}"

            # Detect which tito command is available
            `tito release --help`
            cmd_exit = $?.exitstatus
            raise "Your version of tito is no longer supported after the Brew migration to git" if cmd_exit != 0
          end

          # Build the RPM in brew
          if push_failures.empty? && run(tito_cmd, :verbose => options.verbose?)
            puts "Done"
          else
            build_failures += "pushd #{working_dir} > /dev/null; #{tito_cmd}; popd > /dev/null;\n"
          end
        end
      end

      unless requires_rebuild.empty?
        puts "************BEGIN REQUIRES REBUILD****************"
        puts "Note: These packages will need to be force built by hand."
        puts requires_rebuild.pretty_inspect
        puts "*************END REQUIRES REBUILD*****************\n"
      end
      unless tag_failures.empty?
        puts "************BEGIN TAG FAILURES****************"
        puts "Note: Packages that failed to tag should continue to show up in build/release check.  Since tito failed there may be uncommited changes in your repo.  Clear these by running 'git reset HEAD --hard' from each repo."
        puts tag_failures.pretty_inspect
        puts "*************END TAG FAILURES*****************\n"
      end
      unless push_failures.empty?
        puts "************BEGIN PUSH FAILURES****************"
        puts push_failures
        puts "*************END PUSH FAILURES*****************\n"
      end
      unless build_failures.empty?
        puts "************BEGIN BUILD FAILURES****************"
        puts build_failures
        puts "*************END BUILD FAILURES*****************\n"
      end
    ensure
      reset_orig_branches(orig_branches, options.verbose?)
    end
    
    if File.exists?("../jenkins-cloud-plugin")
      inside("../jenkins-cloud-plugin") do
        git_pull_output = `git pull`.chomp
        unless git_pull_output.include?("Already up-to-date.")
          puts ""
          puts "#########################################"
          puts "INFO: There is a change to the jenkins plugin.  You can release it with 'build/release release_jenkins_plugin'"
          puts "#########################################"
          puts ""
        end
      end
    end
  end

  desc "sync", "Download a build from Brew (using Mash) and sync it to the OpenShift repos"
  method_option :stage, :type => :string, :desc => "Comma-delimited list of packages to sync.  Exclude NVR for latest versions.  (e.g. --stage='rhc, rhc-site-0.73.3-1')"
  method_option :test, :type => :boolean, :desc => "Run against libra's -test repo"
  method_option :stage_all, :type => :boolean, :desc => "Tag all the latest packages for stage"
  method_option :no_ami, :type => :boolean, :desc => "Indicates whether to not build an ami"
  method_option :source_ami, :type => :boolean, :desc => "Indicates whether to build a source ami"
  def sync
    orig_branches = checkout_branch(options[:stage] || options.stage? ? "stage" : "master")
    begin
      # do RHEL 6.x first
      mash_and_rsync BASE_RELEASE_BRANCH, false, options

      unless options.no_ami?
        create_ami(options)
      end
    ensure
      reset_orig_branches(orig_branches)
    end
  end
  
  desc "tag_pkgs [AFTER_DATE]", "Tag packages into the candidate or stage repo, specify AFTER_DATE(YYYY-MM-DD) optionally" 
  method_option :include_internal, :type => :boolean, :desc => "Boolean indicating whether to include internal packages"
  method_option :check, :type => :boolean, :desc => "Don't do anything yet, just show what would be done"
  method_option :stage, :type => :boolean, :desc => "Target brew tag is stage"
  method_option :candidate, :type => :boolean, :desc => "Target brew tag is candidate"
  def tag_pkgs(after_date = nil)
    if options.stage?
      target_brew_tag = "#{BASE_RELEASE_BRANCH}-stage"
      src_brew_tag = "#{BASE_RELEASE_BRANCH}-candidate"
    elsif options.candidate?
      target_brew_tag = "#{BASE_RELEASE_BRANCH}-candidate"
      src_brew_tag = "#{BASE_RELEASE_BRANCH}-test"
    else
      puts "ERROR: must specify target brew tag with --stage or --candidate"
      exit 1
    end 

    orig_branches = checkout_branch("master")

    begin
      
      git_pull
      if after_date.nil? or after_date.empty?
        # Define a month timeline to trim down the package list to process
        # from brew's output
        after_date = (Time.new - 60*60*24*30).strftime("%Y-%m-%d")
      end

      pkgs_need_tagging = get_packages_to_tag(src_brew_tag, target_brew_tag, after_date, options.include_internal?)

      if options.check?
        puts "### If this were run without --check, the following packages would be tagged into #{target_brew_tag}:"
        pkgs_need_tagging.each { |pkg| puts pkg }
      else
        puts "### Tagging the following packages into #{target_brew_tag}:"
        pkgs_need_tagging.each do |pkg| 
          puts pkg 
          `brew tag-pkg #{target_brew_tag} #{pkg}`
        end
      end
    ensure
      reset_orig_branches(orig_branches)
    end
  end

  desc "bump_minor_versions", "Bump the minor version in all specs > .1 patch level"
  method_option :push_changes, :type => :boolean, :desc => "Push the changes to the current branch"
  method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
  def bump_minor_versions
    fail_if_uncommitted_changes

    orig_branches = checkout_branch("master", options.verbose?)
    begin
      all_packages = get_packages
      IGNORE_PACKAGES.each do |package|
        all_packages.delete(package)
      end

      all_packages.each do |package_name, pkg|
        build_dir = pkg[0]
        spec_file = pkg[1]
        version = get_version(spec_file)
        new_version = next_minor_version(version)
        if new_version
          run("/bin/sed -i 's,^Version:.*,Version: #{new_version},' #{spec_file}", :verbose => options.verbose?)
        end
      end
      if options.push_changes?
        SIBLING_REPOS.each do |repo_name, repo_dirs|
          repo_dirs.each do |repo_dir|
            if File.exists?(repo_dir)
              inside(repo_dir) do
                run("git add .; git commit -m 'Bumping spec versions'; git push origin master", :verbose => options.verbose?)
              end
              break
            end
          end
        end
      end
    ensure
      reset_orig_branches(orig_branches)
    end
  end

  desc "build_ami", "Build an ami"
  method_option :stage, :type => :boolean, :desc => "Indicates whether to use the stage repo"
  method_option :source_ami, :type => :boolean, :desc => "Indicates whether to build a source ami"
  def build_ami
    create_ami(options)
  end

  # sync impl methods
  no_tasks do
    def checkout_branch(branch="master", verbose=false)
      puts "#######################"
      puts "Operating on branch: #{branch}"
      puts "#######################"
      orig_branches = {}
      begin
        SIBLING_REPOS.each do |repo_name, repo_dirs|
          repo_dirs.each do |repo_dir|
            if File.exists?(repo_dir)
              inside(repo_dir) do
                orig_branch = get_branch
                if orig_branch != branch
                  orig_branches[repo_dir] = orig_branch
                  unless run("git checkout #{branch}", :verbose => verbose)
                    puts "Unable to checkout branch '#{branch}' for repo '#{repo_name}'"
                    exit 1
                  end
                end
              end
              break
            end
          end
        end
      rescue Exception => e
        reset_orig_branches(orig_branches, verbose)
        raise
      end
      orig_branches
    end
    
    def reset_orig_branches(orig_branches, verbose=false)
      orig_branches.each do |repo_dir, branch|
        inside(repo_dir) do
          run("git checkout #{branch}", :verbose => verbose)
        end
      end
    end
    
    
    def mash_and_rsync(tag_base, skip_gem, options)
      # Mash / RSync parameters
      if options.test?
        mash_config = "#{tag_base}-test"
      elsif options[:stage] || options.stage_all
        mash_config = "#{tag_base}-stage"  
      else 
        mash_config = "#{tag_base}-candidate"
      end

      repo_host = "mirror1.ops.rhcloud.com"
      repo_dir = "/export/gpxe/trees"
      repo = "#{repo_host}:#{repo_dir}"
      rsync = nil
      if options[:stage] || options.stage_all?
        rsync = "rsync -aHv --progress --no-p --no-g --omit-dir-times --chmod=Dug=rwX"
      else
        #rsync = "rsync -aHv --delete-after --progress --no-p --no-g --omit-dir-times --chmod=Dug=rwX"
        rsync = "rsync -aHv --progress --no-p --no-g --omit-dir-times --chmod=Dug=rwX"
      end

      # variable to keep track of if we've built a new rhc-devenv
      rhc_devenv_found = false
  
      # derive pkg_suffix from tag_base
      if tag_base =~ /^.*rhel-(\d)\.(\d)$/
        pkg_suffix = "el#{$1}_#{$2}"
      else
        pkg_suffix = "el6_3"
      end
  
      # Check the Brew installation
      `brew --help`
      unless $? == 0
        puts "ERROR - Brew not installed.  Read misc/docs/BREW for setup steps"
        exit 2
      end
  
      # Check the mash installation
      unless File.exists?("/etc/mash/#{mash_config}.mash")
        puts "ERROR - Mash configuration missing.  Read misc/docs/BREW for setup steps"
        exit 2
      end
  
      # Make sure we have write access to /var/cache/mash
      begin
        File.new("/var/cache/mash/.rhcignore", "w")
        File.delete("/var/cache/mash/.rhcignore")
      rescue Errno::EACCES
        puts "ERROR - user doesn't have write access to /var/cache/mash - mash needs write access to this directory"
        exit 2
      end
  
      # See if we are doing a stage sync - if so, tag the packages listed
      if (options[:stage] and !options[:stage].empty?) or options.stage_all?

        all_packages = get_packages
        nvr_regex = /(.*)-(\d+)\.(\d+)\.(\d+)-?(\d)?/

        packages = nil
        if options[:stage]
          packages = options[:stage].split(",").map do |package|
            package.strip!
            pkg = package
            if nvr_regex.match(package)
              pkg = $1
            end
            unless all_packages[pkg]
              puts "Couldn't find '#{pkg}' on local system.  You probably don't have one of these repos #{SIBLING_REPOS}"
              exit 1
            end
            package
          end
        else
          packages = all_packages.keys
          packages -= IGNORE_PACKAGES
        end
        
        packages.each do |package|
          # Check for the supplied NVR value (e.g. 0.45.1)
          if nvr_regex.match(package)
            pkg = $1 
            # Confirm the package is valid
            nvr_package = nil
            build_info = all_packages[pkg]
            build_dir = build_info[0]
            inside(build_dir) do
              nvr_package = `git tag | grep ^#{package} | tail -n1`.chomp
            end
  
            unless nvr_package.empty?
              package = nvr_package
            else
              puts "ERROR - invalid package supplied #{package}"
              exit 1
            end
          else
            # No NVR was specified - lookup the latest
            tags = []
            build_info = all_packages[package]
            build_dir = build_info[0]
            inside(build_dir) do
              tags = `git tag | grep ^#{package}-[0-9]`.chomp.split("\n")
            end
  
            # Sort the tags by NVR and take the last entry
            package = tags.sort_by {|tag| nvr_regex.match(tag); $1 ? [$1, $2.to_i, $3.to_i, $4.to_i, $5.to_i] : []}[-1]
          end
  
          puts "Tagging package #{package}..."
          puts `brew tag-pkg #{mash_config} #{package}.#{pkg_suffix}`
        end
      end
  
      # Run mash twice since it usually fails the first time
      puts "Running mash sync"
      mash_cmd = "/usr/bin/mash -o #{options.temp_dir}/#{mash_config} -c /etc/mash/li-mash.conf #{mash_config}"
      puts mash_cmd
      run(mash_cmd, :verbose => options.verbose?)
      unless run(mash_cmd, :verbose => options.verbose?)
        puts "ERROR - mash sync failed"
        exit 1
      end

      unless skip_gem
        # Build the gem locally since it's not stored centrally like RPMs in Brew
        puts "Building client gem..."
        if File.exists?('../rhc')
          inside(File.expand_path(File.dirname(File.expand_path(__FILE__)) + "/../../rhc")) do
            unless run('./build.sh', :verbose => options.verbose?)
              puts "ERROR - client gem building failed"
              exit 1
            end
          end
          puts "Done"
        else
          puts "Couldn't find ../rhc.  Skipping build client gem step."
        end

      end

      puts "Syncing RPMs to repo..."
      #
      # Ugly bash hack to set the value of ruby's $? as well as get output to 
      # terminal while rsync runs.
      rsync_output = `_f() { #{rsync} #{options.temp_dir}/#{mash_config}/#{mash_config}/* #{repo}/#{mash_config}/ | tee /dev/tty; return ${PIPESTATUS[0]}; }; _f`
      if $? != 0
        puts "ERROR - RPM sync failed"
        exit 1
      end
      
      rhc_devenv_found = rsync_output.include?('rhc-devenv')
      
      ### FIXME - Comment this out until new patch is verified, then remove
      #unless run("#{rsync} #{options.temp_dir}/#{mash_config}/#{mash_config}/* #{repo}/#{mash_config}/", :verbose => options.verbose?)
      #  puts "ERROR - RPM sync failed."
      #  exit 1
      #end
      
      unless skip_gem
        # sync rhc gem
        puts "Syncing client gem to repo..."
        if File.exists?('../rhc')
          unless run("#{rsync} ../rhc/*.gem #{repo}/#{mash_config}/client/gems/", :verbose => options.verbose?)
            puts "ERROR - Gem sync failed."
            exit 1
          end
          puts "Done"
        else
          puts "Couldn't find ../rhc.  Skipping rsync client gem step."
        end
      end
  
      unless skip_gem
        puts "Updating gem indexes..."
        unless run("ssh #{repo_host} 'gem generate_index -d #{repo_dir}/#{mash_config}/client'", :verbose => options.verbose?)
          puts "ERROR - Gem index update failed."
          exit 1
        end
        puts "Done"
      end
      rhc_devenv_found
    end
  
    def create_ami(options)
      # Jenkins parameters
      proxy = "squid.corp.redhat.com:8080"
      jenkins = "https://ci.dev.openshift.redhat.com/jenkins"
  
      puts "Kicking off AMI build..."
      if options.test?
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/libra_ami_test/buildWithParameters?token=#{JENKINS_BUILD_TOKEN}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
         
      elsif options.stage?
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/create_ami/buildWithParameters?token=#{JENKINS_BUILD_TOKEN}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
      else
        unless run("curl --insecure --proxy #{proxy} #{jenkins}/job/libra_ami/buildWithParameters?token=#{JENKINS_BUILD_TOKEN}\\&INSTALL_FROM_SOURCE=#{(options.source_ami?).to_s}", :verbose => options.verbose?)
          puts "ERROR - Jenkins remote job invocation failed."
          exit 1
        end
      end
      puts "Done"
    end
  end
end

Release.start
