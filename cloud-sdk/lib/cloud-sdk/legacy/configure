#!/bin/bash

# Copyright © 2010 Mike McGrath All rights reserved
# Copyright © 2010 Red Hat, Inc. All rights reserved

# This copyrighted material is made available to anyone wishing to use, modify,
# copy, or redistribute it subject to the terms and conditions of the GNU
# General Public License v.2.  This program is distributed in the hope that it
# will be useful, but WITHOUT ANY WARRANTY expressed or implied, including the
# implied warranties of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.  You should have
# received a copy of the GNU General Public License along with this program;
# if not, write to the Free Software Foundation, Inc., 51 Franklin Street,
# Fifth Floor, Boston, MA 02110-1301, USA. Any Red Hat trademarks that are
# incorporated in the source code or documentation are not subject to the GNU
# General Public License and may only be used or replicated with the express
# permission of Red Hat, Inc.

# Creates a libra user
#
# IN: username
#     SSH RSA public key
#
# 1) create a local user account: username, home directory
# 2) enable login via SSH using RSA key: trap user
# 3) Place limits on user: number of processes

#
#
# default values
#
DEFAULT_LIBRA_DIR=/var/lib/libra
DEFAULT_LIBRA_CONF_DIR=/etc/libra
DEFAULT_LIBRA_SKEL_DIR=${DEFAULT_LIBRA_CONF_DIR}/skel

first_uid=${first_uid:=500}

# defaults
limits_order=84
limits_nproc=100
quota_files=1000
# a block = 1Kbytes: 1k * 1024 * 128
quota_blocks=`expr 1024 \* 128` # 128MB

# Exit on any errors
# set -e

CART_DIR=/usr/libexec/li/cartridges

function load_node_conf {
    if [ -f '/etc/libra/node.conf' ]
    then
        . /etc/libra/node.conf
    elif [ -f 'node.conf' ]
    then
        . node.conf
    else
        echo "node.conf not found.  Cannot continue" 1>&2
        exit 3
    fi
}

function load_resource_limits_conf {
    if [ -f '/etc/libra/resource_limits.conf' ]
    then
        . /etc/libra/resource_limits.conf
    fi
}

#
#  provide usage information
#
function print_help {
    echo "Usage: $0"
    echo "  -c customer_uuid"
    if [ -z "$REVERT" ]
    then
        echo "  -s ssh_pub_key"
        echo "  -d (optional: debug)"
    fi
    exit 1
}

function initialize {
    load_node_conf

    load_resource_limits_conf

    if [ -z "$libra_dir" ]
    then
	      libra_dir=$DEFAULT_LIBRA_DIR
    fi

    SCRIPTNAME=`basename $0`
    if [ $SCRIPTNAME = 'deconfigure' ] ; then
       REVERT='TRUE'
    fi 
}

function parse_options {
    while getopts 'c:e:s:p:o:dnr' OPTION
    do
	case $OPTION in
            c) username=$OPTARG
		;;
            s) ssh_key=$OPTARG
		;;
            p) limits_nproc=$OPTARG
		;;
            o) limits_order=$OPTARG
		;;
            d) set -x
		;;
	          n) NOOP='echo'
		;;
	          r) REVERT="TRUE"	          
		;;
            ?) print_help
		;;
	esac
    done

    # username is always required
    if ( [ -z "$username" ])
    then
	      print_help
    fi

    # ssh_key is only needed for configure, not deconfigure
    if ( [ -z "$REVERT" ] && [ -z "$ssh_key" ])
    then
	      print_help
    fi
}

#
# Generate a user's home directory from their username
#
function homedir {
    USERNAME=$1
    USERHOME=`grep $USERNAME /etc/passwd | cut -d: -f6`

    if [ -n "${USERHOME}" ]
    then
        echo $USERHOME
    else
        # remove duplicate slashes (/) and return the result
	    echo ${libra_dir}/${USERNAME} | tr -s '/'
    fi
}

# Find the filesystem which holds a user's home directory
function home_filesystem {
    df -P ${libra_dir} | tail -1 | cut -d' ' -f1
}


# Find the next available UID/GID pair
function next_uid() {

  # find the lowest number greater than or equal to 500 which is not used
  # either as a UID or GID
  # Line 1: create a set of UID's from /etc/passwd
  # Line 2: create a set of GID's from /etc/group
  # count up from 500 until you find one not used in either
  # and YES $first_uid is a shell variable interpolated into the python in-line
  python -c "pid = set([int(line.split(':')[2]) for line in open('/etc/passwd').readlines()])
gid = set([int(line.split(':')[2]) for line in open('/etc/group').readlines()])
i = $first_uid
while i in pid or i in gid: i += 1
print i
"

}

#
# Create a local user account
#
# IN: username
# IN: homeroot

function create_user_account() {
    USERNAME=$1

    HOMEDIR=`homedir $USERNAME`
    SKEL_DIR=${SKEL_DIR:=$DEFAULT_LIBRA_SKEL_DIR}

    (
      flock -x -w 10 200
      ${NOOP} useradd -u `next_uid` -d ${HOMEDIR} -s /usr/bin/trap-user -c 'libra guest' -m -k $SKEL_DIR $USERNAME

      if [ $? -ne 0 ]
      then
          echo "ERROR: unable to create user account $USERNAME"
          exit 1
      fi
    ) 200>/var/lock/libra_create
    ${NOOP} chown "root.$USERNAME" "$HOMEDIR"
    ${NOOP} chmod 0750 "$HOMEDIR"
}

function remove_user_account {
    USERNAME=$1

    for i in {1..10}
    do
        if /bin/ps -U "$USERNAME" -o pid | /bin/grep -v PID | xargs kill -9 2> /dev/null
        then
            sleep .5
        else
            break
        fi
    done

    ${NOOP} rm -rf `homedir $USERNAME`
    ${NOOP} userdel ${USERNAME}
}

#
# Create Environment and temp dirs
#
# ASSUME: local user with username
# IN: username
# IN: HOMEDIR
#
function create_user_home_skel {
    USERNAME="$1"
    USERHOME=`homedir $USERNAME`

    ${NOOP} mkdir -p ${USERHOME}/.tmp ${USERHOME}/.env

    # Required for polyinstantiated tmp dirs to work
    ${NOOP} chmod 0000 ${USERHOME}/.tmp
    ${NOOP} chmod 0750 ${USERHOME}/.env
    ${NOOP} chgrp ${USERNAME} ${USERHOME}/.env
    ${NOOP} echo "export OPENSHIFT_APP_UUID='${USERNAME}'" > ${USERHOME}/.env/OPENSHIFT_APP_UUID
    ${NOOP} echo "export OPENSHIFT_HOMEDIR='${USERHOME}/'" > ${USERHOME}/.env/OPENSHIFT_HOMEDIR
}

#
# Enable SSH RSA access for a user
#
# ASSUME: local user with username exists
# IN: username
# IN: user home directory
# IN: SSH RSA key string
#
function enable_user_ssh_access {
    USERNAME="$1"
    SSHKEY="$2"
    
    USERHOME=`homedir $USERNAME`
    SSHDIR=${USERHOME}/.ssh

    CMDENTRY="command=\"/usr/bin/trap-user\",no-port-forwarding,no-X11-forwarding ssh-rsa $SSHKEY Libra-$USERNAME"

    ${NOOP} mkdir -p ${SSHDIR}
    ${NOOP} chmod 0750 ${SSHDIR}
    if [ -z "${NOOP}" ]
    then
	    echo "$CMDENTRY" > ${SSHDIR}/authorized_keys
    else
        echo "echo '$CMDENTRY' > ${SSHDIR}/authorized_keys"
    fi
    ${NOOP} chmod 0440 ${SSHDIR}/authorized_keys
    # Give force ssh key to not change
    ${NOOP} chown -R "root.$USERNAME" ${SSHDIR}
    ${NOOP} restorecon -R ${SSHDIR}
}


#
# Add a PAM limit set to the user
#
# IN: username
# IN: limits_order
# IN: limits_nproc
#

LIMITSVARS="core data fsize memlock nofile rss stack cpu nproc as maxlogins priority locks sigpending msgqueue nice rprio"

# TODO: check if file already exists
function set_pam_limits {
    USERNAME=$1
    #assume these come from sourced config file into environment
    #LIMITS_ORDER=${2:-$limits_order}
    #LIMITS_NPROC=${3:-$limits_nproc}

    LIMITSFILE=/etc/security/limits.d/${limits_order}-${USERNAME}.conf

    if [ -z "${NOOP}" ]
    then
	cat <<EOF > ${LIMITSFILE}
# PAM process limits for guest $customer_id
# see limits.conf(5) for details
#Each line describes a limit for a user in the form:
#
#<domain> <type> <item> <value>
EOF
    else
	echo "cat <<EOF > ${LIMITSFILE}
# PAM process limits for guest $customer_id
# see limits.conf(5) for details
#Each line describes a limit for a user in the form:
#
#<domain>        <type>  <item>  <value>
${USERNAME}     hard    nproc   ${LIMITS_NPROC}
EOF"

    fi

    for KEY in $LIMITSVARS
    do
	VALUE=`eval echo \\$limits_$KEY`
	if [ -n "$VALUE" ]
	then
	    if [ -z "${NOOP}" ]
        then
		    echo "${USERNAME} hard $KEY $VALUE" >> ${LIMITSFILE}
        else
		    echo "echo \"${USERNAME} hard $KEY $VALUE\" >> ${LIMITSFILE}"
	    fi
	fi
    done

}

function remove_pam_limits {
    USERNAME=$1
    LIMITS_ORDER=${2:-$limits_order}

    LIMITSFILE=/etc/security/limits.d/${LIMITS_ORDER}-${USERNAME}.conf

    ${NOOP} rm -f ${LIMITSFILE}
}

# conditions

# ============================================================================
# Quota management
# ============================================================================
#
# We need to be able to find the terminal mount point or device file for
# the filesystem containing the Libra application home directories.
#
# df(1) will present the device and mountpoint when given a file or directory
#
# A terminal mount point is identified when the device is either a UUID or
# a file path in /dev.
#
# If it is not, and the mount options contain 'bind' then search again using
# dirname of the bind "device" path.
#
# repeat until you find a terminal device
#
#function get_filesystem() {
#    # $1=libra_dir
#    df -P $1 | tail -1 | tr -s ' ' | cut -d' ' -f 1
#}

function get_mountpoint() {
    df -P $1 | tail -1 | tr -s ' ' | cut -d' ' -f 6 | sort -u
}

function get_mount_device() {
    df -P $1 | tail -1 | tr -s ' ' | cut -d' ' -f 1 | sort -u
}

function get_mount_options() {
    mount | grep " $1 " | sed -e 's/^.*(// ; s/).*$// ' | sort -u
    #cat /etc/fstab | tr -s ' ' | grep $1 | awk '{print $4;}'
}

#
# This is not efficient, but it avoids bind mounts
#
function get_terminal_mountpoint() {
    # DIR=$1
    MP=`get_mountpoint $1`
    DEV=`get_mount_device $1`

    while echo $DEV | grep -v -E '^/dev/|LABEL=|UUID=' >/dev/null 2>&1
    do
	MP=`dirname $DEV`
	DEV=`get_mount_device $MP`
    done

    echo $MP
}

#LIBRA_FILESYSTEM=`get_filesystem $libra_dir`
LIBRA_MOUNTPOINT=`get_terminal_mountpoint $libra_dir`
QUOTA_FILE=$( echo ${LIBRA_MOUNTPOINT}/aquota.user | tr -s /)


#
# Find the quota mountpoint by searching back from a known path until
# you find aquota.user
#
function get_quota_root() {
    # DIR=$1
    QUOTA_ROOT=$1
    while [ -n "$QUOTA_ROOT" -a ! -f "$QUOTA_ROOT/aquota.user" ]
    do
        if [ "$QUOTA_ROOT" = "/" ]
        then
            QUOTA_ROOT=""
        else
            QUOTA_ROOT=`dirname $QUOTA_ROOT`
        fi
    done
    echo $QUOTA_ROOT
}

#
# Are quotas configured?
# quotaon prints the status of all configured filesystems
# if no filesystems are configured, there is no output
function quotas_configured {
    test -n `quotaon -u -p -a > /dev/null 2>&1`
}

# Are quotas enabled on the specified directory?
function quotas_enabled {
    # DIR=$1
    QUOTA_ROOT=`get_quota_root $1`
    # if you can't find the quota root for the given directory, it's not enabled
    if [ -z "${QUOTA_ROOT}" ]
    then
        return 1
    fi
    quotaon -u -p $QUOTA_ROOT >/dev/null 2>&1
    # quotaon returns the opposite of what you expect
    # 1 = enabled, 0 = not enabled
    if [ $? -eq 0 ]
    then
        return 1
    else
        return 0
    fi
}

#
# Get the user's current quotas in a managable string form:
#      inodes       blocks
# fs use soft hard use soft hard
# empty string means "no quotas set"
#
function user_quotas {
    # USERNAME=$1
    FS=`get_quota_root $libra_dir`
    quota -w -u $1 | grep $FS | tr -s ' ' | sed 's/^ //'
}

#
# Set a user's inode and block quotas on the home file system
# usage: set_fs_quota <username> <inodes> <blocks>
function set_fs_quotas {
    # USERNAME=$1
    # QUOTA_BLOCKS=${2:-$quota_blocks}
    # QUOTA_FILES=${3:-$quota_files}

    # get the user home directory
    # get the quota mount point
    if quotas_configured
    then
        if quotas_enabled $libra_dir
        then
            setquota $1 0 $2 0 $3 `get_quota_root $libra_dir`
        else
            echo "WARNING: quotas not enabled on $libra_dir" >&2
        fi
    else
        echo "WARNING: quotas not configured" >&2
    fi
}

# Remove filesystem quota limits for the user
function remove_fs_quotas {
    USERNAME=$1
    if quotas_configured
    then
        if quotas_enabled $libra_dir
        then
            setquota $1 0 0 0 0 `get_quota_root $libra_dir`
        else
            echo "WARNING: quotas not enabled on $libra_dir" >&2
        fi
    else
        echo "WARNING: quotas not configured" >&2
    fi
}

# ============================================================================
#                                 MAIN
# ============================================================================

# get configuration values from libra configuration files or defaults
initialize

# provides values for username and ssh_key
parse_options $*

if [ -z "$REVERT" ]
then
    create_user_account $username

    if (service cgconfig status > /dev/null 2>&1)
    then
        service libra-cgroups startuser ${username} > /dev/null
    fi

    if (service libra-tc status > /dev/null 2>&1)
    then
        service libra-tc startuser ${username} > /dev/null
    fi

    enable_user_ssh_access $username "$ssh_key"
    create_user_home_skel $username

    set_pam_limits $username

    set_fs_quotas $username $quota_blocks $quota_files
else
    if (service libra-tc status ${username} > /dev/null 2>&1)
    then
        service libra-tc stopuser ${username} > /dev/null
    fi

    if (service cgconfig status > /dev/null)
    then
        service libra-cgroups stopuser ${username} > /dev/null
    fi

    remove_fs_quotas $username

    remove_pam_limits $username

    remove_user_account $username
fi
