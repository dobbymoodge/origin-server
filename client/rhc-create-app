#!/usr/bin/env ruby
# Copyright © 2010 Jim Jagielski All rights reserved
# Copyright © 2010 Mike McGrath All rights reserved
# Copyright © 2010 Red Hat, Inc. All rights reserved

# This copyrighted material is made available to anyone wishing to use, modify,
# copy, or redistribute it subject to the terms and conditions of the GNU
# General Public License v.2.  This program is distributed in the hope that it
# will be useful, but WITHOUT ANY WARRANTY expressed or implied, including the
# implied warranties of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.  You should have
# received a copy of the GNU General Public License along with this program;
# if not, write to the Free Software Foundation, Inc., 51 Franklin Street,
# Fifth Floor, Boston, MA 02110-1301, USA. Any Red Hat trademarks that are
# incorporated in the source code or documentation are not subject to the GNU
# General Public License and may only be used or replicated with the express
# permission of Red Hat, Inc.

require "rubygems"
require "uri"
require "net/http"
require "getoptlong"
require 'resolv'
require 'json'
require 'parseconfig'
require 'fileutils' 
require File.dirname($0) + '/rhc-common'

config_path = File.exists?('client.conf') ? 'client.conf' : '/etc/libra/client.conf'

unless File.exists?("#{ENV['HOME']}/.li")
    file = File.open("#{ENV['HOME']}/.li", 'w')
    file.close
end

begin
    @global_config = ParseConfig.new(config_path)
    @local_config = ParseConfig.new("#{ENV['HOME']}/.li")
rescue Errno::EACCES => e
    puts "Could not open config file: #{e.message}"
    exit 253
end

#
# Check if host exists
#
def hostexist?(host)
    dns = Resolv::DNS.new
    resp = dns.getresources(host, Resolv::DNS::Resource::IN::A)
    return resp.any?
end

#
# Check for local var in ~/.li use it, else use /etc/libra/client.conf
#
def get_var(var)
    @local_config.get_value(var) ? @local_config.get_value(var) : @global_config.get_value(var)
end


def p_usage
    username = @local_config.get_value('default_user') ? "Default: #{@local_config.get_value('default_user')}" : "(required)"
    type_keys = RHC::get_type_keys(', ')
    puts <<USAGE

Usage: #{$0}
Create a new app libra project.

  -a|--app   application  Application name  (alphanumeric) (required)
  -t|--type  type         Type of app to create (#{type_keys}) (required)
  -u|--user  username     Libra username    (alphanumeric) (#{username})
  -r|--repo  path         Git Repo path (defaults to ./$app_name)
  -b|--bypass             Bypass warnings
  -d|--debug              Print Debug info
  -h|--help               Show Usage info

USAGE
exit 255
end

opts = GetoptLong.new(
    ["--debug", "-d", GetoptLong::NO_ARGUMENT],
    ["--help",  "-h", GetoptLong::NO_ARGUMENT],
    ["--bypass","-b", GetoptLong::NO_ARGUMENT],
    ["--user",  "-u", GetoptLong::REQUIRED_ARGUMENT],
    ["--app",   "-a", GetoptLong::REQUIRED_ARGUMENT],
    ["--repo",  "-r", GetoptLong::OPTIONAL_ARGUMENT],
    ["--type",  "-t", GetoptLong::REQUIRED_ARGUMENT]
)


# Pull in configs from files
libra_domain = get_var('libra_domain')
libra_dir = get_var('libra_dir')
li_server = get_var('li_server')
debug = get_var('debug') == 'false' ? nil : get_var('debug')

ssh_config = "#{ENV['HOME']}/.ssh/config"
ssh_config_d = "#{ENV['HOME']}/.ssh/"

opt = {}
opts.each do |o, a|
    opt[o[2..-1]] = a.to_s
end

if opt["help"]
    p_usage
end

if opt["debug"]
    debug = true
end

opt["user"] = @local_config.get_value('default_user') unless opt["user"]

if !RHC::check_user(opt['user'])
    p_usage
end

if !RHC::check_app(opt['app'])
    p_usage
end


@type = RHC::get_type(opt['type'])
if !@type  
    p_usage
end

if !opt["user"] || !opt["app"] || !opt["type"]
    p_usage
end

#
# Get UUID from file
#

uuid = @local_config.get_value(opt["user"])
unless uuid
    puts "Could not find UUID for #{opt["user"]}"
    exit 149
end

opt["repo"] = opt["app"] unless opt["repo"]

#
# Send Warning
#

if !opt["bypass"]
    puts <<WARNING
NOTICE: This is pre-alpha destructionware.  It is not tested, it
might break at any time.  While we'll generally leave it running, there is no
attempt at data protection or downtime minimization.  This is just a proof
of concept, do not store anything important here.

Thar be dragons this way.

Rules/Terms:
1) Don't put anything important here.
2) Know we won't be protecting data in any way and may arbitrarly destroy it
3) The service will go up and down as we are developing it, which may be a lot
4) We'll be altering your ~/.ssh/config file a bit, should be harmless.
5) Bugs should be sent to the libra team
6) This entire service may vanish as this is just a proof of concept.

WARNING

    print "Do you agree to the rules and terms? (y/n): "
    agree = gets.chomp
    if agree != 'y'
        puts "Sorry this won't work for you, keep tabs for future updates"
        exit 5
    end
end
puts ""
puts "Remember: this is pre-alpha destructionware.  Let #libra know of any bugs you find"
puts ""

#
# Create local git repo
#

def cleanup_and_exit(repo, code)
    FileUtils.rm_rf repo
    exit code
end

if File.exists?(opt['repo']) 
    puts "We will not overwrite an existing git repo. Exiting"
    exit 255
else
    Dir.mkdir(opt['repo'])
end

#
# Create remote application space
#

puts "Creating remote application space: " + opt['app']

json_data = JSON.generate(
               {:cartridge => "#{opt['type']}",
                :action => 'configure',
                :app_name => "#{opt['app']}",
                :username => "#{opt['user']}"})

puts "Contacting server http://#{li_server}"
response = Net::HTTP.post_form(URI.parse("http://#{li_server}/php/cartridge_do.php"),
                           { 'json_data' => json_data })

json_resp = JSON.parse(response.body);
if response.code == '200'
    if debug
        puts "HTTP response from server is:"
        json_resp.each do |k,v|
            puts "#{k.to_s}: #{v.to_s}"
        end
    end
    puts "Creation successful"
else
    puts "Problem with server. Response code was #{response.code}"
    puts "HTTP response from server is #{response.body}"
    json_resp.each do |k,v|
        puts "#{k.to_s}: #{v.to_s}"
    end    
    cleanup_and_exit(opt['repo'], 254)
end

#
# Check / add new host to ~/.ssh/config
#

puts "Checking ~/.ssh/config"

my_url = "#{opt['app']}.#{opt['user']}.#{libra_domain}"

found = false
File.open(ssh_config) do |sline|
    if sline =~ /my_url/
        found = true
        break
    end
end

if found
    puts "Found #{my_url} in ~/.ssh/config... No need to adjust"
else
    puts "    Adding #{my_url} to ~/.ssh/config"
    f = File.open(ssh_config, "a")
    f.puts <<SSH

# Added by libra app on #{`date`}
Host #{my_url}
    User #{uuid}
    IdentityFile ~/.ssh/libra_id_rsa
    VerifyHostKeyDNS yes
    StrictHostKeyChecking no
    PasswordAuthentication no

SSH
f.close
end

File.chmod(0600, ssh_config)
File.chmod(0700, ssh_config_d)

#
# Confirm that the host exists in DNS
#
puts "Confirming that host exists..."
loop = 0
sleep_time = 2.5
while loop < 5 && !hostexist?(my_url)
    sleep sleep_time *= 2
    loop+=1
    puts "  retry # #{loop}"
end

if loop == 5
    puts "Host could not be created and/or found..."
    exit 255
end

sleep_time = 2
attempt = 0

#
# Pull new repo locally
#
puts "Pulling new repo down"
git_pull = `git clone ssh://#{opt['app']}.#{opt['user']}.#{libra_domain}/#{libra_dir}/#{uuid}/git/#{opt['app']}.git/ #{opt['repo']}`
if $?.exitstatus != 0
    puts "Error in git pull"
    puts git_pull
    exit 255
end

#
# Test several times, doubling sleep time between attempts.
#

puts "Confirming application #{opt['app']} is available"
while sleep_time < 65
    attempt+=1
    puts "  Attempt # #{attempt}"
    page = ''
    if (@type == :php)
      page = 'health_check.php'
    elsif (@type == :rack)
      page = 'health'
    end
    url = URI.parse("http://#{my_url}/#{page}")
    response = Net::HTTP.get_response(url)
    if response.code == "200" && response.body[0,1] == "1"
        puts <<LOOKSGOOD

Success!  Your application is now available at:

      http://#{my_url}/

To make changes to your application, commit to $new_repo_path/.
Then run 'git push origin master' to update your libra space

LOOKSGOOD
        exit 0
    end
    puts "Server responded with #{response.code}"
    puts response.body
    puts
    puts "    sleeping #{sleep_time} seconds"
    sleep sleep_time
    sleep_time *= 2
end
puts "Unable to find or access the site... problems"
exit 255
