#!/usr/bin/env ruby
# Copyright © 2010 Jim Jagielski All rights reserved
# Copyright © 2010 Mike McGrath All rights reserved
# Copyright © 2010 Red Hat, Inc. All rights reserved

# This copyrighted material is made available to anyone wishing to use, modify,
# copy, or redistribute it subject to the terms and conditions of the GNU
# General Public License v.2.  This program is distributed in the hope that it
# will be useful, but WITHOUT ANY WARRANTY expressed or implied, including the
# implied warranties of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.  You should have
# received a copy of the GNU General Public License along with this program;
# if not, write to the Free Software Foundation, Inc., 51 Franklin Street,
# Fifth Floor, Boston, MA 02110-1301, USA. Any Red Hat trademarks that are
# incorporated in the source code or documentation are not subject to the GNU
# General Public License and may only be used or replicated with the express
# permission of Red Hat, Inc.

require "rubygems"
require "uri"
require "net/http"
require "net/https"
require "getoptlong"
require 'resolv'
require 'json'
require 'parseconfig'
require 'fileutils'
require File.dirname($0) + '/rhc-common'

@config_path = File.exists?('client.conf') ? 'client.conf' : '/etc/libra/client.conf'
@local_config_path = File.exists?('.li') ? '.li' : "#{ENV['HOME']}/.li"

FileUtils.touch @local_config_path

begin
    @global_config = ParseConfig.new(@config_path)
    @local_config = ParseConfig.new(@local_config_path)
rescue Errno::EACCES => e
    puts "Could not open config file: #{e.message}"
    exit 253
end

#
# Check for proxy environment
#
if ENV['http_proxy']
    host, port = ENV['http_proxy'].split(':')
    @http = Net::HTTP::Proxy(host, port)
else
    @http = Net::HTTP
end

#
# Check if host exists
#
def hostexist?(host)
    dns = Resolv::DNS.new
    resp = dns.getresources(host, Resolv::DNS::Resource::IN::A)
    return resp.any?
end

#
# Check for local var in ~/.li use it, else use /etc/libra/client.conf
#
def get_var(var)
    @local_config.get_value(var) ? @local_config.get_value(var) : @global_config.get_value(var)
end

def p_usage
    rhlogin = @local_config.get_value('default_rhlogin') ? "Default: #{@local_config.get_value('default_rhlogin')}" : "(required)"
    puts <<USAGE

Usage: #{$0}
Control a libra app

  -a|--app   application   Application name  (alphanumeric) (required)
  -l|--rhlogin rhlogin     Red Hat login  (alphanumeric) (#{rhlogin})
  -p|--password password   RHLogin password  (alphanumeric) (optional, will prompt)
  -c|--command command     (start|stop|restart|reload|status|destroy)
  -b|--bypass              Bypass warnings
  -d|--debug               Print Debug info
  -h|--help                Show Usage info

USAGE
exit 255
end

opts = GetoptLong.new(
    ["--debug",     "-d", GetoptLong::NO_ARGUMENT],
    ["--help",      "-h", GetoptLong::NO_ARGUMENT],
    ["--bypass",    "-b", GetoptLong::NO_ARGUMENT],
    ["--rhlogin",   "-l", GetoptLong::OPTIONAL_ARGUMENT],
    ["--password",   "-p", GetoptLong::OPTIONAL_ARGUMENT],
    ["--app",       "-a", GetoptLong::REQUIRED_ARGUMENT],
    ["--command",   "-c", GetoptLong::REQUIRED_ARGUMENT]
)


# Pull in configs from files
libra_domain = get_var('libra_domain')
libra_dir = get_var('libra_dir')
li_server = get_var('li_server')
debug = get_var('debug') == 'false' ? nil : get_var('debug')
ssh_config = "#{ENV['HOME']}/.ssh/config"
ssh_config_d = "#{ENV['HOME']}/.ssh/"

opt = {}
opts.each do |o, a|
    opt[o[2..-1]] = a.to_s
end

if opt["help"]
    p_usage
end

if opt["debug"]
    debug = true
end

opt["rhlogin"] = @local_config.get_value('default_rhlogin') unless opt["rhlogin"]

if !RHC::check_rhlogin(opt['rhlogin'])
    p_usage
end

if !RHC::check_app(opt['app'])
    p_usage
end

unless defined? opt["command"] and opt["command"] =~ /(start|stop|restart|reload|status|destroy)/
    puts "Command is required"
    p_usage
end

if !opt['rhlogin'] || !opt['app'] || !opt['command']
    p_usage
end

password = opt['password'] 
if !password
  password = RHC::get_password
end

user_info = RHC::get_user_info(li_server, opt['rhlogin'], password, @http, debug)
app = user_info['app_info'][opt['app']]
if app
  framework = app['framework']
else
  puts "Application not found: #{opt['app']}"
  exit 252
end
#
# Send Warning
#

opt["command"] = "deconfigure" if opt["command"] == "destroy"

if !opt["bypass"] and opt["command"] == "deconfigure"
    # deconfigure is the actual hook called on 'destroy'
    # destroy is used for clarity


    puts <<WARNING
!!!! WARNING !!!! WARNING !!!! WARNING !!!!
You are about to destroy the #{opt['app']} application.

This is NOT reversable, all remote data for this application will be removed.
WARNING

    print "Do you want to destroy this application (y/n): "
    agree = gets.chomp
    if agree != 'y'
        puts "Destroy aborted"
        exit 5
    end
end
puts ""
puts "Remember: this is pre-alpha destructionware.  Let #libra know of any bugs you find."
puts ""

json_data = JSON.generate(
               {:cartridge => framework,
                :action => opt['command'],
                :app_name => "#{opt['app']}",
                :rhlogin => "#{opt['rhlogin']}",
                :password => password
                })

puts "Contacting server https://#{li_server}"

url = URI.parse("https://#{li_server}/php/cartridge_do.php")
response = RHC::http_post(@http, url, json_data)

json_resp = JSON.parse(response.body);

if response.code == '200'
    puts "HTTP response from server is #{response.body}" if debug
    puts "Action successful"
    if (json_resp['return'].to_s.strip != "0")
        puts "An error has occured: #{response.body}"
        json_resp.each do |k,v|
            puts "#{k.to_s}: #{v.to_s}"
        end
        exit 253
    end
else
    puts "Problem with server. Response code was #{response.code}"
    puts "HTTP response from server is #{response.body}"
    json_resp.each do |k,v|
        puts "#{k.to_s}: #{v.to_s}"
    end
    exit 254
end
