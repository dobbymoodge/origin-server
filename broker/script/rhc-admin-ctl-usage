#!/usr/bin/env ruby

require 'rubygems'
require 'getoptlong'

def usage
    puts <<USAGE
== Synopsis

rhc-admin-ctl-usage: Control usage

== Usage

rhc-admin-ctl-usage OPTIONS

Options:
--rhlogin   <rhlogin>
    RHLogin to control
--sync
    Sync usage with the billing vendor
--list
    List usage available to be synced
-h|--help
    Show Usage info
USAGE
end

opts = GetoptLong.new(
    ["--app_uuid",               GetoptLong::REQUIRED_ARGUMENT],
    ["--rhlogin",          "-l", GetoptLong::REQUIRED_ARGUMENT],
    ["--list",                   GetoptLong::NO_ARGUMENT],
    ["--sync",                   GetoptLong::NO_ARGUMENT],
    ["--help",             "-h", GetoptLong::NO_ARGUMENT]
)

args = {}
begin
    opts.each{ |k,v| args[k]=v }
rescue GetoptLong::Error => e
    usage
    exit -100
end

rhlogin = args["--rhlogin"]
sync = args["--sync"]
list = args["--list"]
  
unless sync || list 
  puts "You must --list or --sync"
  exit 1
end

if args["--help"]
  usage
  exit 1
end

require "/var/www/stickshift/broker/config/environment"

def usage_time(usage_record, begin_time, end_time)
  if usage_record.sync_time
    if false # TODO aria_already_has_records?(usage_record.uuid, usage_record.sync_time)
      puts "WARNING: Usage data has already been sent to billing vendor but not removed from datastore usage.  Resetting begin_time to previous sync_time."
      begin_time = usage_record.sync_time
    else
      puts "WARNING: Billing vendor doesn't have the records.  Leaving begin_time from previous sync."
    end
  end
  total_time = (end_time - begin_time) / 60 # minutes
  total_time
end

users = nil
if rhlogin
  user = CloudUser.find(rhlogin)
  if user
    users = [user]
  else
    puts "User not found: #{rhlogin}"
    exit 1  
  end
else
  users = CloudUser.find_all(nil)
end

users.each do |user|
  if user.gear_usage_records && !user.gear_usage_records.empty?
    puts "\n#################"
    puts "User: #{user.login}"
    puts "#################"
    sorted_gear_usage = user.gear_usage_records.sort_by { |usage_record| usage_record.time }
    usage_records_by_gear = {}
    sorted_gear_usage.each do |usage_record|
      usage_records_by_gear[usage_record.gear_uuid] = [] unless usage_records_by_gear[usage_record.gear_uuid]
      usage_records_by_gear[usage_record.gear_uuid] << usage_record
    end
    if sync
      usage_records_by_gear.each do |gear_uuid, usage_records_for_gear|
        usage = nil
        usage_records_for_gear.each do |usage_record|
          unless usage_record.event == UsageRecord::EVENTS[:continue]
            usage = Usage.find_latest_by_gear(usage_record.gear_uuid) unless usage
            if !usage && usage_record.event == UsageRecord::EVENTS[:begin]
              puts "WARNING: Usage not found in collection for new gear: #{usage_record.gear_uuid}"
              usage = Usage.new(user.login, usage_record.gear_uuid, usage_record.gear_size, usage_record.time, nil, usage_record.uuid)
            elsif usage
              if usage_record.event == UsageRecord::EVENTS[:end]
                puts "Setting end time for gear: #{usage.gear_uuid}"
                usage.end_time = usage_record.time
              end
            else
              puts "ERROR: Usage not found in collection for gear: #{usage_record.gear_uuid}"
              exit 1
            end
          end
        end
        usage.save! if usage
      end

      usage_records_by_gear.each do |gear_uuid, usage_records_for_gear|
        puts "Collecting usage for gear: #{gear_uuid}"
        usage = nil
        begin_time = nil
        end_time = nil
        now = Time.new
        usage_records_for_gear.each do |usage_record|
          if usage_record.event == UsageRecord::EVENTS[:end]
            end_time = usage_record.time
          else
            begin_time = usage_record.time
          end
        end
        end_time = now unless end_time

        usage_record = usage_records_for_gear.first
        usage_time = usage_time(usage_record, begin_time, end_time)
        puts "Saving sync_time before sending usage data to billing vendor."
        usage_record.sync_time = now
        usage_record.save
        puts "Sending usage data (#{usage_time}m) to billing vendor."
        # Send data to billing vendor
        #if success
          puts "Billing vendor returned success."
          if usage_records_for_gear.length == 2 && usage_records_for_gear.last.event == UsageRecord::EVENTS[:end]
            puts "Deleting ended usage record"
            usage_record.delete_by_gear_uuid
          else
            puts "Continuing usage record."
            usage_record.event = UsageRecord::EVENTS[:continue]
            usage_record.time = now
            usage_record.sync_time = nil
            usage_record.save
          end
        #else
          #retry or wait till next cycle
          #break
        #end
      end
    elsif list
      usage_records_by_gear.each do |gear_uuid, usage_records_for_gear|
        puts "Collecting usage for gear: #{gear_uuid}"
        begin_time = nil
        end_time = nil
        now = Time.new
        usage_records_for_gear.each do |usage_record|
          if usage_record.event == UsageRecord::EVENTS[:end]
            end_time = usage_record.time
          else
            begin_time = usage_record.time
          end
        end
        if end_time
          puts "Usage record ended."
        else
          puts "Usage record continued."
          end_time = now
        end
        usage_time = usage_time(usage_records_for_gear.first, begin_time, end_time)
        puts "Usage to send to billing vendor: #{usage_time}m"
      end
    end
  else
    puts "Gear usage not found for user: #{user.login}"
  end
  puts "Done"
end