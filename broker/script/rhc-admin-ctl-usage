#!/usr/bin/env ruby

require 'rubygems'
require 'getoptlong'
require 'socket'

def usage
    puts <<USAGE
== Synopsis

rhc-admin-ctl-usage: Control usage

== Usage

rhc-admin-ctl-usage OPTIONS

Options:
--sync
    Sync usage with the billing vendor
--remove_sync_lock
    Remove existing sync lock
--list
    List usage available to be synced
-h|--help
    Show Usage info
USAGE
end

opts = GetoptLong.new(
    ["--remove_sync_lock",       GetoptLong::NO_ARGUMENT],
    ["--list",                   GetoptLong::NO_ARGUMENT],
    ["--sync",                   GetoptLong::NO_ARGUMENT],
    ["--help",             "-h", GetoptLong::NO_ARGUMENT]
)

args = {}
begin
    opts.each{ |k,v| args[k]=v }
rescue GetoptLong::Error => e
    usage
    exit -100
end

sync = args["--sync"]
list = args["--list"]
remove_sync_lock = args["--remove_sync_lock"]

if args["--help"]
  usage
  exit 1
end

unless sync || list || remove_sync_lock
  puts "You must --list or --sync or --remove_sync_lock"
  exit 1
end

require "/var/www/stickshift/broker/config/environment"

def usage_time(billing_api, acct_no, usage_record, begin_time, end_time)
  if usage_record.sync_time
    found = false
    usages = billing_api.get_usage_history(acct_no, billing_api.usage_type[usage_record.gear_size.to_sym])
    usages.each do |usage|
      gear_uuid = usage["qualifier_1"]
      sync_time = usage["qualifier_2"]
      if usage_record.sync_time.to_i == sync_time.to_i && usage_record.gear_uuid == gear_uuid
        found = true
        break
      end
    end
    if found
      puts "WARNING: Usage data has already been sent to billing vendor but not removed from datastore usage.  Resetting begin_time to previous sync_time."
      begin_time = usage_record.sync_time
    else
      puts "WARNING: Billing vendor doesn't have the records.  Leaving begin_time from previous sync."
    end
  end
  total_time = (end_time - begin_time) / 3600 # hours
  total_time
end

def get_billing_user_acct_no(billing_api, user)
  puts "Aria userid: #{user.uuid}"
  unless billing_api.userid_exists(user.uuid)
    puts "User didn't exist"
    # Temporary code until users are created up front
    acct_no = billing_api.create_fake_acct(user.uuid, :MegaShift)
  else
    acct_no = billing_api.get_acct_no_from_user_id(user.uuid)
  end
  acct_no
end

if remove_sync_lock
  Express::Broker::DistributedLock.release_lock("sync_usage")
else
  hostname = Socket.gethostname
  if Express::Broker::DistributedLock.obtain_lock("sync_usage", hostname)
    begin
      CloudUser.find_all(nil, {:with_gear_usage => true}) {|hash|
        user = CloudUser.hash_to_obj(hash)
        failures = []
        if user.gear_usage_records && !user.gear_usage_records.empty?
          puts "\n#################"
          puts "User: #{user.login}"
          puts "#################"
          sorted_gear_usage = user.gear_usage_records.sort_by { |usage_record| usage_record.time }
          usage_records_by_gear = {}
          sorted_gear_usage.each do |usage_record|
            usage_records_by_gear[usage_record.gear_uuid] = [] unless usage_records_by_gear[usage_record.gear_uuid]
            usage_records_by_gear[usage_record.gear_uuid] << usage_record
          end
          billing_api = Express::AriaBilling::Api.new
          billing_acct_no = get_billing_user_acct_no(billing_api, user)
          if sync

            usage_records_by_gear.each do |gear_uuid, usage_records_for_gear|
              usage = nil
              usage_records_for_gear.each do |usage_record|
                unless usage_record.event == UsageRecord::EVENTS[:continue]
                  usage = Usage.find_latest_by_gear(usage_record.gear_uuid) unless usage
                  if !usage && usage_record.event == UsageRecord::EVENTS[:begin]
                    puts "WARNING: Usage not found in collection for new gear: #{usage_record.gear_uuid}"
                    usage = Usage.new(user.login, usage_record.gear_uuid, usage_record.gear_size, usage_record.time, nil, usage_record.uuid)
                  elsif usage
                    if usage_record.event == UsageRecord::EVENTS[:end]
                      puts "Setting end time for gear: #{usage.gear_uuid}"
                      usage.end_time = usage_record.time
                    end
                  else
                    puts "ERROR: Usage not found in collection for gear: #{usage_record.gear_uuid}"
                    exit 1
                  end
                end
              end
              usage.save! if usage
            end

            usage_records_by_gear.each do |gear_uuid, usage_records_for_gear|
              puts "Collecting usage for gear: #{gear_uuid}"
              usage = nil
              begin_time = nil
              end_time = nil
              now = Time.now.utc
              usage_records_for_gear.each do |usage_record|
                if usage_record.event == UsageRecord::EVENTS[:end]
                  end_time = usage_record.time
                else
                  begin_time = usage_record.time
                end
              end
              end_time = now unless end_time
    
              usage_record = usage_records_for_gear.first
              ut = usage_time(billing_api, billing_acct_no, usage_record, begin_time, end_time)
              puts "Saving sync_time before sending usage data to billing vendor."
              usage_record.sync_time = now
              usage_record.save
              puts "Sending usage data (#{ut}h) to billing vendor."
              # Send data to billing vendor
              success = false
              2.times do
                if billing_api.record_usage(gear_uuid, usage_record.sync_time, user.uuid, nil, billing_api.usage_type[usage_record.gear_size.to_sym], ut)
                  success = true
                  break
                else
                  sleep 1
                end
              end
              #TODO 
              if success
                puts "Billing vendor returned success."
                if usage_records_for_gear.length == 2 && usage_records_for_gear.last.event == UsageRecord::EVENTS[:end]
                  puts "Deleting ended usage record"
                  usage_record.delete_by_gear_uuid
                else
                  puts "Continuing usage record."
                  usage_record.event = UsageRecord::EVENTS[:continue]
                  usage_record.time = now
                  usage_record.sync_time = nil
                  usage_record.save
                end
              else
                puts "Billing vendor returned error."
                failures << [user.login, gear_uuid]
                break
              end
            end
          elsif list
            usage_records_by_gear.each do |gear_uuid, usage_records_for_gear|
              puts "Collecting usage for gear: #{gear_uuid}"
              begin_time = nil
              end_time = nil
              now = Time.now.utc
              usage_records_for_gear.each do |usage_record|
                if usage_record.event == UsageRecord::EVENTS[:end]
                  end_time = usage_record.time
                else
                  begin_time = usage_record.time
                end
              end
              if end_time
                puts "Usage record ended."
              else
                puts "Usage record continued."
                end_time = now
              end
              ut = usage_time(billing_api, billing_acct_no, usage_records_for_gear.first, begin_time, end_time)
              puts "Usage to send to billing vendor: #{ut}h"
            end
          end
        else
          puts "Gear usage not found for user: #{user.login}"
        end
      }

      unless failures.empty?
        puts "!!!!!!!!!!!!!!!!!!!FAILURES!!!!!!!!!!!!!!!!!!!!!!"
        puts "<User>: <Gear UUID>"
        failures.each do |failure|
          puts "#{failure[0]}: #{failure[1]}"
        end
        puts "!!!!!!!!!!!!!!!!!END FAILURES!!!!!!!!!!!!!!!!!!!!"
      end
    ensure
      Express::Broker::DistributedLock.release_lock("sync_usage", hostname)
    end
  else
    puts "Failed to obtain lock to interact with usage data"
    exit 1
  end
  puts "Done"
end