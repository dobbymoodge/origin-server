#!/usr/bin/env oo-ruby

require 'rubygems'
require 'getoptlong'
require "/var/www/openshift/broker/config/environment"

Rails.configuration.msg_broker[:rpc_options][:disctimeout] = 20


def check_gear_uid(gear, new_uid)
  district = OpenShift::DataStore.instance.find_district_with_node(gear.server_identity)
  # district = gear.get_proxy.district
  if district.nil?
    return 
  end
  # first check if the new_uid is not taken by anyone on the member nodes (other than this gear's node)
  district["server_identities"].keys.each { |server_id|
    next if server_id == gear.get_proxy.id
    if $sender_hash[server_id].has_key? new_uid
      raise Exception.new("ERROR : Gear #{gear.uuid} cannot set its uid to #{new_uid}, because the uid is taken in the district by another gear #{$sender_hash[server_id][new_uid]} on node #{server_id}.")
    end
  }
  if district["available_uids"].include? new_uid
    # check and reserve the uid with the district
    if !OpenShift::DataStore.instance.reserve_district_uid(district["uuid"], new_uid)
      raise Exception.new("Could not reserve uid #{new_uid} on district #{district["name"]} (#{district["uuid"]}).")
    end
  end

  return 
end

mongo_hash = {}
query = {"$or" => [{"apps.group_instances.gears.0" => {"$exists" => true}}, {"consumed_gears" => {"$ne" => 0}}]}
options = {:fields => ["apps.group_instances.gears.uuid", "apps.group_instances.gears.uid"], :timeout => false}
ret = []
OpenShift::DataStore.instance.user_collection.find(query, options) do |mcursor|
  mcursor.each do |hash|
    hash['apps'].each { |app|
      app['group_instances'].each { |gi|
        if gi['gears']
          gi['gears'].each { |gear|
            mongo_hash[gear['uuid']] = gear['uid']
          }
        end
      } if app['group_instances']
    } if hash['apps']
  end
end

node_hash, $sender_hash = OpenShift::ApplicationContainerProxy.get_all_gears
no_error = true

fail_summary = []
cleanup_summary = []
nil_summary = []
numerify_uid_summary = []
numerify_uid_fail_summary = []
# now check
mongo_hash.each { |gear_uuid,gear_uid|
  if not node_hash.has_key? gear_uuid
    nil_summary << gear_uuid
    next
  end
  node_info = node_hash[gear_uuid]
  actual_uid = node_info[1]
  if gear_uid != actual_uid
    app, gear = Application::find_by_gear_uuid(gear_uuid)
    msg = "Gear '#{gear_uuid}' in app #{app.name} for user '#{app.domain.owner.login}', needs its uid to be set from '#{gear_uid}' to '#{actual_uid}'..."
    begin
      check_gear_uid(gear, actual_uid)
      gear.uid = actual_uid
      app.save
      msg += "done.\n"
      cleanup_summary << msg
    rescue Exception => e
      msg += "failed. Reason - #{e.message}\n"
      fail_summary << msg
    end
  end
  if gear_uid.class == String
    begin
      app, gear = Application::find_by_gear_uuid(gear_uuid)
      msg = "Gear '#{gear_uuid}' in app #{app.name} for user '#{app.domain.owner.login}', needs its uid converted from String to Integer..."
      gear.uid = Integer(gear_uid)
      app.save
      msg += "done.\n"
      numerify_uid_summary << msg
    rescue Exception =>e
      msg += "failed. Because of #{e.message}\n"
      numerify_uid_fail_summary << msg
    end
  end
}

exitstatus = 0
if cleanup_summary.length > 0
  print "Gear UID cleanup summary : \n#{cleanup_summary}\n"
else
  print "No gears were cleaned up.\n"
end

if nil_summary.length > 0
  print "The following gears had 'nil' uid, but could not be fixed still:\n#{nil_summary.join("\n")}\n"
  exitstatus = 1
end

if fail_summary.length > 0
  print "The following gears needed a fix on their uid, but could not be fixed still:\n#{fail_summary.join("\n")}\n"
  exitstatus = 1
end

if numerify_uid_summary.length > 0
  print "The following gears converted their uids from String to Integer and succeeded: \n#{numerify_uid_summary}\n"
else
  print "No gears required their uids to be converted from String to Integer!\n"
end

if numerify_uid_fail_summary.length > 0
  print "The following gears converted their uids from String to Integer but FAILED: \n#{numerify_uid_fail_summary}\n"
  exitstatus = 1
end

exit exitstatus

