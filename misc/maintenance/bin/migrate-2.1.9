#!/usr/bin/env ruby
# Usage: ./migrate-2.1.9 > out.txt
require 'rubygems'
require 'openshift'
require 'pp'

include Libra

RHLOGINS = nil #['rhlogin']
MAX_THREADS = 10

#
#  Migrate the specified app on the node
#

#
#  Migrate the specified app on the node
#
def migrate_app_on_node(server_identity, framework, uuid, namespace, app_name)
  migrate_cmd = "#{__FILE__} '#{server_identity}' '#{framework}' '#{uuid}' '#{namespace}' '#{app_name}'"
  puts "Migrating app on node with: #{migrate_cmd}"
  migrated = false
  Helper.rpc_exec('libra', server_identity) do |client|
    client.migrate(:uuid => uuid,
                   :application => app_name,
                   :app_type => framework,
                   :namespace => namespace,
                   :version => '2.1.9') do |response|
      exit_code = response[:body][:data][:exitcode]
      output = response[:body][:data][:output]
      if (output.length > 0)
        puts "Migrate on node output: #{output}"
      end
      if exit_code != 0
        puts "Migrate on node exit code: #{exit_code}"
        raise "Failed migrating app. Rerun with: #{migrate_cmd}"
      else
        migrated = true
      end
    end
  end
  raise "Migrate on node failed.  Rerun with: #{migrate_cmd}" if !migrated
end

#
# Migrate applications between 2.1.8a and 2.1.9
#
def migrate
  start_time = Time.now.to_i
  puts "Getting all RHLogins..." 
  all_rhlogins = RHLOGINS || User.find_all_rhlogins
  all_rhlogins_length = all_rhlogins.length
  @app_cnt = 0
  puts "RHLogins.length: #{all_rhlogins_length.to_s}"
  node_to_apps = {}
  node_to_users = {}
  s3_queues = []
  all_rhlogins.each_with_index do |rhlogin, index|
    queue_index = index % MAX_THREADS
    s3_queues[queue_index] = [] unless s3_queues[queue_index]
    s3_queues[queue_index].push(rhlogin)
  end
  rhlogin_cnt = 0
  s3_threads = []
  s3_queues.each do |rhlogins|
    s3_threads << Thread.new do
      rhlogins.each do |rhlogin|
        user = User.find(rhlogin)
        if user
          puts "Gathering apps for user: #{user.rhlogin}(#{all_rhlogins_length - rhlogin_cnt}) with uuid: #{user.uuid}"
          apps = user.apps
          apps.each do |app_name, app|
            @app_cnt += 1
            server_identity = app['server_identity']
            node_to_apps[server_identity] = [] unless node_to_apps[server_identity]
            node_to_users[server_identity] = [] unless node_to_users[server_identity]
            node_to_apps[server_identity] << {:name => app_name, :app => app}
            node_to_users[server_identity] << user
          end
        else
          puts "WARNING:  Couldn't find user: #{rhlogin}"
        end
        rhlogin_cnt += 1
      end
    end
  end
  s3_threads.each do |t|
    t.join
  end
  
  all_apps_length = @app_cnt

  app_cnts = []
  thread_groups = []
  node_to_apps.each do |server_identity, apps|
    if thread_groups.length < MAX_THREADS
      thread_groups << [{server_identity => apps}]
      app_cnts << apps.length
    else
      min_pos = 0
      min = app_cnts[0]
      app_cnts.each_with_index do |cnt, index|
        if cnt < min
          min = cnt
          min_pos = index
        end
      end
      thread_groups[min_pos] << {server_identity => apps}
      app_cnts[min_pos] += apps.length
    end
  end
  node_to_apps = nil
  
  puts "#####################################################"
  puts 'Application Counts Per Thread:'
  puts app_cnts.pretty_inspect
  puts "#####################################################"

  @failures = []
  node_threads = []
  thread_groups.each do |thread_group|
    node_threads << Thread.new do
      thread_group.each do |node_to_apps|
        node_to_apps.each do |server_identity, apps|
          migrate_node(server_identity, apps, node_to_users)
        end
      end
    end
  end

  node_threads.each do |t|
    t.join
  end
  
  puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  puts "Failures:"
  @failures.each do |failure|
    puts failure
  end
  puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  puts ""
  puts "#####################################################"
  puts "Summary:"
  puts "# of users: #{all_rhlogins_length}"
  puts "# of apps: #{all_apps_length}"
  puts "# of failures: #{@failures.length}"
  puts "Application counts per thread: #{app_cnts.pretty_inspect}"

  end_time = Time.now.to_i
  total_time = end_time-start_time
  puts "Total execution time: #{total_time.to_s}s"
  puts "#####################################################"
end

def migrate_node(server_identity, apps, node_to_users)
  puts "Migrating #{apps.length} apps on node #{server_identity}"
  users = node_to_users[server_identity]
  apps.each_with_index do |app_hash, index|
    app = app_hash[:app]
    app_name = app_hash[:name]
    user = users[index]
    rhlogin = user.rhlogin
    migrate_on_node_cmd = "#{__FILE__} '#{app['server_identity']}' '#{app['framework']}' '#{app['uuid']}' '#{user.namespace}' '#{app_name}'"
    begin
      puts "Migrating app '#{app_name}'(#{@app_cnt}) with uuid '#{app['uuid']}' on node '#{app['server_identity']}' for user: #{rhlogin}"
      @app_cnt -= 1
      num_tries = 2
      (1..num_tries).each do |i|
        output, exit_code = execute_script(migrate_on_node_cmd)
        puts output
        if (exit_code != 0)
          puts "Migrate on node exit_code: #{exit_code}"
          if (exit_code == 1)
            if i == num_tries
              puts "Failed to migrate with cmd: '#{migrate_on_node_cmd}' after #{num_tries} tries"
              @failures << migrate_on_node_cmd
              break
            else
              sleep 10
            end
          else
            puts "Failed to migrate with cmd: '#{migrate_on_node_cmd}'"
            @failures << migrate_on_node_cmd
            break
          end
        else
          break
        end
      end
    rescue Exception => e
      puts "ERROR: Failed migrating app: #{app_name} with uuid: #{app['uuid']} on node '#{app['server_identity']}' for user: #{rhlogin}"
      @failures << migrate_on_node_cmd
      puts e.message
      puts e.backtrace
    end
  end
end

def execute_script(cmd)
  num_tries = 3
  exitcode = nil
  output = ''
  (1..num_tries).each do |i|
    read, write = IO.pipe
    pid = fork {
        # child
        $stdout.reopen write
        read.close
        exec(cmd)
    }
    # parent
    write.close
    read.each do |line|
        output << line
    end
    begin
      Timeout::timeout(60) do
        Process.waitpid(pid)
        exitcode = $?.exitstatus
      end
      break
    rescue Timeout::Error
      begin
        Process.kill("TERM", pid)
      rescue Exception => e
        puts "execute_script: WARNING - Failed to kill cmd: '#{cmd}' with message: #{e.message}"
      end
      puts "Command '#{cmd}' timed out"
      raise if i == num_tries
    end
  end
  return output, exitcode
end

if ARGV.length == 5
  migrate_app_on_node(ARGV[0], ARGV[1], ARGV[2], ARGV[3], ARGV[4])
else
  migrate
end
