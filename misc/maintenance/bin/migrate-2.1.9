#!/usr/bin/env ruby
# Usage: ./migrate-2.1.9 > out.txt
require 'rubygems'
require 'openshift'
require 'pp'
require 'open4'

include Libra

RHLOGINS = nil #['rhlogin']
MAX_THREADS = 6

#
#  Migrate the specified app on the node
#

#
#  Migrate the specified app on the node
#
def migrate_app_on_node(server_identity, framework, uuid, namespace, app_name)
  migrate_cmd = "#{__FILE__} '#{server_identity}' '#{framework}' '#{uuid}' '#{namespace}' '#{app_name}'"
  puts "Migrating app on node with: #{migrate_cmd}"
  migrated = false
  Helper.rpc_exec('libra', server_identity) do |client|
    client.migrate(:uuid => uuid,
                   :application => app_name,
                   :app_type => framework,
                   :namespace => namespace,
                   :version => '2.1.9') do |response|
      exit_code = response[:body][:data][:exitcode]
      output = response[:body][:data][:output]
      if (output.length > 0)
        puts "Migrate on node output: #{output}"
      end
      if exit_code != 0
        puts "Migrate on node exit code: #{exit_code}"
        raise "Failed migrating app. Rerun with: #{migrate_cmd}"
      else
        migrated = true
      end
    end
  end
  raise "Migrate on node failed.  Rerun with: #{migrate_cmd}" if !migrated
end

#
# Migrate applications between 2.1.8a and 2.1.9
#
def migrate
  start_time = Time.now.to_i
  puts "Getting all RHLogins..." 
  all_rhlogins = RHLOGINS || User.find_all_rhlogins
  all_rhlogins_length = all_rhlogins.length
  @app_cnt = 0
  puts "RHLogins.length: #{all_rhlogins_length.to_s}"
  node_to_apps = {}
  node_to_users = {}
  s3_queues = []
  all_rhlogins.each_with_index do |rhlogin, index|
    queue_index = index % MAX_THREADS
    s3_queues[queue_index] = [] unless s3_queues[queue_index]
    s3_queues[queue_index].push(rhlogin)
  end
  rhlogin_cnt = 0
  s3_threads = []
  s3_queues.each do |rhlogins|
    s3_threads << Thread.new do
      rhlogins.each do |rhlogin|
        user = User.find(rhlogin)
        if user
          puts ""
          puts "######################################################"
          puts "Gathering apps for user: #{user.rhlogin}(#{all_rhlogins_length - rhlogin_cnt}) with uuid: #{user.uuid}"
          apps = user.apps
          apps.each do |app_name, app|
            @app_cnt += 1
            server_identity = app['server_identity']
            node_to_apps[server_identity] = [] unless node_to_apps[server_identity]
            node_to_users[server_identity] = [] unless node_to_users[server_identity]
            node_to_apps[server_identity] << {:name => app_name, :app => app}
            node_to_users[server_identity] << user
          end
        else
          puts "WARNING:  Couldn't find user: #{rhlogin}"
        end
        rhlogin_cnt += 1
      end
    end
  end
  s3_threads.each do |t|
    t.join
  end

  app_cnts = []
  thread_groups = []
  node_to_apps.each do |server_identity, apps|
    if thread_groups.length < MAX_THREADS
      thread_groups << [{server_identity => apps}]
      app_cnts << apps.length
    else
      min_pos = 0
      min = app_cnts[0]
      app_cnts.each_with_index do |cnt, index|
        if cnt < min
          min = cnt
          min_pos = index
        end
      end
      thread_groups[min_pos] << {server_identity => apps}
      app_cnts[min_pos] += apps.length
    end
  end
  node_to_apps = nil
  
  puts '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
  puts 'Application Counts Per Thread:'
  puts app_cnts.pretty_inspect
  puts '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'

  node_threads = []
  thread_groups.each do |thread_group|
    node_threads << Thread.new do
      thread_group.each do |node_to_apps|
        node_to_apps.each do |server_identity, apps|
          migrate_node(server_identity, apps, node_to_users)
        end
      end
    end
  end

  node_threads.each do |t|
    t.join
  end

  end_time = Time.now.to_i
  total_time = end_time-start_time
  puts "Total execution time: #{total_time.to_s}s"
end

def migrate_node(server_identity, apps, node_to_users)
  puts "Migrating #{apps.length} apps on node #{server_identity}: #{apps.pretty_inspect}"
  users = node_to_users[server_identity]
  apps.each_with_index do |app_hash, index|
    app = app_hash[:app]
    app_name = app_hash[:name]
    user = users[index]
    rhlogin = user.rhlogin
    begin
      puts "Migrating app '#{app_name}'(#{@app_cnt}) with uuid '#{app['uuid']}' on node '#{app['server_identity']}' for user: #{rhlogin}"
      @app_cnt -= 1
      migrate_on_node_cmd = "#{__FILE__} '#{app['server_identity']}' '#{app['framework']}' '#{app['uuid']}' '#{user.namespace}' '#{app_name}'"
      output, exit_code = execute_script(migrate_on_node_cmd)
      puts output
      puts "Migrate on node exit_code: #{exit_code}"
    rescue Exception => e
      puts "ERROR: Failed migrating app: #{app_name} with uuid: #{app['uuid']} on node '#{app['server_identity']}' for user: #{rhlogin}"
      puts e.message
      puts e.backtrace
    end
  end
end

def execute_script(cmd)
  num_tries = 3
  exitcode = nil
  output = ''
  (1..num_tries).each do |i|
    pid, stdin, stdout, stderr = Open4::popen4(cmd)
    stdin.close
    begin
      Timeout::timeout(60) do
        ignored, status = Process::waitpid2 pid
        exitcode = status.exitstatus
      end
      begin
        Timeout::timeout(5) do
          while (line = stdout.gets)
            output << line
          end
        end
      rescue Timeout::Error
        puts ("execute_script: WARNING - stdout read timed out")
      end
      break
    rescue Timeout::Error
      puts "Command '#{cmd}' timed out"
      raise if i == num_tries
    end
  end
  return output, exitcode
end

if ARGV.length == 5
  migrate_app_on_node(ARGV[0], ARGV[1], ARGV[2], ARGV[3], ARGV[4])
else
  migrate
end
