#!/usr/bin/env ruby
require 'rubygems'
require 'pp'
require 'thread'
require 'thread-dump'
require 'getoptlong'
require 'stringio'

RHLOGINS = nil #['rhlogin']
MAX_THREADS = 10
WORK_DIR = '/tmp/rhc/migration'

STDOUT.sync, STDERR.sync = true

#
#  Migrate the specified gear
#
def migrate_gear(rhlogin, app_name, gear_uuid, version)
  migrate_cmd = "#{__FILE__} --rhlogin '#{rhlogin}' --migrate-gear '#{gear_uuid}' --app-name '#{app_name}' --version '#{version}'"
  out = StringIO.new
  out << "Migrating gear on node with: #{migrate_cmd}\n"
  migrated = false
  begin
    user = CloudUser.find(rhlogin)
    if user
      app = Application.find(user, app_name)
      if app
        gear = nil
        app.gears.each do |app_gear|
          if app_gear.uuid == gear_uuid
            gear = app_gear
            break
          end
        end
        if gear
          server_identity = gear.server_identity
          begin
            Timeout::timeout(360) do
              GearChanger::MCollectiveApplicationContainerProxy.rpc_exec('libra', server_identity) do |client|
                client.migrate(:uuid => gear_uuid,
                               :namespace => app.domain.namespace,
                               :version => version) do |response|
                  exit_code = response[:body][:data][:exitcode]
                  output = response[:body][:data][:output]
                  if (output.length > 0)
                    out << "Migrate on node output: #{output}\n"
                  end
                  if exit_code != 0
                    out << "Migrate on node exit code: #{exit_code}\n"
                    raise "Failed migrating gear. Rerun with: #{migrate_cmd}"
                  else
                    #redeploy_httpd_proxy(gear, out)
                    migrated = true
                    if migrated
                      gear.configured_components.each do |comp_name|
                        if comp_name == '@@app/cart-jenkins-1.4'
                          component = app.comp_instance_map[comp_name]
                          restart_component(gear, component, out)
                        end
                      end
                    end
                  end
                end
              end
            end
          rescue Timeout::Error
            raise "Command '#{migrate_cmd}' timed out"
          end
        else
          out << "WARNING: Gear not found with uuid #{gear_uuid} for app '#{app_name}' and user '#{rhlogin}'\n"
          migrated = true
        end
      else
        raise "App not found: #{app_name}"
      end
    else
      raise "User not found: #{rhlogin}"
    end 
    raise "Migrate on node failed.  Rerun with: #{migrate_cmd}" if !migrated
  rescue Exception => e
    raise "#{e.message}\n#{e.backtrace}\nOutput:\n#{out.string}"
  end
  out.string
end

def restart_component(gear, component, out)
  leave_stopped = false
  reply = gear.status(component)
  reply.cart_commands.each do |command_item|
    case command_item[:command]
    when "ATTR"
      key = command_item[:args][0]
      value = command_item[:args][1]
      if key == 'status'
        case value
        when "ALREADY_STOPPED"
          leave_stopped = true
        when "ALREADY_IDLED"
          leave_stopped = true
        end
      end
    end
  end
  unless leave_stopped
    begin
      out << "Stopping gear '#{gear.name}' with uuid '#{gear.uuid}' on node '#{gear.server_identity}'\n"
      reply.append gear.stop(component)
    rescue Exception => e
      out << "WARNING: Error stopping gear '#{gear.name}' with uuid '#{gear.uuid}' on node '#{gear.server_identity}': #{e.message}\n"
    end
    begin
      out << "Force stopping gear '#{gear.name}' with uuid '#{gear.uuid}' on node '#{gear.server_identity}'\n"
      reply.append gear.force_stop(component)
    rescue Exception => e
      out << "WARNING: Error force stopping gear '#{gear.name}' with uuid '#{gear.uuid}' on node '#{gear.server_identity}': #{e.message}\n"
    end
    num_tries = 2
    (1..num_tries).each do |i|
      out << "Restarting gear '#{gear.name}' with uuid '#{gear.uuid}' on node '#{gear.server_identity}'\n"
      begin
        reply.append gear.restart(component)
        break
      rescue Exception => e
        if i == num_tries
          out << "Failed to restart '#{gear.name}' with uuid '#{gear.uuid}' on node '#{gear.server_identity}' after #{num_tries} tries with exception: #{e.message}\n"
          raise
        end
      end
    end    
  else
    out << "Leaving gear stopped '#{gear.name}' with uuid '#{gear.uuid}' on node '#{gear.server_identity}'\n"
  end
  out << "RESTART DEBUG OUTPUT:\n#{reply.debugIO.string}\n" unless reply.debugIO.string.empty?
  out << "RESTART ERROR OUTPUT:\n#{reply.errorIO.string}\n" unless reply.errorIO.string.empty?
end

def redeploy_httpd_proxy(gear, out)
  gear.configured_components.each do |comp_name|
    component = gear.app.comp_instance_map[comp_name]
    out << "Redeploying httpd proxy for '#{component.parent_cart_name}' on gear '#{gear.name}' with uuid '#{gear.uuid}' on node #{gear.server_identity}\n"
    embedded = gear.app.embedded.include?(component.parent_cart_name)
    reply = gear.app.container.send(:run_cartridge_command, (embedded ? "embedded/" : '') + component.parent_cart_name, gear.app, gear, 'deploy-httpd-proxy', nil, false)

    out << "DEPLOY_HTTP_PROXY DEBUG OUTPUT:\n#{reply.debugIO.string}\n" unless reply.debugIO.string.empty?
    out << "DEPLOY_HTTP_PROXY ERROR OUTPUT:\n#{reply.errorIO.string}\n" unless reply.errorIO.string.empty?
    
    if reply.exitcode != 0
      out << "Deploy httpd proxy for cart: #{component.parent_cart_name} on node exit code: #{reply.exitcode}\n"
      raise "Failed deploying httpd proxy for gear '#{gear.name}' with uuid '#{gear.uuid}' on node '#{gear.server_identity}'"
    end
  end
    
  unless gear.app.aliases.nil?
    gear.app.aliases.each do |server_alias|
      out << "Adding alias '#{server_alias}' for '#{gear.name}' with uuid '#{gear.uuid}' on node #{gear.server_identity}\n"
      reply = gear.add_alias(server_alias)
      out << "ADD_ALIAS DEBUG OUTPUT:\n#{reply.debugIO.string}\n" unless reply.debugIO.string.empty?
      out << "ADD_ALIAS ERROR OUTPUT:\n#{reply.errorIO.string}\n" unless reply.errorIO.string.empty?
      if reply.exitcode != 0
        out << "Add alias on node exit code: #{reply.exitcode}\n"
        raise "Failed adding alias #{server_alias} for gear '#{gear.name}' with uuid '#{gear.uuid}' on node '#{gear.server_identity}'"
      end
    end
  end
end

def migrate(version, continue=false, target_server_identity=nil, migrate_position=1, num_migrators=1)
  start_time = Time.now.to_i
  puts "Getting all RHLogins..."
  users = []
  if RHLOGINS
    RHLOGINS.each do |rhlogin|
      user = CloudUser.find(rhlogin)
      if user
        users << user
      else
        puts "WARNING:  Couldn't find user: #{rhlogin}"
      end
    end
  else
    users = CloudUser.find_all(nil)
  end
  all_rhlogins_length = users.length
  gear_cnt = 0
  puts "RHLogins.length: #{all_rhlogins_length.to_s}"
  
  node_to_gears = {}
  ds_queues = []
  users.each_with_index do |user, index|
    queue_index = index % MAX_THREADS
    ds_queues[queue_index] = [] unless ds_queues[queue_index]
    ds_queues[queue_index].push(user)
  end
  ds_threads = []
  mutex = Mutex.new
  ds_queues.each do |users|
    ds_threads << Thread.new do
      users.each do |user|
        puts "Gathering gears for user: #{user.login} with uuid: #{user.uuid}"
        apps = user.applications
        apps.each do |app|
          gears = app.gears
          if gears && !gears.empty?
            gears.each do |gear|
              server_identity = gear.server_identity
              if (!target_server_identity || (server_identity == target_server_identity))
                mutex.synchronize do
                  node_to_gears[server_identity] = [] unless node_to_gears[server_identity]
                  node_to_gears[server_identity] << gear
                end
              end
            end
          else
            puts "ERROR: Gear not found for app: '#{app.name}' of user #{user.login}"
          end
        end
      end
    end
  end
  ds_threads.each do |t|
    t.join
  end
  
  position = migrate_position - 1
  migrator_position_nodes = []
  if num_migrators > 1
    server_identities = node_to_gears.keys.sort 
    server_identities.each_with_index do |server_identity, index|
      if index == position
        migrator_position_nodes << server_identity
        position += num_migrators
      else
        node_to_gears.delete(server_identity)
      end
    end
  end

  gear_cnts = []
  thread_groups = []
  node_to_gears.each do |server_identity, gears|
    gear_cnt += gears.length
    if thread_groups.length < MAX_THREADS
      thread_groups << [{server_identity => gears}]
      gear_cnts << gears.length
    else
      min_pos = 0
      min = gear_cnts[0]
      gear_cnts.each_with_index do |cnt, index|
        if cnt < min
          min = cnt
          min_pos = index
        end
      end
      thread_groups[min_pos] << {server_identity => gears}
      gear_cnts[min_pos] += gears.length
    end
  end
  node_to_gears = nil
  
  puts "#####################################################"
  puts 'Gear counts per thread:'
  puts gear_cnts.pretty_inspect
  if migrator_position_nodes
    puts 'Nodes this migrator is handling:'
    puts migrator_position_nodes.pretty_inspect
  end
  puts "#####################################################"
  
  thread_groups.each do |thread_group|
    thread_group.each do |node_to_gears|
      node_to_gears.each do |server_identity, gears|
        write_node_to_file(server_identity, gears, version) unless continue
        node_to_gears[server_identity] = nil
      end
    end
  end

  @failures = []
  node_threads = []
  thread_groups.each do |thread_group|
    node_threads << Thread.new do
      thread_group.each do |node_to_gears|
        node_to_gears.each do |server_identity, gears|
          migrate_node(server_identity, continue)
        end
      end
    end
  end

  node_threads.each do |t|
    t.join
  end
  
  if @failures.length > 0
    puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    puts "Failures:"
    @failures.each do |failure|
      puts failure
    end
    puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    puts ""
  end

  nodes_to_gears.each do |server_identity, gears|
    f = migrate_file_path(server_identity)
    leftover_count = `wc -1 #{f}`.to_i
    if leftover_count > 0
      puts "!!!!!!!!!!WARNING!!!!!!!!!!!!!WARNING!!!!!!!!!!!!WARNING!!!!!!!!!!"
      puts "#{leftover_count} leftover gears found in migrate file: #{f}"
      puts "You can run with --continue to try again"
      puts "!!!!!!!!!!WARNING!!!!!!!!!!!!!WARNING!!!!!!!!!!!!WARNING!!!!!!!!!!"
      puts ""
    end
  end
  
  puts "#####################################################"
  puts "Summary:"
  puts "# of users: #{all_rhlogins_length}"
  puts "# of gears: #{gear_cnt}"
  puts "# of failures: #{@failures.length}"
  puts "Gear counts per thread: #{gear_cnts.pretty_inspect}"
  puts "Nodes migrated: #{migrator_position_nodes.pretty_inspect}"

  end_time = Time.now.to_i
  total_time = end_time-start_time
  puts "Total execution time: #{total_time.to_s}s"
  puts "#####################################################"
end

def write_node_to_file(server_identity, gears, version)
  f = migrate_file_path(server_identity)
  puts "Writing #{gears.length} gears for node #{server_identity} to file #{f}"
  FileUtils.mkdir_p WORK_DIR
  FileUtils.rm_f f
  FileUtils.touch f
  gears.each_with_index do |gear, index|
    user = gear.app.user
    rhlogin = user.login
    migrate_on_node_args = "#{gear.server_identity},#{gear.uuid},#{gear.name},#{gear.app.name},#{rhlogin},#{version}"
    append_to_file(f, migrate_on_node_args)
  end
end

def error_file_path(server_identity)
  "#{WORK_DIR}/migrate_errors_#{server_identity}"
end

def log_file_path(server_identity)
  "#{WORK_DIR}/migrate_log_#{server_identity}"
end

def migrate_file_path(server_identity)
  "#{WORK_DIR}/migrate_#{server_identity}"
end

def migrate_node(server_identity, continue)
  puts "Migrating gears on node #{server_identity}"
  error_file = error_file_path(server_identity)
  FileUtils.rm_f error_file unless continue
  FileUtils.touch error_file
  log_file = log_file_path(server_identity)
  FileUtils.rm_f log_file unless continue
  FileUtils.touch log_file
  f = migrate_file_path(server_identity)
  migrate_node_cmd = "#{__FILE__} --migrate-file '#{f}'"
  output, exit_code = execute_script(migrate_node_cmd)
  puts output
  file = File.open(error_file, "r")
  begin
    while (line = file.readline)
      @failures << line.chomp
    end
  rescue EOFError
    file.close
  end
  file = File.open(log_file, "r")
  begin
    while (line = file.readline)
      print line
    end
  rescue EOFError
    file.close
  end
end

def migrate_from_file(file)
  while true
    line = File.open(file, &:gets)
    if line && !line.empty?
      params = line.chomp.split(',')
      server_identity = params[0] 
      gear_uuid = params[1]
      gear_name = params[2]
      app_name = params[3]
      rhlogin = params[4]
      version = params[5]
      migrate_on_node_cmd = "#{__FILE__} --rhlogin '#{rhlogin}' --migrate-gear '#{gear_uuid}' --app-name '#{app_name}' --version '#{version}'"
      error_file = error_file_path(server_identity)
      log_file = log_file_path(server_identity)
      append_to_file(log_file,  "Migrating app '#{app_name}' gear '#{gear_name}' with uuid '#{gear_uuid}' on node '#{server_identity}' for user: #{rhlogin}")
      num_tries = 2
      (1..num_tries).each do |i|
        begin
          output = migrate_gear(rhlogin, app_name, gear_uuid, version)
          append_to_file(log_file, output)
          break
        rescue Exception => e
          if i == num_tries
            append_to_file(log_file, "Failed to migrate with cmd: '#{migrate_on_node_cmd}' after #{num_tries} tries with exception: #{e.message}")
            append_to_file(error_file, migrate_on_node_cmd)
            break
          else
            if StickShift::DataStore.instance.find(Application.name, rhlogin, app_name)
              sleep 4
            else
              append_to_file(log_file, "App '#{app_name}' no longer found in datastore with uuid '#{gear_uuid}'.  Ignoring...")
              break
            end
          end
        end
      end
      `sed -i '1,1d' #{file}`
    else
      break
    end
  end
end

def self.append_to_file(f, value)
  file = File.open(f, 'a')
  begin
    file.puts value
  ensure
    file.close
  end
end

def execute_script(cmd, num_tries=1, timeout=28800)
  exitcode = nil
  output = ''
  (1..num_tries).each do |i|
    pid = nil
    begin
      Timeout::timeout(timeout) do
        read, write = IO.pipe
        pid = fork {
          # child
          $stdout.reopen write
          read.close
          exec(cmd)
        }
        # parent
        write.close
        read.each do |line|
          output << line
        end
        Process.waitpid(pid)
        exitcode = $?.exitstatus
      end
      break
    rescue Timeout::Error
      begin
        Process.kill("TERM", pid) if pid
      rescue Exception => e
        puts "execute_script: WARNING - Failed to kill cmd: '#{cmd}' with message: #{e.message}"
      end
      puts "Command '#{cmd}' timed out"
      raise if i == num_tries
    end
  end
  return output, exitcode
end

def p_usage
    puts <<USAGE

Usage: #{$0}

  --rhlogin rhlogin                    User rhlogin
  --migrate-gear gear_uuid             Gear uuid of the single gear to migrate
  --app-name app_name                  App name of the gear to migrate
  --migrate-node server_identity       Server identity of the node to migrate
  --migrate-file file                  File containing the gears to migrate
  --num-migrators num                  The total number of migrators to be run.  Each migrate-position will be a 
                                       migrate-position of num-migrators.  All positions must to taken to migrate
                                       all gears.  Ex: If you are going to run 2 migrators you would need to run:
                                       ./migrate --version <version> --position 1 --num-migrators 2
                                       ./migrate --version <version> --position 2 --num-migrators 2
  --migrate-position position          Postion of this migrator (1 based) amongst the num of migrators (--num_migrators)
  --continue                           Flag indicating to continue a previous migration

USAGE
exit 255
end

begin
  opts = GetoptLong.new(
    ["--rhlogin", GetoptLong::REQUIRED_ARGUMENT],
    ["--migrate-gear", GetoptLong::REQUIRED_ARGUMENT],
    ["--app-name", GetoptLong::REQUIRED_ARGUMENT],
    ["--migrate-node", GetoptLong::REQUIRED_ARGUMENT],
    ["--migrate-file", GetoptLong::REQUIRED_ARGUMENT],
    ["--version", GetoptLong::REQUIRED_ARGUMENT],
    ["--num-migrators", GetoptLong::REQUIRED_ARGUMENT],
    ["--migrator-position", GetoptLong::REQUIRED_ARGUMENT],
    ["--continue", GetoptLong::NO_ARGUMENT],
    ["--help", "-h", GetoptLong::NO_ARGUMENT]
  )
  opt = {}
  opts.each do |o, a|
    opt[o[2..-1]] = a.to_s
  end
rescue Exception => e
  p_usage
end

if opt['help']
  p_usage
end

$:.unshift('/var/www/stickshift/broker')
require 'config/environment'

if opt['migrate-file']
  migrate_from_file(opt['migrate-file'])
elsif opt['migrate-gear']
  if opt['rhlogin'] && opt['app-name'] && opt['version']
    puts migrate_gear(opt['rhlogin'], opt['app-name'], opt['migrate-gear'], opt['version'])
  else
    puts "--rhlogin, --app-name, and --version is required with --migrate-gear"
    exit 255
  end
elsif opt['migrate-node']
  if opt['version']
    migrate_file = migrate_file_path(opt['migrate-node'])
    if opt['continue']
      migrate(opt['version'], true, opt['migrate-node'])
    elsif File.exists?(migrate_file)
        puts <<-WARNING
!!!!!!!!!!!!!!!!!!!! EXISTING MIGRATION DATA FOUND !!!!!!!!!!!!!!!!!!!!
Data from a previous migration exists at #{migrate_file}.  You must 
either move/remove (Ex: rm #{migrate_file}) that data or pick up
where it left off with '#{__FILE__} --migrate-node #{opt['migrate-node']} --version '#{opt['version']}' --continue'.
WARNING
        exit 1
    else
      migrate(opt['version'], false, opt['migrate-node'])
    end
  else
    puts "--version is required with --migrate-node"
    exit 255
  end
else
  if opt['version']
    num_migrators = opt['num-migrators']
    migrate_position = opt['migrate-position']
    if num_migrators || migrate_position
      unless num_migrators
        puts "--num-migrators is required with --migrate-position"
        exit 255
      end
      unless migrate_position
        puts "--migrate-position is required with --num-migrators"
        exit 255
      end
    else
      num_migrators = 1
      migrate_position = 1
    end
    if opt['continue']
      migrate(opt['version'], true, nil, migrate_position, num_migrators)
    elsif File.exists?("/tmp/rhc/migration")
      puts <<-WARNING
!!!!!!!!!!!!!!!!!!!! EXISTING MIGRATION DATA FOUND !!!!!!!!!!!!!!!!!!!!
Data from a previous migration exists at /tmp/rhc/migration.  You must 
either move/remove (Ex: rm -rf /tmp/rhc/migration) that data or pick up
where it left off with '#{__FILE__} --continue'.
WARNING
      exit 1
    else
      migrate(opt['version'], false, nil, migrate_position, num_migrators)
    end
  else
    puts "--version is required"
    exit 255
  end
end
