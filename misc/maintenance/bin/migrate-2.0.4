#!/usr/bin/env ruby
# Usage: ./migrate-2.0.4 > out.txt
$:.unshift('/var/www/libra/broker')
require 'config/environment'
require 'rubygems'
require 'pp'

RHLOGINS = nil #['rhlogin']
MAX_THREADS = 10
WORK_DIR = '/tmp/rhc/migration'

#
#  Migrate the specified app on the node
#
def migrate_app_on_node(server_identity, framework, uuid, rhlogin, app_name)
  migrate_cmd = "#{__FILE__} '#{server_identity}' '#{framework}' '#{uuid}' '#{rhlogin}' '#{app_name}'"
  puts "Migrating app on node with: #{migrate_cmd}"
  migrated = false
  user = CloudUser.find(rhlogin)
  if user
    app  = Application.find(user, app_name)
    if app
      Express::Broker::ApplicationContainerProxy.rpc_exec('libra', server_identity) do |client|
        client.migrate(:uuid => uuid,
                       :application => app_name,
                       :app_type => framework,
                       :namespace => user.namespace,
                       :version => '2.0.4') do |response|
          exit_code = response[:body][:data][:exitcode]
          output = response[:body][:data][:output]
          if (output.length > 0)
            puts "Migrate on node output: #{output}"
          end
          if exit_code != 0
            puts "Migrate on node exit code: #{exit_code}"
            raise "Failed migrating app. Rerun with: #{migrate_cmd}"
          else
            reply = app.container.send(:run_cartridge_command, framework, app, 'deploy-httpd-proxy', nil, false)
            
            puts "DEPLOY_HTTP_PROXY DEBUG OUTPUT:\n#{reply.debugIO.string}\n" unless reply.debugIO.string.empty?
            puts "DEPLOY_HTTP_PROXY ERROR OUTPUT:\n#{reply.errorIO.string}\n" unless reply.errorIO.string.empty?
    
            if reply.exitcode != 0
              puts "Deploy httpd proxy on node exit code: #{reply.exitcode}"
              raise "Failed deploying httpd proxy for app '#{app_name}' with uuid '#{uuid}' on node '#{server_identity}'"
            else
              deployed_httpd_proxy_success = true
              app.embedded.each do |cart, cart_info|
                puts "DEBUG: Deploying httpd proxy for embedded #{cart} for '#{app_name}' with uuid '#{uuid}' on node #{server_identity}"
                reply.append app.container.send(:run_cartridge_command, "embedded/" + cart, app, "deploy-httpd-proxy", nil, false)
                puts "DEPLOY_HTTP_PROXY DEBUG OUTPUT:\n#{reply.debugIO.string}\n" unless reply.debugIO.string.empty?
                puts "DEPLOY_HTTP_PROXY ERROR OUTPUT:\n#{reply.errorIO.string}\n" unless reply.errorIO.string.empty?
                if reply.exitcode != 0
                  puts "Deploy httpd proxy for cart: #{cart} on node exit code: #{reply.exitcode}"
                  deployed_httpd_proxy_success = false
                end
              end
              raise "Failed deploying httpd proxy for app '#{app_name}' with uuid '#{uuid}' on node '#{server_identity}'" unless deployed_httpd_proxy_success 
              migrated = true
            end
          end
        end
      end
    else
      puts "App not found: #{app_name}"
      exit 1
    end
  else
    puts "User not found: #{rhlogin}"
    exit 1
  end
  raise "Migrate on node failed.  Rerun with: #{migrate_cmd}" if !migrated
end

#
# Migrate applications between 2.0.3 and 2.0.4
#
def migrate
  start_time = Time.now.to_i
  puts "Getting all RHLogins..."
  users = []
  if RHLOGINS
    RHLOGINS.each do |rhlogin|
      user = CloudUser.find(rhlogin)
      if user
        users << user
      else
        puts "WARNING:  Couldn't find user: #{rhlogin}"
      end
    end
  else
    users = CloudUser.find_all(nil)
  end
  all_rhlogins_length = users.length
  app_cnt = 0
  puts "RHLogins.length: #{all_rhlogins_length.to_s}"
  node_to_apps = {}
  node_to_users = {}
  s3_queues = []
  users.each_with_index do |user, index|
    queue_index = index % MAX_THREADS
    s3_queues[queue_index] = [] unless s3_queues[queue_index]
    s3_queues[queue_index].push(user)
  end
  rhlogin_cnt = 0
  s3_threads = []
  s3_queues.each do |users|
    s3_threads << Thread.new do
      users.each do |user|
        puts "Gathering apps for user: #{user.login}(#{all_rhlogins_length - rhlogin_cnt}) with uuid: #{user.uuid}"
        apps = user.applications
        apps.each do |app|
          app_name = app.name
          server_identity = app.server_identity
          node_to_apps[server_identity] = [] unless node_to_apps[server_identity]
          node_to_users[server_identity] = [] unless node_to_users[server_identity]
          node_to_apps[server_identity] << {:name => app_name, :app => app}
          node_to_users[server_identity] << user
        end
        app_cnt += apps.length
        rhlogin_cnt += 1
      end
    end
  end
  s3_threads.each do |t|
    t.join
  end

  app_cnts = []
  thread_groups = []
  node_to_apps.each do |server_identity, apps|
    if thread_groups.length < MAX_THREADS
      thread_groups << [{server_identity => apps}]
      app_cnts << apps.length
    else
      min_pos = 0
      min = app_cnts[0]
      app_cnts.each_with_index do |cnt, index|
        if cnt < min
          min = cnt
          min_pos = index
        end
      end
      thread_groups[min_pos] << {server_identity => apps}
      app_cnts[min_pos] += apps.length
    end
  end
  node_to_apps = nil
  
  puts "#####################################################"
  puts 'Application Counts Per Thread:'
  puts app_cnts.pretty_inspect
  puts "#####################################################"

  @failures = []
  node_threads = []
  thread_groups.each do |thread_group|
    node_threads << Thread.new do
      thread_group.each do |node_to_apps|
        node_to_apps.each do |server_identity, apps|
          migrate_node(server_identity, apps, node_to_users)
        end
      end
    end
  end

  node_threads.each do |t|
    t.join
  end
  if @failures.length > 0
    puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    puts "Failures:"
    @failures.each do |failure|
      puts failure
    end
    puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    puts ""
  end
  puts "#####################################################"
  puts "Summary:"
  puts "# of users: #{all_rhlogins_length}"
  puts "# of apps: #{app_cnt}"
  puts "# of failures: #{@failures.length}"
  puts "Application counts per thread: #{app_cnts.pretty_inspect}"

  end_time = Time.now.to_i
  total_time = end_time-start_time
  puts "Total execution time: #{total_time.to_s}s"
  puts "#####################################################"
end

def migrate_node(server_identity, apps, node_to_users)
  puts "Migrating #{apps.length} apps on node #{server_identity}"
  users = node_to_users[server_identity]
  FileUtils.mkdir_p WORK_DIR
  error_file = "#{WORK_DIR}/migrate_errors_#{server_identity}"
  FileUtils.rm_f error_file
  FileUtils.touch error_file
  f = "#{WORK_DIR}/migrate_#{server_identity}"
  FileUtils.rm_f f
  FileUtils.touch f
  apps.each_with_index do |app_hash, index|
    app = app_hash[:app]
    app_name = app_hash[:name]
    user = users[index]
    rhlogin = user.login
    migrate_on_node_args = "#{app.server_identity},#{app.framework},#{app.uuid},#{rhlogin},#{app_name}"
    append_to_file(f, migrate_on_node_args)
  end
  migrate_node_cmd = "#{__FILE__} '#{f}'"
  output, exit_code = execute_script(migrate_node_cmd)
  puts output
  file = File.open(error_file, "r")
  begin
    while (line = file.readline)
      @failures << line.chomp
    end
  rescue EOFError
    file.close
  end
end

def migrate_from_file(file)
  file = File.open(file, "r")
  begin
    while (line = file.readline)
      params = line.chomp.split(',')
      server_identity = params[0] 
      framework = params[1]
      uuid = params[2] 
      rhlogin = params[3]
      app_name = params[4]
      migrate_on_node_cmd = "#{__FILE__} '#{server_identity}' '#{framework}' '#{uuid}' '#{rhlogin}' '#{app_name}'"
      error_file = "#{WORK_DIR}/migrate_errors_#{server_identity}"
      puts "Migrating app '#{app_name}' with uuid '#{uuid}' on node '#{server_identity}' for user: #{rhlogin}"
      num_tries = 2
      (1..num_tries).each do |i|
        begin
          migrate_app_on_node(server_identity, framework, uuid, rhlogin, app_name)
          break
        rescue Exception => e
          if i == num_tries
            puts "Failed to migrate with cmd: '#{migrate_on_node_cmd}' after #{num_tries} tries with exception: #{e.message}"
            append_to_file(error_file, migrate_on_node_cmd)
            break
          else
            if Cloud::Sdk::DataStore.instance.find(Application.name, rhlogin, app_name)
              sleep 4
            else
              puts "App '#{app_name}' no longer found in datastore with uuid '#{uuid}'.  Ignoring..."
              break
            end
          end
        end
      end
    end
  rescue EOFError
    file.close
  end
end

def self.append_to_file(f, value)
  file = File.open(f, 'a')
  begin
    file.puts value
  ensure
    file.close
  end
end

def execute_script(cmd)
  num_tries = 3
  exitcode = nil
  output = ''
  (1..num_tries).each do |i|
    pid = nil
    begin
      Timeout::timeout(60) do
        read, write = IO.pipe
        pid = fork {
          # child
          $stdout.reopen write
          read.close
          exec(cmd)
        }
        # parent
        write.close
        read.each do |line|
          output << line
        end
        Process.waitpid(pid)
        exitcode = $?.exitstatus
      end
      break
    rescue Timeout::Error
      begin
        Process.kill("TERM", pid) if pid
      rescue Exception => e
        puts "execute_script: WARNING - Failed to kill cmd: '#{cmd}' with message: #{e.message}"
      end
      puts "Command '#{cmd}' timed out"
      raise if i == num_tries
    end
  end
  return output, exitcode
end

if ARGV.length == 1
  migrate_from_file(ARGV[0])
elsif ARGV.length == 5
  migrate_app_on_node(ARGV[0], ARGV[1], ARGV[2], ARGV[3], ARGV[4])
else
  migrate
end
