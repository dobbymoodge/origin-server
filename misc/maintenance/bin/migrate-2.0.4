#!/usr/bin/env ruby
# Usage: ./migrate-2.0.4 > out.txt
$:.unshift('/var/www/libra/broker')
require 'config/environment'
require 'rubygems'
require 'pp'
require 'thread'
require 'thread-dump'

RHLOGINS = nil #['rhlogin']
MAX_THREADS = 10
WORK_DIR = '/tmp/rhc/migration'

#
#  Migrate the specified app on the node
#
def migrate_app_on_node(server_identity, framework, uuid, rhlogin, app_name)
  migrate_cmd = "#{__FILE__} '#{server_identity}' '#{framework}' '#{uuid}' '#{rhlogin}' '#{app_name}'"
  out =  "Migrating app on node with: #{migrate_cmd}\n"
  migrated = false
  begin
    user = CloudUser.find(rhlogin)
    if user
      app  = Application.find(user, app_name)
      if app
        begin
          Timeout::timeout(180) do
            Express::Broker::ApplicationContainerProxy.rpc_exec('libra', server_identity) do |client|
              client.migrate(:uuid => uuid,
                             :application => app_name,
                             :app_type => framework,
                             :namespace => user.namespace,
                             :version => '2.0.4') do |response|
                exit_code = response[:body][:data][:exitcode]
                output = response[:body][:data][:output]
                if (output.length > 0)
                  out += "Migrate on node output: #{output}\n"
                end
                if exit_code != 0
                  out += "Migrate on node exit code: #{exit_code}\n"
                  raise "Failed migrating app. Rerun with: #{migrate_cmd}"
                else
                  reply = app.container.send(:run_cartridge_command, framework, app, 'deploy-httpd-proxy', nil, false)
                  
                  out += "DEPLOY_HTTP_PROXY DEBUG OUTPUT:\n#{reply.debugIO.string}\n" unless reply.debugIO.string.empty?
                  out += "DEPLOY_HTTP_PROXY ERROR OUTPUT:\n#{reply.errorIO.string}\n" unless reply.errorIO.string.empty?
          
                  if reply.exitcode != 0
                    out += "Deploy httpd proxy on node exit code: #{reply.exitcode}\n"
                    raise "Failed deploying httpd proxy for app '#{app_name}' with uuid '#{uuid}' on node '#{server_identity}'"
                  else
                    deployed_httpd_proxy_success = true
                    app.embedded.each do |cart, cart_info|
                      out += "DEBUG: Deploying httpd proxy for embedded #{cart} for '#{app_name}' with uuid '#{uuid}' on node #{server_identity}\n"
                      reply.append app.container.send(:run_cartridge_command, "embedded/" + cart, app, "deploy-httpd-proxy", nil, false)
                      out += "DEPLOY_HTTP_PROXY DEBUG OUTPUT:\n#{reply.debugIO.string}\n" unless reply.debugIO.string.empty?
                      out += "DEPLOY_HTTP_PROXY ERROR OUTPUT:\n#{reply.errorIO.string}\n" unless reply.errorIO.string.empty?
                      if reply.exitcode != 0
                        out += "Deploy httpd proxy for cart: #{cart} on node exit code: #{reply.exitcode}\n"
                        deployed_httpd_proxy_success = false
                      end
                    end
                    raise "Failed deploying httpd proxy for app '#{app_name}' with uuid '#{uuid}' on node '#{server_identity}'" unless deployed_httpd_proxy_success
                    unless app.aliases.nil?
                      app.aliases.each do |server_alias|
                        app.container.add_alias(app, app.framework, server_alias)
                      end
                    end
                    migrated = true
                  end
                end
              end
            end
          end
        rescue Timeout::Error
          raise "Command '#{migrate_cmd}' timed out"
        end
      else
        raise  "App not found: #{app_name}"
      end
    else
      raise "User not found: #{rhlogin}"
    end 
    raise "Migrate on node failed.  Rerun with: #{migrate_cmd}" if !migrated
  rescue Exception => e
    raise "#{e.message}\n#{e.backtrace}\nOutput:\n#{out}"
  end
  out
end

#
# Migrate applications between 2.0.3 and 2.0.4
#
def migrate(continue=false)
  start_time = Time.now.to_i
  puts "Getting all RHLogins..."
  users = []
  if RHLOGINS
    RHLOGINS.each do |rhlogin|
      user = CloudUser.find(rhlogin)
      if user
        users << user
      else
        puts "WARNING:  Couldn't find user: #{rhlogin}"
      end
    end
  else
    users = CloudUser.find_all(nil)
  end
  all_rhlogins_length = users.length
  app_cnt = 0
  puts "RHLogins.length: #{all_rhlogins_length.to_s}"
  node_to_apps = {}
  node_to_users = {}
  ds_queues = []
  users.each_with_index do |user, index|
    queue_index = index % MAX_THREADS
    ds_queues[queue_index] = [] unless ds_queues[queue_index]
    ds_queues[queue_index].push(user)
  end
  ds_threads = []
  mutex = Mutex.new
  ds_queues.each do |users|
    ds_threads << Thread.new do
      users.each do |user|
        puts "Gathering apps for user: #{user.login} with uuid: #{user.uuid}"
        apps = user.applications
        apps.each do |app|
          app_name = app.name
          server_identity = app.server_identity
          mutex.synchronize do
            node_to_apps[server_identity] = [] unless node_to_apps[server_identity]
            node_to_users[server_identity] = [] unless node_to_users[server_identity]
            node_to_apps[server_identity] << {:name => app_name, :app => app}
            node_to_users[server_identity] << user
            app_cnt += 1
          end
        end
      end
    end
  end
  ds_threads.each do |t|
    t.join
  end

  app_cnts = []
  thread_groups = []
  node_to_apps.each do |server_identity, apps|
    if thread_groups.length < MAX_THREADS
      thread_groups << [{server_identity => apps}]
      app_cnts << apps.length
    else
      min_pos = 0
      min = app_cnts[0]
      app_cnts.each_with_index do |cnt, index|
        if cnt < min
          min = cnt
          min_pos = index
        end
      end
      thread_groups[min_pos] << {server_identity => apps}
      app_cnts[min_pos] += apps.length
    end
  end
  node_to_apps = nil
  
  puts "#####################################################"
  puts 'Application Counts Per Thread:'
  puts app_cnts.pretty_inspect
  puts "#####################################################"
  
  thread_groups.each do |thread_group|
    thread_group.each do |node_to_apps|
      node_to_apps.each do |server_identity, apps|
        write_node_to_file(server_identity, apps, node_to_users) unless continue
        node_to_apps[server_identity] = nil
      end
    end
  end
  
  node_to_users = nil

  @failures = []
  node_threads = []
  thread_groups.each do |thread_group|
    node_threads << Thread.new do
      thread_group.each do |node_to_apps|
        node_to_apps.each do |server_identity, apps|
          migrate_node(server_identity, continue)
        end
      end
    end
  end

  node_threads.each do |t|
    t.join
  end
  if @failures.length > 0
    puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    puts "Failures:"
    @failures.each do |failure|
      puts failure
    end
    puts "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    puts ""
  end
  puts "#####################################################"
  puts "Summary:"
  puts "# of users: #{all_rhlogins_length}"
  puts "# of apps: #{app_cnt}"
  puts "# of failures: #{@failures.length}"
  puts "Application counts per thread: #{app_cnts.pretty_inspect}"

  end_time = Time.now.to_i
  total_time = end_time-start_time
  puts "Total execution time: #{total_time.to_s}s"
  puts "#####################################################"
end

def write_node_to_file(server_identity, apps, node_to_users)
  f = "#{WORK_DIR}/migrate_#{server_identity}"
  puts "Writing #{apps.length} apps for node #{server_identity} to file #{f}"
  users = node_to_users[server_identity]
  FileUtils.mkdir_p WORK_DIR
  FileUtils.rm_f f
  FileUtils.touch f
  apps.each_with_index do |app_hash, index|
    app = app_hash[:app]
    app_name = app_hash[:name]
    user = users[index]
    rhlogin = user.login
    migrate_on_node_args = "#{app.server_identity},#{app.framework},#{app.uuid},#{rhlogin},#{app_name}"
    append_to_file(f, migrate_on_node_args)
  end
end

def migrate_node(server_identity, continue)
  puts "Migrating apps on node #{server_identity}"
  error_file = "#{WORK_DIR}/migrate_errors_#{server_identity}"
  FileUtils.rm_f error_file unless continue
  FileUtils.touch error_file
  log_file = "#{WORK_DIR}/migrate_log_#{server_identity}"
  FileUtils.rm_f log_file unless continue
  FileUtils.touch log_file
  f = "#{WORK_DIR}/migrate_#{server_identity}"
  migrate_node_cmd = "#{__FILE__} '#{f}'"
  output, exit_code = execute_script(migrate_node_cmd)
  puts output
  file = File.open(error_file, "r")
  begin
    while (line = file.readline)
      @failures << line.chomp
    end
  rescue EOFError
    file.close
  end
  file = File.open(log_file, "r")
  begin
    while (line = file.readline)
      print line
    end
  rescue EOFError
    file.close
  end
end

def migrate_from_file(file)
  while true
    line = File.open(file, &:gets)
    if line && !line.empty?
      params = line.chomp.split(',')
      server_identity = params[0] 
      framework = params[1]
      uuid = params[2]
      rhlogin = params[3]
      app_name = params[4]
      migrate_on_node_cmd = "#{__FILE__} '#{server_identity}' '#{framework}' '#{uuid}' '#{rhlogin}' '#{app_name}'"
      error_file = "#{WORK_DIR}/migrate_errors_#{server_identity}"
      log_file = "#{WORK_DIR}/migrate_log_#{server_identity}"
      append_to_file(log_file,  "Migrating app '#{app_name}' with uuid '#{uuid}' on node '#{server_identity}' for user: #{rhlogin}")
      num_tries = 2
      (1..num_tries).each do |i|
        begin
          output = migrate_app_on_node(server_identity, framework, uuid, rhlogin, app_name)
          append_to_file(log_file, output)
          
          break
        rescue Exception => e
          if i == num_tries
            append_to_file(log_file, "Failed to migrate with cmd: '#{migrate_on_node_cmd}' after #{num_tries} tries with exception: #{e.message}")
            append_to_file(error_file, migrate_on_node_cmd)
            break
          else
            if Cloud::Sdk::DataStore.instance.find(Application.name, rhlogin, app_name)
              sleep 4
            else
              append_to_file(log_file, "App '#{app_name}' no longer found in datastore with uuid '#{uuid}'.  Ignoring...")
              break
            end
          end
        end
      end
      `sed -i '1,1d' #{file}`
    else
      break
    end
  end
end

def self.append_to_file(f, value)
  file = File.open(f, 'a')
  begin
    file.puts value
  ensure
    file.close
  end
end

def execute_script(cmd, num_tries=1, timeout=28800)
  exitcode = nil
  output = ''
  (1..num_tries).each do |i|
    pid = nil
    begin
      Timeout::timeout(timeout) do
        read, write = IO.pipe
        pid = fork {
          # child
          $stdout.reopen write
          read.close
          exec(cmd)
        }
        # parent
        write.close
        read.each do |line|
          output << line
        end
        Process.waitpid(pid)
        exitcode = $?.exitstatus
      end
      break
    rescue Timeout::Error
      begin
        Process.kill("TERM", pid) if pid
      rescue Exception => e
        puts "execute_script: WARNING - Failed to kill cmd: '#{cmd}' with message: #{e.message}"
      end
      puts "Command '#{cmd}' timed out"
      raise if i == num_tries
    end
  end
  return output, exitcode
end

if ARGV.length == 1
  if ARGV[0] == '--continue'
    migrate(true)
  else
    migrate_from_file(ARGV[0])
  end
elsif ARGV.length == 5
  puts migrate_app_on_node(ARGV[0], ARGV[1], ARGV[2], ARGV[3], ARGV[4])
else
  migrate
end
