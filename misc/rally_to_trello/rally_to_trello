#!/usr/bin/env ruby

$LOAD_PATH.unshift(File.dirname(__FILE__) + '/lib') unless $LOAD_PATH.include?(File.dirname(__FILE__) + '/lib')

require 'config'

require 'rally_helper'
require 'trello'
require 'reverse_markdown'
require 'nokogiri'

require 'yaml'
require 'commander/import'

name="#{__FILE__}"

program :name, "Move From Rally To Trello"
program :version, "1.0.0"
program :description, "A script move to Trello from Rally"

# This loads the conf files and creates new objects
#   based on the specified classes
def load_conf(klass,args,single = false)
  if single
    klass.new(args)
  else
    Hash[*args.map do |key,val|
      [key,klass.new(val)]
    end.flatten]
  end
end



tag_to_label_color = {
  'os-documentation' => 'green',
  'TC-approved' => 'yellow',
  'TC_approved' => 'yellow',
  'os-no-qe' => 'orange',
  'os-security' => 'red',
  'os-DevCut' => 'purple'
}

board_to_team = { 
  #'Business Integration (Sharks)' => '50f5d10ff44b270a080031be',
  'Documentation (Tigers)' => '50fc695dd58223727e00750c',
  'Enterprise (Eagles)' => '50fc6852d58223727e0074f0',
  'Runtime (Centipedes)' => '50fc6814d58223727e0074e4',
  #'User Interface (Barracudas)' => '50fc6840d58223727e0074ea',
  #'Design (Pandas)' => '50fc6840d58223727e0074ea' # Merging with UI
}

title_tag_mapping = { 
  "os-billing" => "billing",
  "os-billing-summit-2013" => "summit2013",
  "os-public" => "public",
  "os-open-sourcing" => "openSourcing",
  "os-devops" => "devOps",
  "os-marketing" => "marketing",
  "os-horizontal-scaling" => "horizontalScaling",
  "os-backlog-review" => "backlogReview",
  "os-doc-approved" => "docApproved",
  "os-docs-ready" => "docReady",
  "os-crossroads" => "crossroads",
  "os-latest-lang-versions" => "latestLangVersions",
  "os-metrics-monitoring" => "metricsMonitoring",
  "os-no-sql" => "noSql",
  "os-JBoss-Integration" => "jboss",
  "os-onCloud-IDE" => "onCloudIDE",
  "os-capture" => "capture",
  "os-new-console" => "newConsole"
}






command :run do |c|
  c.syntax = "#{name}"

  c.option "--dry-run" , "Check what would happen if you actually ran it"
  c.option "--delete-all-from-trello" , "Delete everything from the target boards"

  c.description = "Run available reports"
  c.action do |args, options|
  
    rally = load_conf(RallyHelper, CONFIG.rally, true)

    #https://trello.com/1/appKey/generate
    #https://trello.com/1/connect?key=...&name=MyApp&response_type=token&scope=read,write
    Trello.configure do |config|
      config.consumer_key = 'key'
      config.consumer_secret = 'secret'
      config.oauth_token = 'token'
      config.oauth_token_secret = 'token_secret'
    end

    dan = Trello::Member.find("danmcp")
    puts dan.full_name
    
    stories = rally.get_stories
    stories = stories.sort_by{|story| story.rank.to_i}
    stories_with_attachments = []
    failures = []
    title_tags = []
    deleted = {}
    count = 0
    board_to_team.each do |team_name, board_id|
      new_list = nil
      backlog_list = nil
      summit_list = nil
      board = Trello::Board.find(board_id)
      board.lists.each do |list|
        case list.name
        when 'New'
          new_list = list
        when 'Backlog'
          backlog_list = list
        when 'Summit'
          summit_list = list
        end
      end

      if new_list.nil? or backlog_list.nil? or summit_list.nil?
        puts 'New, backlog, and summit lists are required to move'
        exit 1
      end
      
      if options.delete_all_from_trello && !options.dry_run
        unless deleted[board_id]
          [new_list, backlog_list, summit_list].each do |list|
            list.cards.each do |card|
              card.delete
            end
          end
          deleted[board_id] = true
        end
      end

      stories.each do |story|
        begin
          if story.project.to_s.chomp.strip == team_name
            puts "*************************************"
            puts "ID: #{story.formatted_i_d}"
            puts "Name: #{story.name}"
            puts "Description: #{story.description}"
            puts "Notes: #{story.notes}"
            puts "Scheduled State: #{story.schedule_state}"
            puts "Tags: #{story.tags.pretty_inspect}" 
            puts "Size: #{story.plan_estimate}"
            puts "Tasks: #{story.tasks.pretty_inspect}"
            puts "Rank: #{story.rank.pretty_inspect}"
            puts "Parent: #{story.parent}"
            puts "Children: #{story.children.pretty_inspect}"
            puts "Workspace: #{story.workspace}"
            puts "Project: #{story.project}"
            puts "Attachments: #{story.attachments}"
            puts "Iteration: #{story.iteration}"
            puts "Release: #{story.release}"
          
            if story.attachments
              stories_with_attachments << story.formatted_i_d
            end

            ready = false
            summit = false
            tags = []
            addtl_tags = []
            story.tags.each do |tag|
              tag = tag.to_s
              if tag != 'os-ready'
                if tag == 'os-docs-online' || tag == 'os-docs-enterprise' || tag == 'os-docs-origin'
                  tags << tag_to_label_color['os-documentation']
                elsif tag_to_label_color[tag]
                  tags << tag_to_label_color[tag]
                else
                  summit = true if tag == "os-billing-summit-2013"
                  tag = title_tag_mapping[tag] if title_tag_mapping[tag] 
                  addtl_tags << tag
                  title_tags << tag
                end
              else
                ready = true
              end
            end if story.tags
            tags.uniq!
        
            list_id = nil
            if summit
              list_id = summit_list.id
            elsif ready
              list_id = backlog_list.id
            else
              list_id = new_list.id
            end

            addtl_tags_name_addition = ' '
            addtl_tags.each do |addtl_tag|
              addtl_tags_name_addition += "[#{addtl_tag}] "
            end
            if story.parent
              addtl_tags_name_addition += "[#{story.parent.to_s}] "
            end
            if story.children
              addtl_tags_name_addition += "[epic] "
            end
            if story.release
              addtl_tags_name_addition += "[Release: #{story.release.to_s}] "
            end
            if story.iteration
              addtl_tags_name_addition += "[#{story.iteration.to_s}] "
            end

            name = "(#{story.plan_estimate ? story.plan_estimate.to_s : '?'})#{addtl_tags_name_addition}#{story.name}"

            desc = ''
            if story.description && !story.description.empty?
              desc = ReverseMarkdown.parse(story.description)
            end

            notes = ''
            if story.notes && !story.notes.empty?
              notes = ReverseMarkdown.parse(story.notes)
            end

            description = "#{desc}

#{notes}

Copied from #{story.formatted_i_d}"
        
            unless options.dry_run

              card = Trello::Card.create({:name => name, :list_id => list_id, :description => description})
              tags.each do |tag|
                card.add_label(tag)
              end

              if story.tasks && !story.tasks.empty?
                checklist = Trello::Checklist.create({:name => 'Tasks', :board_id => board.id})
                story.tasks.each do |task|
                  checklist.add_item(task.to_s)
                end
                checklist.update!
                card.add_checklist(checklist)
              end
            
              if story.children && !story.children.empty?
                checklist = Trello::Checklist.create({:name => 'Child Stories', :board_id => board.id})
                story.children.each do |child|
                  checklist.add_item(child.to_s)
                end
                checklist.update!
                card.add_checklist(checklist)
              end

              card.update!

            end
      
            count += 1
#            break if count >= 4

          end
        rescue Exception => e
          puts e.message
          puts e.backtrace
          failures << story.formatted_i_d
        end
      end
    end
    puts "Failures: #{failures}"
    puts "Tags: #{title_tags.uniq.pretty_inspect}"
    puts "Stories processed: #{count}"
    puts "Stories with attachments: #{stories_with_attachments.pretty_inspect}"
  end
end

default_command :run
