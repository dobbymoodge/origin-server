#!/usr/bin/env ruby

$LOAD_PATH.unshift(File.dirname(__FILE__) + '/lib') unless $LOAD_PATH.include?(File.dirname(__FILE__) + '/lib')

require 'config'
require 'trello_helper'
require 'output_helper'
require 'reports'
require 'report'

require 'pp'
require 'yaml'
require 'commander/import'

name="#{__FILE__}"

program :name, "Trello Utilities"
program :version, "1.0.0"
program :description, "An assortment of Trello utilities"

# This loads the conf files and creates new objects based on the specified classes
def load_conf(klass,args,single = false)
  if single
    klass.new(args)
  else
    Hash[*args.map do |key,val|
      [key,klass.new(val)]
    end.flatten]
  end
end

$tag_to_label_color = {
  'documentation' => 'green',
  'tc-approved' => 'yellow',
  'no-qe' => 'orange',
  'security' => 'red',
  'devcut' => 'purple'
}

EPIC_REFERENCED_STORIES_NAME = "Scenarios"
FUTURE_EPIC_REFERENCED_STORIES_NAME = "Future Scenarios"
FUTURE_TAG = '[future]'

trello = load_conf(TrelloHelper, CONFIG.trello, true)

command :list do |c|
  c.syntax = "#{name} list"

  c.option "--list LIST_NAME", "Restrict to a particular list"
  c.option "--team TEAM_NAME (broker|ui|runtime|enterprise|documentation)", "Restrict to a team"
  c.option "--card-ref SCOPE_TEAM_ID", "Get a single card Ex: origin_broker_1"

  c.description = "An assortment of Trello queries"
  c.action do |args, options|
    puts "Organization: #{trello.org.name}"
    if options.card_ref
      card = trello.card_by_ref(options.card_ref)
      if card
        trello.print_card(card)
      else
        puts "#{options.card_ref} is an invalid format!"
        exit 1
      end
    else
      if options.team
        boards = trello.team_boards(options.team)
      else
        boards = trello.org_boards
      end

      boards.each do |board|
        puts "\nBoard Name: #{board.name}"
        lists = board.lists.target
        if options.list
          lists = []
          lists.each do |list|
            if list.name == options.list
              lists = [list]
              break
            end
          end
        end
        lists.each do |list|
          trello.print_list(list)
        end
      end
    end
  end
end

command :report do |c|
  c.syntax = "#{name} report"

  c.option "--report-type NAME" , "Available report types: %s" % CONFIG.reports.keys.join(', ')
  c.option "--send-email" , "Send email?"

  c.description = "An assortment of Trello reporting utilities"
  c.action do |args, options|
    options.report_type ||= choose("Report to run?",*CONFIG.reports.keys)
    options.report_type = options.report_type.to_sym
    if options.date
      $date = Date.parse(options.date)
    end

    heading "Generating Status Report" do
      # Read Rally configuration file
      _progress "Logging into Trello" do
        $sprint = Sprint.new({:trello => trello})
      end

      # Generate queries
      _progress "Generating queries" do
        $report_types = load_conf(UserStoryReport,CONFIG.queries)
      end

      # Generate reports
      _progress "Building available reports" do
        $reports = load_conf(Report,CONFIG.reports)
      end
    end

    report = $reports[options.report_type]
    report.options = options.__hash__

    _table(
      "Running Report With Options",
      report.options.marshal_dump,
      { :capitalize => true, :sort => 0, :separator => ':' }
    )

    report.send_email if options.send_email

  end
end

command :generate_roadmap_overview do |c|
  c.syntax = "#{name} generate_roadmap_overview"

  c.option "--out OUT_FILE", "The file to output Ex: /tmp/roadmap_overview.html"

  c.description = "Generate the status of the roadmap board"
  c.action do |args, options|
    options.out ||= '/tmp/roadmap_overview.html'

    epic_list = trello.epic_list

    File.open(options.out, 'w') do |f|
      f.puts '<html><title>OpenShift Roadmap Overview</title><body>'
      f.puts "<h1>OpenShift Roadmap Overview</h1>"
      epic_list.cards.each do |epic_card|
        f.puts "<br/><h2><a href='#{epic_card.url}'>#{epic_card.name}</a></h2>"
        f.puts "<p>#{epic_card.desc}</p>"
        td_th_style = 'margin: 0; padding: 4px; border-width: 1px 1px 0 0; border-style: solid; border-color: black;'
        td = "<td style='#{td_th_style}"
        th = "<th style='#{td_th_style}"
        f.puts "<table style='border-width: 0 0 1px 1px; border-spacing: 0; border-collapse: collapse; border-style: solid;'><tr style='text-align: center;background-color: #6690bc;color: #ffffff;'>#{th}'>Scenario</th>#{th}' width='50px'>Sizing</th>#{th}' width='100px'>List</th></tr>"
        complete_sizing_total = 0
        remaining_sizing_total = 0
        stories_checklist = trello.checklist(epic_card, EPIC_REFERENCED_STORIES_NAME)
        stories_checklist.items.each do |item|
          name = item.name.strip
          url = nil
          list = "Epic Backlog"
          sizing = ''
          if name =~ /(.*)\((https?:\/\/trello\.com\/[^\)]+)\) \(([^\)]+)\)/
            name = $1.strip
            url = $2
            list = $3
          end
          if name =~ /\((\d+|\?)\)(.*)/
            sizing = $1
            name = $2

            if list && sizing != '?'
              sizing_i = sizing.to_i
              if (list.match('^Sprint \d+') || list == 'Accepted' || list == 'Complete')
                complete_sizing_total += sizing_i
              else
                remaining_sizing_total += sizing_i
              end
            end
          end
          f.puts "<tr>"
          if url
            f.puts "#{td}'><a href='#{url}'>#{name}</a></td>"
          else
            f.puts "#{td}'><a href='#{epic_card.url}'>#{name}</a></td>"
          end
          f.puts "#{td} text-align: center;'>#{sizing}</td>#{td} text-align: center;'>#{list}</td></tr>"
        end
        f.puts '</table>'
        f.puts "<i>Complete: #{complete_sizing_total}</i></br>"
        f.puts "<i>Remaining: #{remaining_sizing_total}</i></br>"
      end
      f.puts '</body><html>'
    end
  end
end

command :comment do |c|
  c.syntax = "#{name} comment"

  c.option "--card-ref SCOPE_TEAM_ID", "Get a single card Ex: origin_broker_1"

  c.description = "Adds a comment to a trello card"
  c.action do |args, options|
    comment = args[0]
    card = trello.card_by_ref(options.card_ref)
    if card
      card.add_comment(comment)
    else
      puts "#{options.card_ref} is an invalid format!"
      exit 1
    end
  end

end

command :update do |c|
  c.syntax = "#{name} update"

  c.option "--add-task-checklists", "Add task checklists to stories"
  c.option "--add-bug-checklists", "Add checklists to stories"
  c.option "--update-bug-tasks", "Update closed/verified bug tasks"
  c.option "--update-roadmap", "Update the roadmap board with progress from teams"

  c.description = "An assortment of Trello modification utilities"
  c.action do |args, options|
    if options.update_roadmap
      epic_list = trello.epic_list
      tag_to_epic = {}

      epic_list.cards.each do |epic_card|
        tags = []
        epic_card.name.scan(/\[[^\]]+\]/).each do |tag|
          if tag != '[future]'
            tag_to_epic[tag] = epic_card
            tags << tag
          end
        end

        trello.clear_checklist_refs(epic_card, FUTURE_EPIC_REFERENCED_STORIES_NAME, [FUTURE_TAG])
        trello.clear_checklist_refs(epic_card, EPIC_REFERENCED_STORIES_NAME, tags)
      end
      puts 'Tags:'
      puts tag_to_epic.keys.pretty_inspect

      (1..2).each do |accepted_pass|
        trello.boards.each do |board_id, board|
          puts "\nBoard Name: #{board.name}"
          lists = board.lists(:filter => [:all]).target
          lists.each do |list|
            accepted = (list.name.match('^Sprint \d+') || list.name == 'Accepted') ? true : false
            next if (accepted && accepted_pass == 1) || (!accepted && accepted_pass == 2)
            cards = list.cards.target
            if !cards.empty?
              puts "\n  List: #{list.name}  (#cards #{cards.length})"
              cards.each_with_index do |card, index|
                card_tags = card.name.scan(/\[[^\]]+\]/)
                card_tags.each do |card_tag|
                  epic = tag_to_epic[card_tag]
                  if epic
                    stories_checklist = trello.checklist(epic, card_tags.include?(FUTURE_TAG) ? FUTURE_EPIC_REFERENCED_STORIES_NAME : EPIC_REFERENCED_STORIES_NAME)
                    if stories_checklist
                      puts "Adding #{card.url} to #{epic.name}"
                      stories_checklist.add_item("#{card.name} (#{card.url}) (#{list.name})", accepted, 'bottom')
                    end
                  end
                end
              end
            end
          end
        end
      end
    else
      bugzilla = nil
      if options.update_bug_tasks
        require 'bugzilla_helper'
        bugzilla = load_conf(BugzillaHelper, CONFIG.bugzilla, true)
      end
      trello.boards.each do |board_id, board|
        puts "\nBoard Name: #{board.name}"
        lists = board.lists(:filter => [:open]).target
        lists.each do |list|
          if options.add_task_checklists || options.add_bug_checklists || options.update_bug_tasks
            if list.name == 'In Progress' || list.name == 'Complete'
              cards = list.cards.target
              if !cards.empty?
                puts "\n  List: #{list.name}  (#cards #{cards.length})"
                cards.each_with_index do |card, index|
                  if options.add_task_checklists || options.add_bug_checklists
                    if card.name != 'Getting Started: How we use Trello' && !(card.name =~ /^Sprint \d+/ && !card.due.nil?)
                      checklists = []
                      checklists << 'Tasks' if options.add_task_checklists
                      checklists << 'Bugs' if options.add_bug_checklists && !card.labels.map{|x| x.name }.include?('no-qe')

                      card.checklists.target.each do |checklist|
                        checklists.delete(checklist.name)
                        break if checklists.empty?
                      end if !checklists.empty?

                      if !checklists.empty?
                        puts "Adding #{checklists.pretty_inspect.chomp} to #{card.name}"
                        checklists.each do |checklist_name|
                          checklist = Trello::Checklist.create({:name => checklist_name, :board_id => board.id})
                          card.add_checklist(checklist)
                        end
                      end
                    end
                  end
                  if options.update_bug_tasks
                    ['Bugs', 'Tasks'].each do |cl|
                      bugs_checklist = trello.checklist(card, cl)
                      if bugs_checklist
                        bugs_checklist.items.each do |item|
                          item_name = item.name.strip
                          if item_name =~ /(https?:\/\/bugzilla\.redhat\.com\/[^\?]+\?id=\d+)/
                            bug_url = $1
                            status = bugzilla.bug_status_by_url(bug_url)
                            if status == 'VERIFIED' || status == 'CLOSED'
                              if item.state == 'incomplete'
                                puts "Marking complete: #{item_name}"
                                bugs_checklist.add_item(item_name, true, 'bottom')
                                bugs_checklist.delete_checklist_item(item.id)
                              end
                            elsif status == 'OPEN' || status == 'ASSIGNED'
                              if item.state == 'complete'
                                puts "Marking incomplete: #{item_name}"
                                bugs_checklist.add_item(item_name, false, 'top')
                                bugs_checklist.delete_checklist_item(item.id)
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
  end
end
