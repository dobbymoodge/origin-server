#!/usr/bin/env ruby

$LOAD_PATH.unshift(File.dirname(__FILE__) + '/lib') unless $LOAD_PATH.include?(File.dirname(__FILE__) + '/lib')

require 'config'

require 'trello_helper'
require 'output_helper'
require 'reports'
require 'report'

require 'pp'
require 'yaml'
require 'commander/import'

name="#{__FILE__}"

program :name, "Trello Utilities"
program :version, "1.0.0"
program :description, "An assortment of Trello utilities"

# This loads the conf files and creates new objects
#   based on the specified classes
def load_conf(klass,args,single = false)
  if single
    klass.new(args)
  else
    Hash[*args.map do |key,val|
      [key,klass.new(val)]
    end.flatten]
  end
end

$tag_to_label_color = {
  'documentation' => 'green',
  'tc-approved' => 'yellow',
  'no-qe' => 'orange',
  'security' => 'red',
  'devcut' => 'purple'
}

trello = load_conf(TrelloHelper, CONFIG.trello, true)

command :list do |c|
  c.syntax = "#{name} list"

  c.option "--list LIST_NAME", "Restrict to a particular list"
  c.option "--team TEAM_NAME (broker|ui|runtime|enterprise|documentation)", "Restrict to a team"
  c.option "--card-ref SCOPE_TEAM_ID", "Get a single card Ex: origin_broker_1"

  c.description = "An assortment of Trello queries"
  c.action do |args, options|
    puts "Organization: #{trello.org.name}"
    if options.card_ref
      card = trello.card_by_ref(options.card_ref)
      if card
        trello.print_card(card)
      else
        puts "#{options.card_ref} is an invalid format!"
        exit 1
      end
    else
      if options.team
        boards = trello.team_boards(options.team)
      else
        boards = trello.org_boards
      end

      boards.each do |board|
        puts "\nBoard Name: #{board.name}"
        lists = board.lists.target
        if options.list
          lists = []
          lists.each do |list|
            if list.name == options.list
              lists = [list]
              break
            end
          end
        end
        lists.each do |list|
          trello.print_list(list)
        end
      end
    end
  end
end

command :report do |c|
  c.syntax = "#{name} report"

  c.option "--report-type NAME" , "Available report types: %s" % CONFIG.reports.keys.join(', ')
  c.option "--send-email" , "Send email?"

  c.description = "An assortment of Trello reporting utilities"
  c.action do |args, options|
    options.report_type ||= choose("Report to run?",*CONFIG.reports.keys)
    options.report_type = options.report_type.to_sym
    if options.date
      $date = Date.parse(options.date)
    end
    
    heading "Generating Status Report" do
      # Read Rally configuration file
      _progress "Logging into Trello" do
        $sprint = Sprint.new({:trello => trello})
      end
      
      # Generate queries
      _progress "Generating queries" do
        $report_types = load_conf(UserStoryReport,CONFIG.queries)
      end

      # Generate reports
      _progress "Building available reports" do
        $reports = load_conf(Report,CONFIG.reports)
      end
    end
    
    report = $reports[options.report_type]
    report.options = options.__hash__
    
    _table(
      "Running Report With Options",
      report.options.marshal_dump,
      { :capitalize => true, :sort => 0, :separator => ':' }
    )
    
    report.send_email if options.send_email
    
  end
end

command :comment do |c|
  
  c.syntax = "#{name} comment"
  
  c.option "--card-ref SCOPE_TEAM_ID", "Get a single card Ex: origin_broker_1"

  c.description = "Adds a comment to a trello card"
  c.action do |args, options|
    comment = args[0]
    card = trello.card_by_ref(options.card_ref)
    if card
      card.add_comment(comment)
    else
      puts "#{options.card_ref} is an invalid format!"
      exit 1
    end
  end

end

command :update do |c|
  c.syntax = "#{name} update"
  
  c.option "--add-task-checklists", "Add task checklists to stories"
  c.option "--add-bug-checklists", "Add checklists to stories"
  c.option "--update-bug-tasks", "Update closed/verified bug tasks"

  c.description = "An assortment of Trello modification utilities"
  c.action do |args, options|
    trello.boards.each do |board_id, board|
      puts "\nBoard Name: #{board.name}"
      lists = board.lists.target
      lists.each do |list|
        if list.name == 'In Progress' || list.name == 'Complete'
          cards = list.cards.target
          if !cards.empty?
            puts "\n  List: #{list.name}  (#cards #{cards.length})"
            cards.each_with_index do |card, index|
              if options.add_task_checklists || options.add_bug_checklists
                if card.name != 'Getting Started: How we use Trello' && !(card.name =~ /^Sprint \d+/ && !card.due.nil?)
                  checklists = []
                  checklists << 'Tasks' if options.add_task_checklists
                  checklists << 'Bugs' if options.add_bug_checklists && !card.labels.map{|x| x.name }.include?('no-qe')

                  card.checklists.target.each do |checklist|
                    checklists.delete(checklist.name)
                    break if checklists.empty?
                  end if !checklists.empty?
                
                  if !checklists.empty?
                    puts "Adding #{checklists.pretty_inspect.chomp} to #{card.name}"
                    checklists.each do |checklist_name|
                      checklist = Trello::Checklist.create({:name => checklist_name, :board_id => board.id})
                      card.add_checklist(checklist)
                    end
                  end
                end
              end
              if options.update_bug_tasks
                #TODO need a way to complete a task in the trello api
                require 'bugzilla_helper'
                bugzilla = load_conf(BugzillaHelper, CONFIG.bugzilla, true)
                card.check_item_states.target.each do |check_item_state|
                  puts check_item_state.state
                  puts check_item_state.item.name
                end
                card.checklists.target.each do |checklist|
                  if checklist.name == 'Bugs'
                    checklist.items.each do |item|
                      status = bugzilla.bug_status_by_url(item.name)
                      if status == 'VERIFIED' || status == 'CLOSED'
                        #item.complete unless item.complete?
                      elsif status == 'OPEN' || status == 'ASSIGNED'
                        #item.open if item.complete?
                      end
                    end
                    break 
                  end
                end
              end
            end
          end
        end
      end
    end
  end
end

default_command :list
