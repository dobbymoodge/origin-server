#!/usr/bin/env ruby

$LOAD_PATH.unshift(File.dirname(__FILE__) + '/lib') unless $LOAD_PATH.include?(File.dirname(__FILE__) + '/lib')

require 'config'
require 'trello_helper'
require 'output_helper'
require 'reports'
require 'report'

require 'pp'
require 'yaml'
require 'commander/import'

name="#{__FILE__}"

program :name, "Trello Utilities"
program :version, "1.0.0"
program :description, "An assortment of Trello utilities"

# This loads the conf files and creates new objects based on the specified classes
def load_conf(klass,args,single = false)
  if single
    klass.new(args)
  else
    Hash[*args.map do |key,val|
      [key,klass.new(val)]
    end.flatten]
  end
end

$tag_to_label_color = {
  'documentation' => 'green',
  'tc-approved' => 'yellow',
  'no-qe' => 'orange',
  'security' => 'red',
  'devcut' => 'purple'
}

EPIC_REFERENCED_STORIES_NAME = "Referenced Stories"

trello = load_conf(TrelloHelper, CONFIG.trello, true)

command :list do |c|
  c.syntax = "#{name} list"

  c.option "--list LIST_NAME", "Restrict to a particular list"
  c.option "--team TEAM_NAME (broker|ui|runtime|enterprise|documentation)", "Restrict to a team"
  c.option "--card-ref SCOPE_TEAM_ID", "Get a single card Ex: origin_broker_1"

  c.description = "An assortment of Trello queries"
  c.action do |args, options|
    puts "Organization: #{trello.org.name}"
    if options.card_ref
      card = trello.card_by_ref(options.card_ref)
      if card
        trello.print_card(card)
      else
        puts "#{options.card_ref} is an invalid format!"
        exit 1
      end
    else
      if options.team
        boards = trello.team_boards(options.team)
      else
        boards = trello.org_boards
      end

      boards.each do |board|
        puts "\nBoard Name: #{board.name}"
        lists = board.lists.target
        if options.list
          lists = []
          lists.each do |list|
            if list.name == options.list
              lists = [list]
              break
            end
          end
        end
        lists.each do |list|
          trello.print_list(list)
        end
      end
    end
  end
end

command :report do |c|
  c.syntax = "#{name} report"

  c.option "--report-type NAME" , "Available report types: %s" % CONFIG.reports.keys.join(', ')
  c.option "--send-email" , "Send email?"

  c.description = "An assortment of Trello reporting utilities"
  c.action do |args, options|
    options.report_type ||= choose("Report to run?",*CONFIG.reports.keys)
    options.report_type = options.report_type.to_sym
    if options.date
      $date = Date.parse(options.date)
    end

    heading "Generating Status Report" do
      # Read Rally configuration file
      _progress "Logging into Trello" do
        $sprint = Sprint.new({:trello => trello})
      end

      # Generate queries
      _progress "Generating queries" do
        $report_types = load_conf(UserStoryReport,CONFIG.queries)
      end

      # Generate reports
      _progress "Building available reports" do
        $reports = load_conf(Report,CONFIG.reports)
      end
    end

    report = $reports[options.report_type]
    report.options = options.__hash__

    _table(
      "Running Report With Options",
      report.options.marshal_dump,
      { :capitalize => true, :sort => 0, :separator => ':' }
    )

    report.send_email if options.send_email

  end
end

command :comment do |c|
  c.syntax = "#{name} comment"

  c.option "--card-ref SCOPE_TEAM_ID", "Get a single card Ex: origin_broker_1"

  c.description = "Adds a comment to a trello card"
  c.action do |args, options|
    comment = args[0]
    card = trello.card_by_ref(options.card_ref)
    if card
      card.add_comment(comment)
    else
      puts "#{options.card_ref} is an invalid format!"
      exit 1
    end
  end

end

command :update do |c|
  c.syntax = "#{name} update"

  c.option "--add-task-checklists", "Add task checklists to stories"
  c.option "--add-bug-checklists", "Add checklists to stories"
  c.option "--update-bug-tasks", "Update closed/verified bug tasks"
  c.option "--update-roadmap", "Update the roadmap board with progress from teams"

  c.description = "An assortment of Trello modification utilities"
  c.action do |args, options|
    if options.update_roadmap
      epic_list = trello.epic_list
      tag_to_epic = {}
      epic_list.cards.each do |epic_card|
        epic_card.name.scan(/\[.*\]/).each do |tag|
          tag_to_epic[tag] = epic_card
        end

        has_stories_checklist = false
        stories_checklist = trello.checklist(epic_card, EPIC_REFERENCED_STORIES_NAME)
        stories_checklist.delete if stories_checklist
        #unless stories_checklist
          puts "Adding #{EPIC_REFERENCED_STORIES_NAME} to #{epic_card.name}"
          checklist = Trello::Checklist.create({:name => EPIC_REFERENCED_STORIES_NAME, :board_id => trello.roadmap_id})
          epic_card.add_checklist(checklist)
        #end
      end
      puts tag_to_epic.keys.pretty_inspect
    end
    trello.boards.each do |board_id, board|
      puts "\nBoard Name: #{board.name}"
      lists = board.lists(:filter => [ options.update_roadmap ? :all : :open]).target
      lists.each do |list|
        if options.add_task_checklists || options.add_bug_checklists || options.update_bug_tasks
          if list.name == 'In Progress' || list.name == 'Complete'
            cards = list.cards.target
            if !cards.empty?
              puts "\n  List: #{list.name}  (#cards #{cards.length})"
              cards.each_with_index do |card, index|
                if options.add_task_checklists || options.add_bug_checklists
                  if card.name != 'Getting Started: How we use Trello' && !(card.name =~ /^Sprint \d+/ && !card.due.nil?)
                    checklists = []
                    checklists << 'Tasks' if options.add_task_checklists
                    checklists << 'Bugs' if options.add_bug_checklists && !card.labels.map{|x| x.name }.include?('no-qe')

                    card.checklists.target.each do |checklist|
                      checklists.delete(checklist.name)
                      break if checklists.empty?
                    end if !checklists.empty?

                    if !checklists.empty?
                      puts "Adding #{checklists.pretty_inspect.chomp} to #{card.name}"
                      checklists.each do |checklist_name|
                        checklist = Trello::Checklist.create({:name => checklist_name, :board_id => board.id})
                        card.add_checklist(checklist)
                      end
                    end
                  end
                end
                if options.update_bug_tasks
                  require 'bugzilla_helper'
                  bugzilla = load_conf(BugzillaHelper, CONFIG.bugzilla, true)
                  bugs_checklist = trello.checklist(card, 'Bugs')
                  bugs_checklist.items.each do |item|
                    status = bugzilla.bug_status_by_url(item.name)
                    if status == 'VERIFIED' || status == 'CLOSED'
                      if item.state == 'incomplete'
                        bugs_checklist.delete_checklist_item(item.id)
                        bugs_checklist.add_item(item.name, true, 'bottom')
                      end
                    elsif status == 'OPEN' || status == 'ASSIGNED'
                      if item.state == 'complete'
                        bugs_checklist.delete_checklist_item(item.id)
                        bugs_checklist.add_item(item.name, false, 'top')
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if options.update_roadmap
          cards = list.cards.target
          if !cards.empty?
            puts "\n  List: #{list.name}  (#cards #{cards.length})"
            cards.each_with_index do |card, index|
              card_tags = card.name.scan(/\[.*\]/)
              card_tags.each do |card_tag|
                epic = tag_to_epic[card_tag]
                if epic
                  stories_checklist = trello.checklist(epic, EPIC_REFERENCED_STORIES_NAME)
                  if stories_checklist
                    #stories_checklist.items.each do |item|
                      #if item.name.include?(card.url)
                        #stories_checklist.delete_checklist_item(item.id)
                        #break
                      #end
                    #end
                    puts "Adding #{card.url} to #{epic.name}"
                    list_name = card.list.name
                    checked = (list_name.match('^Sprint \d+') || list_name == 'Accepted') ? true : false
                    stories_checklist.add_item("#{card.name} (#{card.url})", checked, checked ? 'bottom' : 'top')
                  end
                end
              end
            end
          end
        end
      end
    end
  end
end

default_command :list
