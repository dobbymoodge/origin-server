#!/usr/bin/ruby

# Client script for submitting pull requests for testing
# as well as updating the test results from Jenkins.
#
# This script requires that the 'hub' rubygem be installed
# which provides the OAuth functionality as well as some
# other core functionality.
#
# You should be able to install 'hub' with:
#   sudo gem install hub
#
# This has to be manually run one time to establish an OAuth
# ticket.  For OpenShift, the user to use is openshift-bot

require 'rubygems'
require 'hub'
require 'pp'
require 'net/https'
require 'getoptlong'
require 'time'

def usage
    puts <<USAGE
Usage: test_pull_requests [--help] [--config <file>] [--merge_pull_request <pull_id>]

This will process all the openshift pull requests and submit
Jenkins tests for any mergeable pull requests

Options:
-h|--help
    Show Usage info
--merge_pull_request <pull_id>
    Takes the id of the pull request to merge and merges into master
-c|--config <file>
    JSON configuration file (default: crankcase configuration)
USAGE
end

opts = GetoptLong.new(
    ["--help",               "-h", GetoptLong::NO_ARGUMENT],
    ["--merge_pull_request",       GetoptLong::REQUIRED_ARGUMENT],
    ["--config",             "-c", GetoptLong::REQUIRED_ARGUMENT]
)

args = {}
begin
    opts.each{ |k,v| args[k[2..-1].intern]=v }
rescue GetoptLong::Error => e
    usage
    exit -100
end

if args[:help]
  usage
  exit 1
end

merge_pull_id = args[:merge_pull_request] 

include Hub

Properties = if args.has_key?(:config) && args[:config]
    JSON.parse(IO.read(args[:config]))
else 
    JSON.parse(%Q|
      {
        "user" : "openshift",
        "repo" : "crankcase",
        "team" : "168397",
        "app_url" : "https://ci.dev.openshift.redhat.com",
        "hub_config" : "~/.config/hub",
        "proxy_host" : null,
        "proxy_port" : null
      }
    |)
end

TEST_SETTINGS = {
  :test_prefix => "Test Results:",
  :waiting_comment => "Test Results: Waiting for stable build",
  :evaluating_comment => "Test Results: Evaluating for testing",
  :evaluating_regex => /Test Results: Evaluating/,
  :waiting_regex => /Test Results: Waiting/,
  :running_regex => /Test Results: Running \((.*)\)/,
  :jenkins_project_name => "test_pull_requests",
  :trigger_regex => /\[TEST\]/i
}

MERGE_TEST_SETTINGS = {
  :test_prefix => "Merge Test Results:",
  :waiting_comment => "Merge Test Results: Waiting for stable build",
  :evaluating_comment => "Merge Test Results: Evaluating for testing",
  :evaluating_regex => /Merge Test Results: Evaluating/,
  :waiting_regex => /Merge Test Results: Waiting/,
  :running_regex => /Merge Test Results: Running \((.*)\)/,
  :jenkins_project_name => "merge_pull_request",
  :trigger_regex => /\[MERGE\]/i
}

REPO_TO_PULL_ID_PARAM = {
  'li' => 'LI_PULL_ID',
  'crankcase' => 'CRANKCASE_PULL_ID',
  'rhc' => 'RHC_PULL_ID' 
}

REPO_TO_PULL_REGEX = {
  'li' => /https:\/\/github.com\/openshift\/li\/pull\/(\d+)/,
  'crankcase' => /https:\/\/github.com\/openshift\/crankcase\/pull\/(\d+)/,
  'rhc' => /https:\/\/github.com\/openshift\/rhc\/pull\/(\d+)/
}

ACTION_PREFIX      = "Action Required:"
ACTION_REGEX       = /#{ACTION_PREFIX}/
ACTION_NOT_MERGE   = "#{ACTION_PREFIX} Pull request cannot be automatically merged"
ACTION_NOT_TEAM    = "#{ACTION_PREFIX} Please contact #openshift-dev to have this pull request manually reviewed and tested"
ACTION_NOT_MASTER  = "#{ACTION_PREFIX} Only pull request(s) from master are automatically tested"

# Dynamically extend GitHubAPI to add methods that don't
# require a local git project
module Hub
  class GitHubAPI
    def list_pull_requests
      res = get "https://api.github.com/repos/#{Properties['user']}/#{Properties['repo']}/pulls" 
      res.error! unless res.success?
      res.data
    end
    
    def get_pull_request id
      res = get "https://api.github.com/repos/#{Properties['user']}/#{Properties['repo']}/pulls/%s" % id
      res.error! unless res.success?
      res.data
    end

    def is_mergeable? id
      pull_request = get_pull_request id
      pull_request['mergeable']
    end

    def get_comments issue_id
      res = get "https://api.github.com/repos/#{Properties['user']}/#{Properties['repo']}/issues/%s/comments" % issue_id
      res.error! unless res.success?
      res.data
    end

    def delete_comment comment_id
      $stderr.puts "Deleting comment ##{comment_id}"
      res = delete "https://api.github.com/repos/#{Properties['user']}/#{Properties['repo']}/issues/comments/%s" % [comment_id]
      res.error! unless res.success?
    end

    def add_comment issue_id, comment
      params = { :body => comment }
      res = post "https://api.github.com/repos/#{Properties['user']}/#{Properties['repo']}/issues/%s/comments" % [issue_id], params
      res.error! unless res.success?
      res.data
    end

    def update_comment comment_id, comment
      $stderr.puts "Updating comment ##{comment_id} with #{comment}"
      params = { :body => comment }
      res = post "https://api.github.com/repos/#{Properties['user']}/#{Properties['repo']}/issues/comments/%s" % [comment_id], params
      res.error! unless res.success?
      res.data
    end

    # Verifies the user is part of Team Red Hat
    def user_trusted? login
      res = get "https://api.github.com/teams/#{Properties['team']}/members/#{login}"
      return res.success?
    end

    # Submit tests to Jenkins and update the comment
    def submit_tests(repo_to_pull_id, comment_id, settings)
      # If the project is stable, submit the tests
      build_url = JenkinsAPI.submit_jenkins_job(repo_to_pull_id, settings)

      # Update the comments to reflect the new tests running
      update_comment comment_id, "#{settings[:test_prefix]} Running (#{build_url})"
    end
    
    def merge_pull_request(pull_id, settings)
      pull_request = get_pull_request(pull_id)
      bot_comment = nil
      get_comments(pull_id).each do |comment|
        if comment['body'] =~ /#{settings[:test_prefix]}/
          bot_comment = comment
          break
        end
      end 
      if bot_comment.nil? || Time.parse(bot_comment['updated_at']) > Time.parse(pull_request['updated_at'])
        params = { :commit_message => "Merged by openshift-bot" }
        res = put "https://api.github.com/repos/#{Properties['user']}/#{Properties['repo']}/pulls/#{pull_id}/merge", params
        res.error! unless res.success?
      else
        update_comment pull_id, settings[:evaluating_comment]
        raise "Pull request was updated after testing started!"
      end
    end

    def put url, params = nil
      perform_request url, :Put do |req|
        if params
          req.body = JSON.dump params
          req['Content-Type'] = 'application/json'
        end
        yield req if block_given?
        req['Content-Length'] = req.body ? req.body.length : 0
      end
    end
    
    def delete url
      perform_request url, :Delete do |req|
        yield req if block_given?
      end
    end

    #
    # Yields on the OpenShift bot comment with the test results.
    # Creates a placeholder comment if none exist
    #
    def process_or_create_comment(issue_id, settings)
      bot_comment = get_comment_with_prefix(issue_id, settings[:test_prefix])

      unless bot_comment
        # No comment found, create a new one and yield to it
        $stderr.puts "Creating placeholder comment"
        bot_comment = add_comment issue_id, settings[:evaluating_comment]
      end

      yield bot_comment['id'], bot_comment['body'], Time.parse(bot_comment['updated_at'])
    end
    
    #
    # Creates or updates a comment with given prefix
    #
    def create_or_update_comment(issue_id, comment_prefix, comment)
      bot_comment = get_comment_with_prefix(issue_id, comment_prefix)

      if bot_comment
        update_comment bot_comment['id'], comment
      else
        # No comment found, create a new one
        add_comment issue_id, comment
      end

    end
    
    #
    # Creates or updates a comment with given prefix
    #
    def delete_comment_with_prefix(issue_id, comment_prefix)
      bot_comment = get_comment_with_prefix(issue_id, comment_prefix)
      delete_comment bot_comment['id'] if bot_comment
    end
    
    #
    # Gets a comment with given prefix
    #
    def get_comment_with_prefix(issue_id, comment_prefix)
      bot_comment = nil
    
      # See if we can find an existing bot comment
      get_comments(issue_id).each do |comment|
        if comment['body'] =~ /#{comment_prefix}/
          bot_comment = comment
          break
        end
      end
    
      bot_comment
    end

    #
    # Processes a specific pull request.  Manages the various comment
    # states and will submit tests as necessary and update the comment
    # with the results.  Tests will be resubmitted if the issue has
    # been updated since the test have been run
    #
    def process_pull_request(req, settings)      
      id = req['number']
      updated_at = Time.parse(req["updated_at"])
      repo_to_pull_id = {Properties['repo'] => id}

      # Gather any dependencies from trusted users
      get_comments(id).each do |comment|
        REPO_TO_PULL_REGEX.each do |repo, regex|
          if comment['body'] =~ regex
            addtl_pull_id = $1
            comment_login = comment['user']['login']
            trusted = user_trusted? comment_login
            $stderr.puts "#{comment_login} trusted: #{trusted}"
            if trusted
              repo_to_pull_id[repo] = addtl_pull_id
            end
          end
        end
      end

      # Find the bot comment for this pull request (or create one)
      process_or_create_comment(id, settings) do |comment_id, comment, comment_updated_at|
        case comment
          when settings[:evaluating_regex]
            # This is the state for a completely new comment
            if JenkinsAPI.is_project_stable?
              submit_tests repo_to_pull_id, comment_id, settings
            else
              update_comment comment_id, settings[:waiting_comment]
            end
          when settings[:waiting_regex]
            # Only submit the tests if the project is stable
            submit_tests repo_to_pull_id, comment_id, settings if JenkinsAPI.is_project_stable?
          when settings[:running_regex]
            # This state means that the tests are already running
            # In this case we need to poll Jenkins to see if the build
            # is finished

            # Capture the build_url from the regex match
            build_url = $1

            # If the build is finished, update with the results
            unless JenkinsAPI.is_build_running?(build_url)
              result = JenkinsAPI.get_build_result(build_url)
              update_comment comment_id, "#{settings[:test_prefix]} #{result} (#{build_url})"
            end
          else
            # This should match the state where the tests have already been
            # run and have passed / failed.  If the issue has been updated,
            # then re-run the tests
            submit_tests repo_to_pull_id, comment_id, settings if updated_at > comment_updated_at
        end
      end
    end

    #
    # Processes a list of the valid pull requests that are mergeable
    # and are submitted by a trusted user
    #
    def process_pull_requests(settings)
      pull_requests = []
      list_pull_requests.each do |req|
        id = req['number']
        $stderr.puts "Analyzing pull request ##{id}"

        # Skip if it's not mergeable
        mergeable = is_mergeable? id
        $stderr.puts "Mergeable #{mergeable}"
        unless mergeable
          create_or_update_comment(id, ACTION_PREFIX, ACTION_NOT_MERGE)
          next
        end

        # Verify user is from the Red Hat Team
        login = req['user']['login']
        trusted = user_trusted? login
        $stderr.puts "#{login} trusted: #{trusted}"
        
        untrusted = false
        # Has a merge or test been requested by a trusted user?
        if req['title'] =~ settings[:trigger_regex]
          if trusted
            delete_comment_with_prefix(id, ACTION_PREFIX)
            pull_requests << req
            next
          else
            create_or_update_comment(id, ACTION_PREFIX, ACTION_NOT_TEAM)
          end
        end
        
        get_comments(id).each do |comment|
          if comment['body'] =~ settings[:trigger_regex]
            comment_login = comment['user']['login']
            trusted = user_trusted? comment_login
            $stderr.puts "#{comment_login} trusted: #{trusted}"
            if trusted
              delete_comment_with_prefix(id, ACTION_PREFIX)
              pull_requests << req
              break
            else
              create_or_update_comment(id, ACTION_PREFIX, ACTION_NOT_TEAM)
            end
          end
        end
      end

      sorted_pull_requests = pull_requests.sort_by do |req|
        Time.parse(req["updated_at"])
      end

      sorted_pull_requests.each do |req|
        # Process the pull request
        process_pull_request(req, settings)
      end
    end
  end

  #
  # A class to encapsulate the Jenkins API interaction
  #
  class JenkinsAPI
    JENKINS = "https://ci.dev.openshift.redhat.com/jenkins"
    CHECK_URI = URI("#{JENKINS}/job/libra_ami/lastCompletedBuild/api/json")
    JOB_BASE_URI = "#{JENKINS}/job/"

    def self.get_session
      proxy = Net::HTTP::Proxy(Properties['proxy_host'], Properties['proxy_port'])
      session = proxy.new(CHECK_URI.host, CHECK_URI.port)
      session.use_ssl = true
      session.verify_mode = OpenSSL::SSL::VERIFY_NONE
      return session
    end

    def self.submit_jenkins_job repo_to_pull_id, settings
      # First, get the next jenkins build number
      next_build_num = get_next_build(settings)
      build_uri = URI(JOB_BASE_URI + settings[:jenkins_project_name] + "/buildWithParameters?token=libra1")

      pull_id_params = ''
      repo_to_pull_id.each do |repo, pull_id|
        pull_id_param = REPO_TO_PULL_ID_PARAM[repo]
        pull_id_params += "&#{pull_id_param}=#{pull_id}"
      end

      # Now submit the Jenkins job
      get_session.start do |http|
        request = Net::HTTP::Get.new build_uri.request_uri + "#{pull_id_params}"
        response = http.request request
        if response.kind_of? Net::HTTPFound
          $stderr.puts "Successfully submitted job for pull request"

          # Block until Jenkins actually increments the build number (this isn't transactional)
          $stderr.puts "Now waiting until build number increments..."
          while get_next_build(settings) == next_build_num
            sleep 1
          end

          # Now you can safely return with the submission registered
          return JOB_BASE_URI + settings[:jenkins_project_name] + "/#{next_build_num}/"
        else
          raise "Jenkins job submission failed for pull request"
        end
      end
    end

    def self.is_project_stable?
      get_session.start do |http|
        request = Net::HTTP::Get.new CHECK_URI.request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          return JSON.parse(response.body)["result"] == "SUCCESS"
        else
          raise "Jenkins connection error"
        end
      end
    end

    def self.get_next_build(settings)
      job_api_uri = URI("#{JENKINS}/job/#{settings[:jenkins_project_name]}/api/json")
      get_session.start do |http|
        request = Net::HTTP::Get.new job_api_uri.request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          JSON.parse(response.body)["nextBuildNumber"].to_i
        else
          raise "Jenkins connection error"
        end
      end
    end

    def self.to_api_url build_url
      URI(build_url + "/api/json")
    end

    def self.is_build_running? build_url
      get_session.start do |http|
        request = Net::HTTP::Get.new to_api_url(build_url).request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          return JSON.parse(response.body)["building"]
        else
          raise "Jenkins connection error"
        end
      end
    end

    def self.get_build_result build_url
      get_session.start do |http|
        request = Net::HTTP::Get.new to_api_url(build_url).request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          job = JSON.parse(response.body)
          return job["result"]
        else
          raise "Jenkins connection error"
        end
      end
    end
  end
end

#
#
# The main program script
#
#

# Create a new Hub client
@api_client ||= begin
  config_file = ENV['HUB_CONFIG'] || Properties['hub_config']
  file_store = GitHubAPI::FileStore.new File.expand_path(config_file)
  file_config = GitHubAPI::Configuration.new file_store
  GitHubAPI.new file_config, :app_url => Properties['app_url']
end

if merge_pull_id
  @api_client.merge_pull_request merge_pull_id, MERGE_TEST_SETTINGS
else
  # Process all the pull requests for testing
  puts "Updating pull requests..."
  @api_client.process_pull_requests TEST_SETTINGS
  @api_client.process_pull_requests MERGE_TEST_SETTINGS
  puts "Done"
end
