#!/usr/bin/ruby

# Client script for submitting pull requests for testing
# as well as updating the test results from Jenkins.
#
# This script requires that the 'hub' rubygem be installed
# which provides the OAuth functionality as well as some
# other core functionality.
#
# You should be able to install 'hub' with:
#   sudo gem install hub
#
# This has to be manually run one time to establish an OAuth
# ticket.  For OpenShift, the user to use is openshift-bot

require 'rubygems'
require 'hub'
require 'pp'
require 'net/https'
require 'getoptlong'
require 'time'

def usage
    puts <<USAGE
Usage: test_pull_requests [--help] [--merge_pull_request <pull_id>] [--local_merge_pull_request <pull_id>] [--test_pull_request <pull_id>] [--repo <repo>]

This will process all the openshift pull requests and submit
Jenkins tests for any mergeable pull requests

Options:
-h|--help
    Show Usage info
--merge_pull_request <pull_id>
    Takes the id of the pull request to merge and merges into master
--local_merge_pull_request <pull_id>
    Takes the id of the pull request to merge and locally merges into master
--test_merge_pull_request <pull_id>
    Takes the id of the pull request to merge and makes sure the merge will succeed before actually merging
--repo <repo>
    The repo of the pull request
USAGE
end

opts = GetoptLong.new(
    ["--help",               "-h", GetoptLong::NO_ARGUMENT],
    ["--merge_pull_request",       GetoptLong::REQUIRED_ARGUMENT],
    ["--local_merge_pull_request", GetoptLong::REQUIRED_ARGUMENT],
    ["--test_merge_pull_request",  GetoptLong::REQUIRED_ARGUMENT],
    ["--repo",                     GetoptLong::REQUIRED_ARGUMENT]
)

args = {}
begin
    opts.each{ |k,v| args[k[2..-1].intern]=v }
rescue GetoptLong::Error => e
    usage
    exit -100
end

if args[:help]
  usage
  exit 1
end

merge_pull_id = args[:merge_pull_request]
local_merge_pull_id = args[:local_merge_pull_request]
test_merge_pull_id = args[:test_merge_pull_request]
pull_id_repo = args[:repo]

include Hub

PROXY_HOST = nil
PROXY_PORT = nil
APP_URL = "https://ci.dev.openshift.redhat.com"
HUB_CONFIG = "~/.config/hub"
OPENSHIFT_USER = "openshift"

TEST_SETTINGS = {
  :name => "test",
  :test_prefix => "Test Results:",
  :waiting_comment => "Test Results: Waiting for stable build",
  :queued_comment => "Test Results: Waiting: You are in the build queue at position: %s",
  :being_queued_comment => "Test Results: Waiting: Determining build queue position",
  :evaluating_comment => "Test Results: Evaluating for testing",
  :evaluating_regex => /^Test Results: Evaluating/,
  :waiting_regex => /^Test Results: Waiting/,
  :running_regex => /^Test Results: Running \((.*)\)/,
  :finished_regex => /^Test Results: .+ \((.*)\)/,
  :queued_regex => /^Test Results: Waiting: You are in the build queue at position: \d+/,
  :allow_multiple => true,
  :branches => { 'stage'   => {:jenkins_job_name => "test_pull_requests_stage",
                               :downstream_job_name => "libra_ami_stage"},
                 'master'  => {:jenkins_job_name => "test_pull_requests",
                               :downstream_job_name => "libra_ami"} },
  :repo_to_teams => {
    'li' => ["168397", "175254", "202863"], # Team Red Hat, crankcase, site
    'crankcase' => ["168397", "175254"], # Team Red Hat, crankcase
    'rhc' => ["168397", "77593"] # Team Red Hat, rhc
  },
  :trigger_regex => /\[TEST\]/i
}

MERGE_TEST_SETTINGS = {
  :name => "merge",
  :test_prefix => "Merge Test Results:",
  :waiting_comment => "Merge Test Results: Waiting for stable build",
  :queued_comment => "Merge Test Results: Waiting: You are in the build queue at position: %s",
  :being_queued_comment => "Merge Test Results: Waiting: Determining build queue position",
  :evaluating_comment => "Merge Test Results: Evaluating for testing",
  :evaluating_regex => /^Merge Test Results: Evaluating/,
  :waiting_regex => /^Merge Test Results: Waiting/,
  :running_regex => /^Merge Test Results: Running \((.*)\)/,
  :finished_regex => /^Merge Test Results: .+ \((.*)\)/,
  :queued_regex => /^Merge Test Results: Waiting: You are in the build queue at position: \d+/,
  :allow_multiple => false,
  :branches => { 'stage'   => {:jenkins_job_name => "merge_pull_request_stage",
                               :downstream_job_name => "libra_ami_stage",
                               :ami_base_name => "devenv-stage"},
                 'master'  => {:jenkins_job_name => "merge_pull_request",
                               :downstream_job_name => "libra_ami",
                               :ami_base_name => "devenv"} },
  :repo_to_teams => {
    'li' => ["175254", "202863"], # Team crankcase, site
    'crankcase' => ["175254"], # Team crankcase
    'rhc' => ["77593"] # Team rhc
  },
  :trigger_regex => /\[MERGE\]/i
}

SETTINGS = [TEST_SETTINGS, MERGE_TEST_SETTINGS]

REPOS = ['li', 'crankcase', 'rhc']

REPO_TO_PULL_ID_PARAM = {
  'li' => 'LI_PULL_ID',
  'crankcase' => 'CRANKCASE_PULL_ID',
  'rhc' => 'RHC_PULL_ID' 
}

REPO_TO_PULL_REGEX = {
  'li' => /https:\/\/github.com\/openshift\/li\/pull\/(\d+)/,
  'crankcase' => /https:\/\/github.com\/openshift\/crankcase\/pull\/(\d+)/,
  'rhc' => /https:\/\/github.com\/openshift\/rhc\/pull\/(\d+)/
}

BRANCHES = {
  'stage' => nil,
  'master' => nil
}

ACTION_PREFIX               = "Action Required:"
ACTION_NOT_MERGE            = "#{ACTION_PREFIX} Pull request cannot be automatically merged"
ACTION_NOT_TEAM             = "#{ACTION_PREFIX} Please contact #openshift-dev to have this pull request manually reviewed and tested"
ACTION_UNSUPPORTED_BRANCH   = "#{ACTION_PREFIX} Only pull request(s) from #{BRANCHES.keys.pretty_inspect.chomp} are handled by the openshift-bot"

EVALUATED_MARKER_REGEX = /^\[Evaluated\]/i
EVALUATED_MARKER_WITH_SHA_REGEX = /^\[Evaluated\] up to (.*)/
EVALUATED_MARKER = "[Evaluated]"

# Dynamically extend GitHubAPI to add methods that don't
# require a local git project
module Hub
  class GitHubAPI
    def list_pull_requests(repo)
      res = get "https://api.github.com/repos/#{OPENSHIFT_USER}/#{repo}/pulls"
      rate_limit_remaining = res.header['X-RateLimit-Remaining']
      $stderr.puts "Rate limit remaining: #{rate_limit_remaining}"
      if rate_limit_remaining.to_i < 100
        $stderr.puts "WARNING: Skipping processing due to rate limit approaching!" 
        exit 0
      end
      res.error! unless res.success?
      res.data
    end
    
    def get_pull_request(id, repo)
      res = get "https://api.github.com/repos/#{OPENSHIFT_USER}/#{repo}/pulls/%s" % id
      res.error! unless res.success?
      res.data
    end

    def is_mergeable?(id, repo, num_tries=1)
      # This call isn't reliable so make sure
      (1..num_tries).each do |i|
        pull_request = get_pull_request(id, repo)
        return true if pull_request['mergeable']
      end
      return false
    end

    def get_commits(id, repo)
      commits = nil
      if $commits[repo]
        commits = $commits[repo][id]
      else
        $commits[repo] = {}
      end
      unless commits
        res = get "https://api.github.com/repos/#{OPENSHIFT_USER}/#{repo}/pulls/%s/commits" % id
        res.error! unless res.success?
        commits = res.data
        $commits[repo][id] = commits
      end
      commits
    end

    def get_comments(issue_id, repo)
      res = get "https://api.github.com/repos/#{OPENSHIFT_USER}/#{repo}/issues/%s/comments" % issue_id
      res.error! unless res.success?
      res.data
    end

    def delete_comment(comment_id, repo)
      $stderr.puts "Deleting comment ##{comment_id}"
      res = delete "https://api.github.com/repos/#{OPENSHIFT_USER}/#{repo}/issues/comments/%s" % [comment_id]
      res.error! unless res.success?
    end

    def add_comment(issue_id, repo, comment)
      params = { :body => comment }
      res = post "https://api.github.com/repos/#{OPENSHIFT_USER}/#{repo}/issues/%s/comments" % [issue_id], params
      res.error! unless res.success?
      res.data
    end

    def update_comment(comment_id, repo, comment)
      $stderr.puts "Updating comment ##{comment_id} with #{comment}"
      params = { :body => comment }
      res = post "https://api.github.com/repos/#{OPENSHIFT_USER}/#{repo}/issues/comments/%s" % [comment_id], params
      res.error! unless res.success?
      res.data
    end

    # Verifies the user is part of Team Red Hat
    def user_trusted?(login, repo, settings)
      trusted = false
      repo_setting_key = "#{repo}_#{settings[:name]}"
      if $permissions[login]
        trusted = $permissions[login][repo_setting_key] ? true : false
      else
        $permissions[login] = {}
      end
      if $permissions[login][repo_setting_key].nil?
        settings[:repo_to_teams][repo].each do |team|
          res = get "https://api.github.com/teams/#{team}/members/#{login}"
          trusted = res.success?
          break if trusted
        end
        $permissions[login][repo_setting_key] = trusted
      end
      trusted
    end

    # Submit tests to Jenkins and update the comment
    def submit_tests(repo_to_pull_request, base_repo, branch, comment_id, settings)
      unless settings[:allow_multiple]
        if $submitted_tests[settings[:name]] || JenkinsAPI.is_previous_build_running?(branch, settings)
          $submitted_tests[settings[:name]] = true
          $stderr.puts "Waiting for existing build to finish"
          return
        end
      end
      
      # If the project is stable, submit the tests
      build_url = JenkinsAPI.submit_jenkins_job(repo_to_pull_request, branch, settings)

      running_comment = "#{settings[:test_prefix]} Running (#{build_url})"

      # Update the comments to reflect the new tests running
      update_comment(comment_id, base_repo, running_comment)

      repo_to_pull_request.each do |repo, pull_request|
        if repo != base_repo
          process_or_create_comment(pull_request['number'], repo, settings) do |comment_id, comment, comment_updated_at|
            update_comment(comment_id, repo, running_comment)
          end
        end
      end

      $submitted_tests[settings[:name]] = true unless settings[:allow_multiple]
    end
    
    def merge_pull_request(pull_id, repo, settings)
      $stderr.puts "Merging pull request ##{pull_id} for repo '#{repo}'"
      pull_request, bot_comment = test_merge_pull_request(pull_id, repo, settings)
      build_url = settings[:running_regex].match(bot_comment['body'])[1]

      ami = "unknown"
      begin
        branch = pull_request['base']['ref']
        branch_settings = settings[:branches][branch]
        ami = "#{branch_settings[:ami_base_name]}_#{JenkinsAPI.get_next_build(branch, settings, branch_settings[:downstream_job_name])}"
      rescue Exception => e
        $stderr.puts e.message
      end

      update_comment(bot_comment['id'], repo, "#{settings[:test_prefix]} SUCCESS (#{build_url})\nAMI: #{ami}")
      params = { :commit_message => "Merged by openshift-bot" }
      res = put "https://api.github.com/repos/#{OPENSHIFT_USER}/#{repo}/pulls/#{pull_id}/merge", params
      res.error! unless res.success?
    end
    
    def test_merge_pull_request(pull_id, repo, settings)
      $stderr.puts "Test merging pull request ##{pull_id} for repo '#{repo}'"
      comments = get_comments(pull_id, repo)
      bot_comment = get_comment_with_prefix(pull_id, repo, settings[:test_prefix], comments)
      raise "Missing '{settings[:test_prefix]}' comment!" if bot_comment.nil?
      evaluated_time = get_evaluated_time(comments)
      raise "Missing evaluated flag!" if evaluated_time.nil?
      pull_request = get_pull_request(pull_id, repo)
      mergeable = pull_request['mergeable']
      # This call isn't reliable so make sure
      mergeable = is_mergeable?(pull_id, repo, 2) unless mergeable 
      raise "Pull request isn't mergeable!" unless mergeable
      pull_request_updated_at, pull_request_changed_after_eval = get_updated_at(pull_request, comments)
      unless !pull_request_changed_after_eval
        $stderr.puts "Evaluated time: #{evaluated_time}"
        $stderr.puts "Updated at: #{pull_request_updated_at}"
        raise "Pull request was updated after testing started!"
      end
      return pull_request, bot_comment
    end
    
    def local_merge_pull_request(pull_id, repo)
      $stderr.puts "Local merging pull request ##{pull_id} for repo '#{repo}'"
      pull_request = get_pull_request(pull_id, repo)
      merge_command = %{
set -ex
pushd #{repo}
  git checkout #{pull_request['base']['ref']}
  git checkout -b #{pull_request['head']['ref']}_#{pull_request['user']['login']}
  git pull #{pull_request['head']['repo']['ssh_url']} #{pull_request['head']['ref']}
  git checkout #{pull_request['base']['ref']}
  git merge #{pull_request['head']['ref']}_#{pull_request['user']['login']}
popd
}
      output = `#{merge_command}`
      exit_code = $?
      puts output
      exit exit_code if exit_code != 0
    end

    def put url, params = nil
      perform_request url, :Put do |req|
        if params
          req.body = JSON.dump params
          req['Content-Type'] = 'application/json'
        end
        yield req if block_given?
        req['Content-Length'] = req.body ? req.body.length : 0
      end
    end
    
    def delete url
      perform_request url, :Delete do |req|
        yield req if block_given?
      end
    end

    #
    # Yields on the OpenShift bot comment with the test results.
    # Creates a placeholder comment if none exist
    #
    def process_or_create_comment(issue_id, repo, settings, comments=nil)
      bot_comment = get_comment_with_prefix(issue_id, repo, settings[:test_prefix], comments)

      unless bot_comment
        # No comment found, create a new one and yield to it
        $stderr.puts "Creating placeholder comment"
        bot_comment = add_comment(issue_id, repo, settings[:evaluating_comment])
      end

      yield bot_comment['id'], bot_comment['body'], Time.parse(bot_comment['updated_at'])
    end
    
    #
    # Creates or updates a comment with given prefix
    #
    def create_or_update_comment(issue_id, repo, comment_prefix, comment, comments=nil)
      bot_comment = get_comment_with_prefix(issue_id, repo, comment_prefix, comments)

      if bot_comment
        update_comment(bot_comment['id'], repo, comment) if bot_comment['body'] != comment
      else
        # No comment found, create a new one
        add_comment(issue_id, repo, comment)
      end

    end
    
    #
    # Creates or updates a comment with given prefix
    #
    def delete_comment_with_prefix(issue_id, repo, comment_prefix, comments=nil)
      comment = get_comment_with_prefix(issue_id, repo, comment_prefix, comments)
      if comment && comments
        comments.delete_if { |c| c['id'] == comment['id'] }
      end
      delete_comment(comment['id'], repo) if comment
    end
    
    #
    # Gets a comment with given prefix
    #
    def get_comment_with_prefix(issue_id, repo, comment_prefix, comments=nil)
      prefix_comment = nil

      comments = comments ? comments : get_comments(issue_id, repo)

      # See if we can find an existing bot comment
      comments.each do |comment|
        if comment['body'] =~ /^#{comment_prefix}/ && (comment['user']['login'] == 'openshift-bot')
          prefix_comment = comment
          break
        end
      end

      prefix_comment
    end
    
    def get_evaluated_time(comments)
      comments = sort_comments(comments)

      comments.each do |comment|
        if comment['user']['login'] == 'openshift-bot' && comment['body'] =~ EVALUATED_MARKER_REGEX
          return Time.parse(comment['updated_at'])
        end
      end
      return nil
    end
    
    def get_trusted_trigger_time(pull_request, comments, settings)
      login = pull_request['user']['login']
      updated_at, changed_after_eval = get_updated_at(pull_request, comments)
      repo = pull_request['base']['repo']['name']
        
      trigger_time = nil
      if pull_request['title'] =~ settings[:trigger_regex] || pull_request['body'] =~ settings[:trigger_regex]
        if user_trusted?(login, repo, settings)
          evaluated_time = get_evaluated_time(comments)
          trigger_time = evaluated_time || Time.parse(pull_request['updated_at'])
        end
      end

      comments = sort_comments(comments)

      comments.each do |comment|
        if comment['body'] =~ settings[:trigger_regex]
          comment_login = comment['user']['login']
          if user_trusted?(comment_login, repo, settings)
            trigger_comment_updated_at = Time.parse(comment['updated_at'])
            if user_trusted?(login, repo, settings) || trigger_comment_updated_at > updated_at
              trigger_time = trigger_comment_updated_at if !trigger_time || trigger_comment_updated_at > trigger_time 
              break
            end
          end
        end
      end
      return trigger_time
    end
    
    def sort_comments(comments)
      comments = comments.sort_by do |comment|
        Time.parse(comment['updated_at'])
      end
      comments.reverse!
      comments
    end

    # Updates all the bot markers for the involved pull requests.  To be called after you have validated the tests should be kicked off again
    def update_evaluated_markers(repo_to_pull_request, trigger_updated_at, settings) 
      repo_to_pull_request.each do |repo, pull_request|
        pull_request_comments = get_comments(pull_request['number'], repo)
        test_prefix_comment = get_comment_with_prefix(pull_request['number'], repo, settings[:test_prefix], pull_request_comments)
        if !test_prefix_comment || !(test_prefix_comment['body'] =~ settings[:waiting_regex])
          create_or_update_comment(pull_request['number'], repo, settings[:test_prefix], settings[:being_queued_comment], pull_request_comments)
        end
        pull_request_evaluated_time = get_evaluated_time(pull_request_comments)
        pull_request_updated_at, pull_request_changed_after_eval = get_updated_at(pull_request, pull_request_comments)
        if pull_request_changed_after_eval || pull_request_evaluated_time < trigger_updated_at
          commits = get_commits(pull_request['number'], repo)
          # Add a new evaluated marker
          add_comment(pull_request['number'], repo, "#{EVALUATED_MARKER} up to #{commits.last['sha']}")
          # Delete the old evaluated markers
          pull_request_comments.each do |comment|
            if comment['user']['login'] == 'openshift-bot' && comment['body'] =~ EVALUATED_MARKER_REGEX 
              delete_comment(comment['id'], repo)
            end
          end
        end
      end
    end
    
    def get_updated_at(pull_request, comments)
      updated_at = nil
      comments = sort_comments(comments)
      previous_sha = nil
      comments.each do |comment|
        if comment['user']['login'] == 'openshift-bot' && comment['body'] =~ EVALUATED_MARKER_WITH_SHA_REGEX
          previous_sha = $1
        end
      end
      commits = get_commits(pull_request['number'], pull_request['base']['repo']['name'])

      changed_after_eval = true
      if commits.last['sha'] == previous_sha
        changed_after_eval = false
      end
      updated_at = Time.parse(commits.last['commit']['committer']['date'])
      [updated_at, changed_after_eval]
    end

    #
    # Processes a specific pull request.  Manages the various comment
    # states and will submit tests as necessary and update the comment
    # with the results.  Tests will be resubmitted if the issue has
    # been updated since the test have been run
    #
    def process_pull_request(req, updated_at, changed_after_eval, comments, settings)
      id = req['number']
      branch = req['base']['ref']
      base_repo = req['base']['repo']['name']
      login = req['user']['login']
      repo_to_pull_request = {base_repo => req}
      
      $stderr.puts "\n****Processing '#{settings[:name]}' for user '#{login}' on: https://github.com/openshift/#{base_repo}/pull/#{id}"

      trigger_updated_at = get_trusted_trigger_time(req, comments, settings)
      evaluated_time = get_evaluated_time(comments)

      $stderr.puts "Updated at: #{updated_at}"
      $stderr.puts "Changed after evaluated time: #{changed_after_eval}"
      $stderr.puts "Trigger updated at: #{trigger_updated_at}"
      $stderr.puts "Evaluated time: #{evaluated_time}"

      # Gather any dependencies from trusted users
      comments.each do |comment|
        REPO_TO_PULL_REGEX.each do |repo, regex|
          next if repo == base_repo
          if comment['body'] =~ regex
            addtl_pull_id = $1
            comment_login = comment['user']['login']
            trusted = user_trusted?(comment_login, repo, settings)
            # It's ok if the user is trusted or the trigger was added after the comment
            if trusted || (trigger_updated_at && trigger_updated_at > Time.parse(comment['updated_at']))
              pull_request = get_pull_request(addtl_pull_id, repo)
              if pull_request
                repo_to_pull_request[repo] = pull_request
              else
                $stderr.puts "Pull ##{addtl_pull_id} not found in repo '#{repo}'"
              end
            else
              $stderr.puts "User '#{comment_login}' not trusted"
            end
          end
        end
      end

      updated_comment = nil
      # Find the bot comment for this pull request (or create one)
      process_or_create_comment(id, base_repo, settings, comments) do |comment_id, comment, comment_updated_at|
        submit_test_job = false
        resubmit_test_job = false
        case comment
          when settings[:evaluating_regex]
            $stderr.puts "Evaluating..."
            # This is the state for a completely new comment

            if JenkinsAPI.is_project_stable?(branch, settings)
              # Make sure there is a trigger in place that is still later than the updated dates of each of the pull requests
              if trigger_updated_at
                repo_to_pull_request.each do |repo, pull_request|
                  next if repo == base_repo
                  if !user_trusted?(pull_request['user']['login'], repo, settings) && trigger_updated_at < Time.parse(pull_request['head']['repo']['updated_at'])
                    create_or_update_comment(id, base_repo, ACTION_PREFIX, ACTION_NOT_TEAM, comments)
                    break
                  end
                end
                update_evaluated_markers(repo_to_pull_request, trigger_updated_at, settings)
                submit_test_job = true
              else
                create_or_update_comment(id, base_repo, ACTION_PREFIX, ACTION_NOT_TEAM, comments)
              end
            else
              updated_comment = settings[:waiting_comment]
            end
          when settings[:waiting_regex]
            $stderr.puts "Waiting..."
            # Only submit the tests if the project is stable
            if JenkinsAPI.is_project_stable?(branch, settings) 
              if !($submitted_tests[settings[:name]] && comment =~ settings[:queued_regex])
                $stderr.puts "Checking that evaluated times are still up to date"
                if changed_after_eval
                  resubmit_test_job = true
                else
                  submit_test_job = true
                  repo_to_pull_request.each do |repo, sub_pull_request|
                    next if repo == base_repo
                    $stderr.puts "Checking evaluated time for sub pull request #{sub_pull_request['number']} for repo '#{repo}'"
                    sub_pull_comments = get_comments(sub_pull_request['number'], repo)
                    sub_pull_request_updated_at, sub_pull_request_changed_after_eval = get_updated_at(sub_pull_request, sub_pull_comments)

                    $stderr.puts "Updated at: #{sub_pull_request_updated_at}"
                    $stderr.puts "Changed after evaluated time: #{sub_pull_request_changed_after_eval}"
                    if sub_pull_request_changed_after_eval
                      resubmit_test_job = true
                      break
                    end
                  end
                end
              else
                $stderr.puts "Job is already queued"
              end
            end
          when settings[:running_regex]
            $stderr.puts "Running..."
            # This state means that the tests are already running
            # In this case we need to poll Jenkins to see if the build
            # is finished

            # Capture the build_url from the regex match
            build_url = $1

            # If the build is finished, update with the results
            if JenkinsAPI.is_build_running?(build_url, branch, settings)
              $submitted_tests[settings[:name]] = true unless settings[:allow_multiple] 
            else
              result = JenkinsAPI.get_build_result(build_url, branch, settings)
              updated_comment = "#{settings[:test_prefix]} #{result} (#{build_url})"
            end
          else
            $stderr.puts "Finished..."
            $stderr.puts comment if comment =~ settings[:finished_regex]
            resubmit_test_job = true if JenkinsAPI.is_project_stable?(branch, settings)
        end
        if resubmit_test_job
          submit_test_job = false

          $stderr.puts "Checking whether we should resubmit"
          if trigger_updated_at
            # We already trust the primary pull request.  Just need to check whether the eval time is older than last update or last trusted trigger.
            if changed_after_eval || (evaluated_time < trigger_updated_at)
              submit_test_job = true
            end

            # Check for any other reason to submit the test job.  And make sure non of the sub pull requests have new untrusted changes.
            repo_to_pull_request.each do |repo, sub_pull_request|
              next if repo == base_repo

              $stderr.puts "Checking evaluated time for sub pull request #{sub_pull_request['number']} for repo '#{repo}'"
              sub_pull_comments = get_comments(sub_pull_request['number'], repo)
              sub_pull_request_updated_at, sub_pull_request_changed_after_eval = get_updated_at(sub_pull_request, sub_pull_comments)

              $stderr.puts "Updated at: #{sub_pull_request_updated_at}"
              $stderr.puts "Changed after evaluated time: #{sub_pull_request_changed_after_eval}"

              # Make sure the trigger on the primary pull request is after the updated date of the sub pull request
              # or the user of the sub pull request is trusted
              valid_trigger_comment = trigger_updated_at > sub_pull_request_updated_at
              $stderr.puts "Has valid trigger comment: #{valid_trigger_comment}"
              if valid_trigger_comment || user_trusted?(sub_pull_request['user']['login'], repo, settings)
                if sub_pull_request_changed_after_eval
                  submit_test_job = true
                end
              else
                create_or_update_comment(id, base_repo, ACTION_PREFIX, ACTION_NOT_TEAM, comments)
                submit_test_job = false
                break
              end
            end
          else
            create_or_update_comment(id, base_repo, ACTION_PREFIX, ACTION_NOT_TEAM, comments)
            submit_test_job = false
          end
          if submit_test_job
            update_evaluated_markers(repo_to_pull_request, trigger_updated_at, settings)
          end
        end
        if submit_test_job
          delete_comment_with_prefix(id, base_repo, ACTION_PREFIX, comments)
          submit_tests(repo_to_pull_request, base_repo, branch, comment_id, settings)
        elsif updated_comment
          update_comment(comment_id, base_repo, updated_comment)
          repo_to_pull_request.each do |repo, pull_request|
            next if repo == base_repo
            create_or_update_comment(pull_request['number'], repo, settings[:test_prefix], updated_comment)
          end
        end
      end
      
    end

    #
    # Processes a list of the valid pull requests that are mergeable
    # and are submitted by a trusted user
    #
    def process_pull_requests
      pull_requests = []
      REPOS.each do |repo|
        $stderr.puts "Processing repo '#{repo}'"
        list_pull_requests(repo).each do |req|
          id = req['number']
          $stderr.puts "Analyzing pull request ##{id}"
        
          branch = req['base']['ref']
          
          if BRANCHES.include?(branch)

            login = req['user']['login']

            comments = nil
            # Skip if it's not mergeable
            mergeable = is_mergeable?(id, repo)
            merge_id="#{repo}_#{id}_#{login}"
            $stderr.puts "Mergeable #{mergeable}"
            if mergeable
              `sed -i "/#{merge_id}/d" ~/test_pull_request_not_mergable`
              comments = get_comments(id, repo) if comments.nil?
              delete_comment_with_prefix(id, repo, ACTION_NOT_MERGE, comments)
            else
              count = 0
              previous_merge_result=`grep #{merge_id} ~/test_pull_request_not_mergable`.chomp
              if !previous_merge_result.empty? && previous_merge_result =~ /#{merge_id}=(\d+)/
                count = $1.to_i
              end
              if count > 10
                create_or_update_comment(id, repo, ACTION_PREFIX, ACTION_NOT_MERGE)
              else
                `sed -i "/#{merge_id}/d" ~/test_pull_request_not_mergable && echo "#{merge_id}=#{(count+1).to_s}" >> ~/test_pull_request_not_mergable`
              end
              next
            end

            comments = get_comments(id, repo) if comments.nil?
            updated_at, changed_after_eval = get_updated_at(req, comments)

            permission_denied = Array.new(SETTINGS.length, false)
            # Has a merge or test been requested by a trusted user?
            SETTINGS.each_with_index do |settings, i|
              if req['title'] =~ settings[:trigger_regex] || req['body'] =~ settings[:trigger_regex]
                if user_trusted?(login, repo, settings)
                  pull_requests << [req, updated_at, changed_after_eval, comments, settings]
                  permission_denied[i] = false
                  next
                else
                  $stderr.puts "User '#{login}' not trusted"
                  permission_denied[i] = true
                end
              end

              comments = sort_comments(comments)
              comments.each do |comment|
                if comment['body'] =~ settings[:trigger_regex]
                  comment_login = comment['user']['login']
                  if user_trusted?(comment_login, repo, settings)
                    pull_requests << [req, updated_at, changed_after_eval, comments, settings]
                    permission_denied[i] = false
                    break
                  else
                    $stderr.puts "User '#{comment_login}' not trusted"
                    permission_denied[i] = true
                  end
                end
              end
            end
            if permission_denied.include? true
              create_or_update_comment(id, repo, ACTION_PREFIX, ACTION_NOT_TEAM, comments)
            end
          else
            create_or_update_comment(id, repo, ACTION_PREFIX, ACTION_UNSUPPORTED_BRANCH)
          end
        end
      end

      sorted_pull_requests = pull_requests.sort_by do |req_info|
        req_info[1]
      end

      skipped_count = {}
      sorted_pull_requests.each do |req_info|
        # Process the pull request
        req = req_info[0]
        updated_at = req_info[1]
        changed_after_eval = req_info[2]
        comments = req_info[3]
        settings = req_info[4]
        process_pull_request(req, updated_at, changed_after_eval, comments, settings)

        if !settings[:allow_multiple] && $submitted_tests[settings[:name]] 
          comments = get_comments(req['number'], req['base']['repo']['name'])
          bot_comment = get_comment_with_prefix(req['number'], req['base']['repo']['name'], settings[:test_prefix], comments)
          if bot_comment && (bot_comment['body'] =~ settings[:waiting_regex])
            skipped_count[settings[:name]] = 0 if skipped_count[settings[:name]].nil?
            skipped_count[settings[:name]] += 1
            create_or_update_comment(req['number'], req['base']['repo']['name'], settings[:test_prefix], settings[:queued_comment] % skipped_count[settings[:name]].to_s, comments)
            $stderr.puts "Pull ##{req['number']} in repo '#{req['base']['repo']['name']}' is at build position ##{skipped_count[settings[:name]]}"
          end
        end
      end
    end
  end

  #
  # A class to encapsulate the Jenkins API interaction
  #
  class JenkinsAPI
    JENKINS = "https://ci.dev.openshift.redhat.com/jenkins"
    JOB_BASE_URI = "#{JENKINS}/job/"
    
    def self.downstream_job_uri(branch, settings)
      job_name = settings[:branches][branch][:downstream_job_name]
      URI("#{JENKINS}/job/#{job_name}/lastCompletedBuild/api/json")
    end

    def self.get_session(branch, settings)
      proxy = Net::HTTP::Proxy(PROXY_HOST, PROXY_PORT)
      uri = downstream_job_uri(branch, settings)
      session = proxy.new(uri.host, uri.port)
      session.use_ssl = true
      session.verify_mode = OpenSSL::SSL::VERIFY_NONE
      return session
    end

    def self.submit_jenkins_job(repo_to_pull_request, branch, settings)
      # First, get the next jenkins build number
      next_build_num = get_next_build(branch, settings)
      build_uri = URI(JOB_BASE_URI + settings[:branches][branch][:jenkins_job_name] + "/buildWithParameters?token=libra1")

      pull_id_params = ''
      repo_to_pull_request.each do |repo, pull_request|
        pull_id_param = REPO_TO_PULL_ID_PARAM[repo]
        pull_id_params += "&#{pull_id_param}=#{pull_request['number']}"
      end

      # Now submit the Jenkins job
      get_session(branch, settings).start do |http|
        request = Net::HTTP::Get.new build_uri.request_uri + "#{pull_id_params}"
        response = http.request request
        if response.kind_of? Net::HTTPFound
          $stderr.puts "Successfully submitted job for pull request"

          # Block until Jenkins actually increments the build number (this isn't transactional)
          $stderr.puts "Now waiting until build number increments..."
          while get_next_build(branch, settings) == next_build_num
            sleep 1
          end

          # Now you can safely return with the submission registered
          return JOB_BASE_URI + settings[:branches][branch][:jenkins_job_name] + "/#{next_build_num}/"
        else
          raise "Jenkins job submission failed for pull request"
        end
      end
    end

    def self.is_project_stable?(branch, settings)
      get_session(branch, settings).start do |http|
        uri = downstream_job_uri(branch, settings)
        request = Net::HTTP::Get.new uri.request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          result = JSON.parse(response.body)["result"]
          return  result == "SUCCESS" || result == "UNSTABLE"
        else
          raise "Jenkins connection error"
        end
      end
    end

    def self.get_next_build(branch, settings, job_name=nil)
      job_name = job_name ? job_name : settings[:branches][branch][:jenkins_job_name]
      job_api_uri = URI("#{JENKINS}/job/#{job_name}/api/json")
      get_session(branch, settings).start do |http|
        request = Net::HTTP::Get.new job_api_uri.request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          JSON.parse(response.body)["nextBuildNumber"].to_i
        else
          raise "Jenkins connection error"
        end
      end
    end

    def self.to_api_url build_url
      URI(build_url + "/api/json")
    end
    
    def self.is_previous_build_running?(branch, settings)
      build_num = get_next_build(branch, settings) - 1
      build_url = JOB_BASE_URI + settings[:branches][branch][:jenkins_job_name] + "/#{build_num}/"
      get_session(branch, settings).start do |http|
        request = Net::HTTP::Get.new to_api_url(build_url).request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          return JSON.parse(response.body)["building"]
        elsif response.kind_of? Net::HTTPNotFound
          return false # maybe someone deleted the last build?
        else
          return true # assume it's running to avoid errors causing multiple builds to start
        end
      end
    end

    def self.is_build_running?(build_url, branch, settings)
      get_session(branch, settings).start do |http|
        request = Net::HTTP::Get.new to_api_url(build_url).request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          return JSON.parse(response.body)["building"]
        else
          raise "Jenkins connection error"
        end
      end
    end

    def self.get_build_result(build_url, branch, settings)
      get_session(branch, settings).start do |http|
        request = Net::HTTP::Get.new to_api_url(build_url).request_uri
        response = http.request request
        if response.kind_of? Net::HTTPSuccess
          job = JSON.parse(response.body)
          return job["result"]
        else
          raise "Jenkins connection error"
        end
      end
    end
  end
end

#
#
# The main program script
#
#

# Create a new Hub client
@api_client ||= begin
  config_file = ENV['HUB_CONFIG'] || HUB_CONFIG
  file_store = GitHubAPI::FileStore.new File.expand_path(config_file)
  file_config = GitHubAPI::Configuration.new file_store
  GitHubAPI.new file_config, :app_url => APP_URL
end

$permissions = {}
$commits = {}
$submitted_tests = {}

if merge_pull_id
  @api_client.merge_pull_request(merge_pull_id, pull_id_repo, MERGE_TEST_SETTINGS)
elsif local_merge_pull_id
  @api_client.local_merge_pull_request(local_merge_pull_id, pull_id_repo)
elsif test_merge_pull_id
  @api_client.test_merge_pull_request(test_merge_pull_id, pull_id_repo, MERGE_TEST_SETTINGS)
else
  # Process all the pull requests for testing
  $stderr.puts "Processing pull requests..."
  @api_client.process_pull_requests
  $stderr.puts "Done\n"
end
