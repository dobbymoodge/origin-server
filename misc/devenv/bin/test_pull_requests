#!/usr/bin/ruby

# Client script for submitting pull requests for testing
# as well as updating the test results from Jenkins.
#
# This script requires that the 'hub' rubygem be installed
# which provides the OAuth functionality as well as some
# other core functionality.
#
# You should be able to install 'hub' with:
#   sudo gem install hub
#
# This has to be manually run one time to establish an OAuth
# ticket.  For OpenShift, the user to use is openshift-bot

require 'rubygems'
require 'hub'
require 'pp'
require 'net/https'
require 'getoptlong'
require 'time'

def usage
    puts <<USAGE
== Synopsis
test_pull_requests: Automatically run tests on pull requests.

== Usage
test_pull_requests OPTIONS

Options:
-t|--test
    Submit pull requests for testing.
-u|--update <comment_id:jenkins_job_id:test_exit_code>
    Update a specified pull request with the test results
-h|--help
    Show Usage info
USAGE
end

opts = GetoptLong.new(
    ["--test",             "-t", GetoptLong::OPTIONAL_ARGUMENT],
    ["--update",           "-u", GetoptLong::REQUIRED_ARGUMENT],
    ["--help",             "-h", GetoptLong::NO_ARGUMENT]
)

args = {}
begin
    opts.each{ |k,v| args[k]=v }
rescue GetoptLong::Error => e
    usage
    exit -100
end

update    = args["--update"]
test      = args["--test"]

if args["--help"] or (!update and !test)
  usage
  exit 1
end

include Hub

# Global configuration
USER = "openshift"
REPO = "crankcase"
JENKINS = "https://ci.dev.openshift.redhat.com/jenkins"
CHECK_URI = URI("#{JENKINS}/job/libra_check/lastCompletedBuild/api/json")
JOB_URI = "#{JENKINS}/job/test_pull_request"
BUILD_URI = URI("#{JOB_URI}/buildWithParameters?token=libra1")
JOB_API_URI = URI("#{JENKINS}/job/test_pull_request/api/json")
JOB_PARAM_1 = "CRANKCASE_PULL_ID"
JOB_PARAM_2 = "COMMENT_ID"
TEAM_RH = "168397"
TEST_PREFIX = "Test Results:"
WAITING_PREFIX = "Test Results: Waiting"
RUNNING_PREFIX = "Test Results: Running"

# Set proxy values to nil if you don't want to use a proxy
#PROXY_HOST = 'file.rdu.redhat.com'
#PROXY_PORT = 3128
PROXY_HOST = nil
PROXY_PORT = nil

# Dynamically extend GitHubAPI to add methods that don't
# require a local git project
module Hub
  class GitHubAPI
    def list_pull_requests
      res = get "https://api.github.com/repos/#{USER}/#{REPO}/pulls" 
      res.error! unless res.success?
      res.data
    end

    def is_mergeable? id
      res = get "https://api.github.com/repos/#{USER}/#{REPO}/pulls/%s" % id
      res.error! unless res.success?
      res.data['mergeable']
    end

    def get_comments issue_id
      res = get "https://api.github.com/repos/#{USER}/#{REPO}/issues/%s/comments" % issue_id
      res.error! unless res.success?
      res.data
    end

    def add_comment issue_id, comment
      params = { :body => comment }
      res = post "https://api.github.com/repos/#{USER}/#{REPO}/issues/%s/comments" % [issue_id], params
      res.error! unless res.success?
      res.data
    end

    def update_comment comment_id, comment
      $stderr.puts "Updating comment ##{comment_id} with #{comment}"
      params = { :body => comment }
      res = post "https://api.github.com/repos/#{USER}/#{REPO}/issues/comments/%s" % [comment_id], params
      res.error! unless res.success?
      res.data
    end

    #
    # This method determines if the pull request has already been tested
    # or is otherwise under review.  This could occur from the request being
    # marked as tests pending or from a pass / fail result.
    #
    def is_reviewed? issue_id, issue_updated_at
      get_comments(issue_id).each do |comment|
        id = comment["id"]
        case comment['body']
          when /#{WAITING_PREFIX}/
            # If it's waiting for the build, just return false
            return false, id
          when /#{RUNNING_PREFIX}/
            # If the tests are already running, just return true
            return true, id
          when /#{TEST_PREFIX}/
            # Otherwise, see if the test results need to be updated
            comment_updated_at = Time.parse(comment["updated_at"])
            return comment_updated_at > issue_updated_at, id
        end
      end

      return false, nil
    end

    # Verifies the user is part of Team Red Hat
    def user_trusted? login
      res = get "https://api.github.com/teams/#{TEAM_RH}/members/#{login}" % login
      return res.success?
    end

  end
end

#
# Creates a new Hub client
#
def create_client
  @api_client ||= begin
    config_file = ENV['HUB_CONFIG'] || '~/.config/hub'
    file_store = GitHubAPI::FileStore.new File.expand_path(config_file)
    file_config = GitHubAPI::Configuration.new file_store
    GitHubAPI.new file_config, :app_url => 'https://ci.dev.openshift.redhat.com'
  end
end

#
# Submits pull requests to Jenkins for testing
#
def test_pull_requests
  @api_client.list_pull_requests.each do |req|
    id = req['number']
    login = req['user']['login']
    mergeable = @api_client.is_mergeable? id
    req_updated_at = Time.parse(req["updated_at"])
    $stderr.puts "Analyzing pull request ##{id}"

    # Skip if it's not mergeable
    $stderr.puts "Mergeable #{mergeable}"
    next unless mergeable

    # Skip if it's already been reviewed
    reviewed, comment_id = @api_client.is_reviewed? id, req_updated_at
    $stderr.puts "Pull request ##{id} - reviewed (#{reviewed} / comment #{comment_id})"
    next if reviewed

    # Verify user is from the Red Hat Team
    next unless @api_client.user_trusted? login

    # Only test if the build is passing
    if is_build_passing?
      unless comment_id
        # Create an initial comment so Jenkins has an id to update
        $stderr.puts "Creating an initial comment for Jenkins"
        result = @api_client.add_comment id, "#{TEST_PREFIX} Submitting tests"
        comment_id = result["id"]
      end

      # Call Jenkins with the commit id
      new_job_url = submit_jenkins_job id, comment_id

      # Update that comment with the Jenkins information
      result = @api_client.update_comment comment_id, "#{TEST_PREFIX} Running (#{new_job_url})"
    else
      # Comment that the pull request is waiting for the build to stabilize
      result = @api_client.add_comment id, "#{TEST_PREFIX} Waiting for stable build"
    end
  end
end

def jenkins_session
  proxy = Net::HTTP::Proxy(PROXY_HOST, PROXY_PORT)
  http_session = proxy.new(CHECK_URI.host, CHECK_URI.port)
  http_session.use_ssl = true
  http_session.verify_mode = OpenSSL::SSL::VERIFY_NONE
  http_session.start do |http|
    yield http
  end
end

def submit_jenkins_job pull_id, comment_id
  # First, get the next jenkins build number
  next_build_num = get_next_build

  # Now submit the Jenkins job
  jenkins_session do |http|
    request = Net::HTTP::Get.new BUILD_URI.request_uri + "&#{JOB_PARAM_1}=#{pull_id}&#{JOB_PARAM_2}=#{comment_id}"
    response = http.request request
    if response.kind_of? Net::HTTPFound
      $stderr.puts "Successfully submitted job for pull request ##{pull_id} and comment ##{comment_id}"

      # Block until Jenkins actually increments the build number (this isn't transactional)
      $stderr.puts "Now waiting until build number increments..."
      while get_next_build == next_build_num
        sleep 1
      end

      # Now you can safely return with the submission registered
      return JOB_URI + "/#{next_build_num}/"
    else
      raise "Jenkins job submission failed for pull request #{pull_id}"
    end
  end
end

def is_build_passing?
  jenkins_session do |http|
    request = Net::HTTP::Get.new CHECK_URI.request_uri
    response = http.request request
    if response.kind_of? Net::HTTPSuccess
      return JSON.parse(response.body)["result"] == "SUCCESS"
    else
      raise "Jenkins connection error"
    end
  end
end

def get_next_build
  jenkins_session do |http|
    request = Net::HTTP::Get.new JOB_API_URI.request_uri
    response = http.request request
    if response.kind_of? Net::HTTPSuccess
      JSON.parse(response.body)["nextBuildNumber"].to_i
    else
      raise "Jenkins connection error"
    end
  end
end

#
# Updates a comment with test results
#
def update_results comment_id, passed, job_id
  result = passed ? "Passed" : "Failed" 
  @api_client.update_comment comment_id, "#{TEST_PREFIX} #{result} - #{JOB_URI}/#{job_id}"
  puts "Comment updated"
end

# Create the hub client
create_client

# Determine how the script was called
if test
  # Process all the pull requests for testing
  puts "Updating pull requests..."
  test_pull_requests
  puts "Done"
else
  # Assume this was an update, parse out the update string
  args = update.split(":")
  comment_id = args[0]
  job_id = args[1]
  passed = args[2].to_i == 0

  puts "Updating test result for comment - #{comment_id}, job - #{job_id}, result - #{passed}..."
  update_results comment_id, passed, job_id
  puts "Done"
end
