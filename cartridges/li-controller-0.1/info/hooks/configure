#!/bin/bash

# Copyright © 2010 Mike McGrath All rights reserved
# Copyright © 2010 Red Hat, Inc. All rights reserved

# This copyrighted material is made available to anyone wishing to use, modify,
# copy, or redistribute it subject to the terms and conditions of the GNU
# General Public License v.2.  This program is distributed in the hope that it
# will be useful, but WITHOUT ANY WARRANTY expressed or implied, including the
# implied warranties of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.  You should have
# received a copy of the GNU General Public License along with this program;
# if not, write to the Free Software Foundation, Inc., 51 Franklin Street,
# Fifth Floor, Boston, MA 02110-1301, USA. Any Red Hat trademarks that are
# incorporated in the source code or documentation are not subject to the GNU
# General Public License and may only be used or replicated with the express
# permission of Red Hat, Inc.

# Creates a libra user
#
# IN: username
#     email address
#     SSH RSA public key
#
# 1) create a local user account: username, home directory
# 2) enable login via SSH using RSA key: trap user
# 3) place Libra service information: $HOME/etc/customer_info
# 4) Place limits on user: number of processes

# 
#
# default values
#
DEFAULT_LIBRA_DIR=/var/lib/libra
DEFAULT_LIBRA_CONF_DIR=/etc/libra

# defaults
limits_order=84
limits_nproc=50
quota_files=1000
# a block = 1Kbytes: 1k * 1024 * 128
quota_blocks=`expr 1024 \* 128` # 128MB

# Exit on any errors
# set -e

#
#  provide usage information
#
function print_help {
    echo "Usage: $0"
    echo "  -c customer_uuid"
    echo "  -e email"
    echo "  -s ssh_pub_key"
    echo "  -d (optional: debug)"
    exit 1
}

function initialize {
    # import Libra node configuration
    if [ -f '/etc/libra/node.conf' ]
    then
	. /etc/libra/node.conf
    elif [ -f 'node.conf' ]
    then
	. node.conf
    else
	echo "node.conf not found.  Cannot continue" 1>&2
	exit 3
    fi

    if [ -f "/etc/libra/resource_limits.conf" ]
    then
	. /etc/libra/resource_limits.conf
    fi

    if [ -z "$libra_dir" ]
    then
	libra_dir=$DEFAULT_LIBRA_DIR
    fi
}

function parse_options {
    while getopts 'c:e:s:p:o:dnr' OPTION
    do
	case $OPTION in
            c) username=$OPTARG
		;;
            e) email=$OPTARG
		;;
            s) ssh_key=$OPTARG
		;;
            p) limits_nproc=$OPTARG
		;;
            o) limits_order=$OPTARG
		;;
            d) set -x
		;;
	    n) NOOP='echo'
		;;
	    r) REVERT="TRUE"
		;;
            ?) print_help
		;;
	esac
    done

    if ( [ -z "$username" ] || [ -z "$email" ] || [ -z "$ssh_key" ] )
    then
	print_help
    fi
}

#
# Generate a user's home directory from their username
#
function homedir {
    USERNAME=$1
    USERHOME=`grep $USERNAME /etc/passwd | cut -d: -f6`

    if [ -n "${USERHOME}" ]
    then
        echo $USERHOME
    else
        # remove duplicate slashes (/) and return the result
	echo ${libra_dir}/${USERNAME} | tr -s '/'
    fi
}

# Find the filesystem which holds a user's home directory
function home_filesystem {
    df ${libra_dir} | tail -1 | cut -d' ' -f1
}


# Find the next available UID/GID pair
function next_uid() {

  # find the lowest number greater than or equal to 500 which is not used 
  # either as a UID or GID
  # Line 1: create a set of UID's from /etc/passwd
  # Line 2: create a set of GID's from /etc/group
  # count up from 500 until you find one not used in either
  python -c "pid = set([int(line.split(':')[2]) for line in open('/etc/passwd').readlines()])
gid = set([int(line.split(':')[2]) for line in open('/etc/group').readlines()])
i = 500
while i in pid or i in gid: i += 1
print i
"

}

#
# Create a local user account
#
# IN: username
# IN: homeroot


function create_user_account() {
    USERNAME=$1

    # Don't depend on useradd to select the next UID/GID pair
    NEXTUID=`next_uid`

    HOMEDIR=`homedir $USERNAME`

    # check if the user can be identified already
    id $USERNAME >/dev/null 2>&1
    USEREXISTS=$?

    if [ $USEREXISTS -ne 0 ]
    then
        ${NOOP} groupadd -g ${NEXTUID} ${USERNAME}

	${NOOP} useradd -g ${USERNAME} -u ${NEXTUID} -d ${HOMEDIR} -s /usr/bin/trap-user -c "libra guest" $USERNAME
	if [ $? -ne 0 ]
        then
	    echo "ERROR: unable to create user account $USERNAME"
	    exit 1
        fi
    fi
    ${NOOP} chown "root.$USERNAME" "$HOMEDIR"
    ${NOOP} chmod 0750 "$HOMEDIR"
}

function remove_user_account {
    USERNAME=$1

    ${NOOP} userdel -f -r ${USERNAME}
}

#
# Configure Libra application information
#
# IN: username
# IN: user home directory
# IN: email
function configure_user_account {
    USERNAME=$1
    EMAIL="$2"

    USERHOME=`homedir $USERNAME`
    USERETC=$USERHOME/etc

    ${NOOP} mkdir -p $USERETC
    if [ -z "${NOOP}" ]
    then
	${NOOP} cat <<EOF >${USERETC}/customer_info
CUSTOMER_ID=\"${USERNAME}\"
EMAIL=\"${EMAIL}\"
EOF
    else
        echo "cat <<EOF > ${USERETC}/customer_info
EOF"
    fi

    # Ensure the new directory is root protected
    ${NOOP} chown -R root.root $USERETC
}


#
# Enable SSH RSA access for a user
#
# ASSUME: local user with username exists
# IN: username
# IN: user home directory
# IN: user email address
# IN: SSH RSA key string
#
function enable_user_ssh_access {
    USERNAME=$1
    USEREMAIL="$2"
    SSHKEY="$3"
    
    USERHOME=`homedir $USERNAME`
    SSHDIR=${USERHOME}/.ssh

    ${NOOP} mkdir -p ${SSHDIR}
    ${NOOP} chmod 0750 ${SSHDIR}
    if [ -z "${NOOP}" ]
    then
	cat <<EOF > ${SSHDIR}/authorized_keys
command="/usr/bin/trap-user",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa $SSHKEY Libra-$USERNAME-$USEREMAIL
EOF
    else
	echo "cat <<EOF > $SSHDIR/authorized_keys
command=\\\"/usr/bin/trap-user\\\",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty ssh-rsa $SSHKEY Libra-$USERNAME-$USEREMAIL
EOF\""
    fi

    ${NOOP} chmod 0440 ${SSHDIR}/authorized_keys

    # Give force ssh key to not change
    ${NOOP} chown -R "root.$USERNAME" ${SSHDIR}
    ${NOOP} restorecon -R ${SSHDIR}
}


#
# Add a PAM limit set to the user
#
# IN: username
# IN: limits_order
# IN: limits_nproc
#

LIMITSVARS="core data fsize memlock nofile rss stack cpu nproc as maxlogins priority locks sigpending msgqueue nice rprio"

# TODO: check if file already exists
function set_pam_limits {
    USERNAME=$1
    #assume these come from sourced config file into environment
    #LIMITS_ORDER=${2:-$limits_order}
    #LIMITS_NPROC=${3:-$limits_nproc}

    LIMITSFILE=/etc/security/limits.d/${limits_order}-${USERNAME}.conf

    if [ -z "${NOOP}" ]
    then
	cat <<EOF > ${LIMITSFILE}
# PAM process limits for guest $customer_id
# see limits.conf(5) for details
#Each line describes a limit for a user in the form:
#
#<domain> <type> <item> <value>
EOF
    else
	echo "cat <<EOF > ${LIMITSFILE}
# PAM process limits for guest $customer_id
# see limits.conf(5) for details
#Each line describes a limit for a user in the form:
#
#<domain>        <type>  <item>  <value>
${USERNAME}     hard    nproc   ${LIMITS_NPROC}
EOF"
	
    fi

    for KEY in $LIMITSVARS
    do
	VALUE=`eval echo \\$limits_$KEY`
	if [ -n "$VALUE" ]
	then
	    if [ -z "${NOOP}" ]
            then
		echo "${USERNAME} hard $KEY $VALUE" >> ${LIMITSFILE}
            else
		echo "echo \"${USERNAME} hard $KEY $VALUE\" >> ${LIMITSFILE}"
	    fi
	fi
    done

}

function remove_pam_limits {
    USERNAME=$1
    LIMITS_ORDER=${2:-$limits_order}

    LIMITSFILE=/etc/security/limits.d/${LIMITS_ORDER}-${USERNAME}.conf


    ${NOOP} rm -f ${LIMITSFILE}
}


#
# Are quotas configured
# return true if configured, else false
#
function quotas_configured {
    quotaon -u -p $libra_dir >/dev/null 2>&1
    if [ $? -eq 0 ]
    then
	return 1
    else
	return 0
    fi
}

# Are quotas enabled on libra home directories
# echos "yes" or "no".  Returns 1 if not configured
function quotas_enabled {
    quotaon -u -p $libra_dir 2>/dev/null | cut -d' ' -f7
}

#
# Get the user's current quotas in a managable string form:
#      inodes       blocks
# fs use soft hard use soft hard
# empty string means "no quotas set"
#
function user_quotas {
    # USERNAME=$1
    FS=`home_filesystem`
    quota -w -u $1 | grep $FS | tr -s ' ' | sed 's/^ //'
}

#
# Set a user's inode and block quotas on the home file system
# usage: set_fs_quota <username> <inodes> <blocks>
function set_fs_quotas {
    # USERNAME=$1
    # QUOTA_BLOCKS=${2:-$quota_blocks}
    # QUOTA_FILES=${3:-$quota_files}

    if quotas_configured
    then
	setquota $1 0 $2 0 $3 `home_filesystem`
    fi
}

# Remove filesystem quota limits for the user
function remove_fs_quotas {
    USERNAME=$1
    if quotas_configured
    then
	setquota $1 0 0 0 0 `home_filesystem`
    fi
}

# ============================================================================
#                                 MAIN
# ============================================================================

# get configuration values from libra configuration files or defaults
initialize

# provides values for username, email and ssh_key
parse_options $*

if [ -z "$REVERT" ]
then
    create_user_account $username

    if (service cgconfig status > /dev/null )
    then
	service libra-cgroups startuser ${username} > /dev/null
    fi

    configure_user_account $username $email

    enable_user_ssh_access $username $email "$ssh_key"

    set_pam_limits $username

    set_fs_quotas $username $quota_blocks $quota_files

else
    if (service cgconfig status > /dev/null)
    then
	service libra-cgroups stopuser ${username} > /dev/null
    fi

    remove_fs_quotas $username

    remove_pam_limits $username
    
    remove_user_account $username
fi
