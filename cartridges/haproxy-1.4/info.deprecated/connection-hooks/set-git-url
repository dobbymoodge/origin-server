#!/bin/bash

# Set a newly added gear's git url to the list of mirrors we need to push too.
GEAR_AVAILABILITY_TIMEOUT=30

# Exit on any errors
set -e

function log_error() {
    echo "$0: $@" | logger -p local0.err -t stickshift_haproxy_set_git_url
    return ${1:-1}
}


function print_help() {
    echo "Usage: $0 app-name namespace uuid"
    echo "Start a running application"

    echo "$0 $@" | logger -p local0.notice -t stickshift_haproxy_set_git_url
    exit 1
}


function check_gear_availability() {
    gear_dns_name=$(echo $1 | cut -f 2 -d '@' | cut -f 1 -d '/')
    timeout=${2:-$GEAR_AVAILABILITY_TIMEOUT}
    i=0
    while [ $i -lt $timeout ]; do
        if dig CNAME $gear_dns_name | grep "ANSWER SECTION" > /dev/null; then
            if ping -c 5 $gear_dns_name > /dev/null; then
                return 0
            fi
        fi

        i=$((i + 1))
        sleep 1
    done

    return 1
}


function setup_git_repo_from_framework() {
    #  Ensure framework gear is available.
    check_gear_availability "$1" $GEAR_AVAILABILITY_TIMEOUT  ||   \
        log_error 140 "DNS check failed - setting up from gear git URL = $1"

    pushd "$GIT_DIR" > /dev/null
    rm -rf * 2> /dev/null  ||  :
    git clone --bare --no-hardlinks $1 "$GIT_DIR"
    git remote add all-gears "$HAPROXY_GIT_URL"
    touch config
    git repack
    popd > /dev/null

    setup_git_repo "$application" "$user_id" "$group_id" "$uuid" "haproxy 1.4 for scalable app"
    observe_setup_app_and_git_dirs

    chown $user_id.$group_id "$OPENSHIFT_DATA_DIR/.ssh/config"
}


function add_gear_git_mirror() {
    [ $# -lt 2 ]  &&  return 1

    gear_name=$1
    url=$2

    git remote add $gear_name $git_url
    git remote set-url --add --push all-gears $git_url
}


function secure_git_remotes() {
   remotes="$GIT_DIR/refs/remotes"
   [ -d "$remotes" ]  ||  return 0

   chown $user_id.$group_id -R "$remotes"
   observe_setup_var_lib_dir "$remotes"
}


function git_mirror_push() {
    [ $# -lt 1 ]  &&  return 1

    gear_name=$1

    #  Need to push twice so that mirror states are also synced.
    git push $gear_name --mirror
    git push $gear_name --mirror

    secure_git_remotes
}


function register_gear() {
    [ $# -lt 2 ]  &&  return 1

    gear_name=$1
    git_url=$2

    # Generate registry entry of the form: gear-${gear_name}=${gear_git_url}
    entry="$gear_name=$git_url"
    gear_registry=$OPENSHIFT_GEAR_DIR/conf/gear-registry.git

    #  Check if its the first framework gear and if so setup the haproxy
    #  git repo from there.
    [ -s "$gear_registry" ]  ||  setup_git_repo_from_framework "$git_url"

    #  Add to the gear git registry if entry doesn't exist.
    if ! grep "$entry" "$gear_registry" > /dev/null 2>&1; then
        echo "$entry" >> "$gear_registry"

        check_gear_availability "$git_url" $GEAR_AVAILABILITY_TIMEOUT  ||   \
            log_error 141 "DNS check failed - registering gear git URL = $1"

        pushd "$GIT_DIR" > /dev/null
        add_gear_git_mirror "$gear_name" "$gear_url"

        #
        # FIXME: This maybe inefficient if we have jenkins as we will do builds
        #        on every gear. rsync is more efficient if each framework has a
        #        gear sync - as what to sync varies by framework - do a git push
        #        for now.
        #
        git_mirror_push "$gear_name"

        popd > /dev/null

        return 0
    fi

    return 1
}


function get_gear_git_mirrors() {
    echo $(git remote -v  | grep -E "^gear\-.*(push)"  |  awk '{print $1}')
}


function get_gear_git_url() {
    echo $(git remote -v  | grep -E "^$1\s*.*(push)"  |  awk '{print $2}')
}


function remove_gear_git_mirror() {
    [ $# -lt 2 ]  &&  return 1

    gear_name=$1
    git_url=$2

    git remote rm $gear_name
    git remote set-url --delete --push all-gears $git_url
}


function unregister_gear() {
    [ $# -lt 2 ]  &&  return 1

    gear_name=$1
    git_url=$2

    # Search for registry entry of the form: gear-${gear_name}=${gear_git_url}
    entry="$gear_name=$git_url"
    gear_registry=$OPENSHIFT_GEAR_DIR/conf/gear-registry.git

    #  Check if the gear git registry entry exists.
    if grep "$entry" "$gear_registry" > /dev/null 2>&1; then
        sed "/$gear_name=.*/d" "$gear_registry"  > /tmp/gear.registry
        cat /tmp/gear.registry > "$gear_registry"
        rm -f /tmp/gear.registry
    fi

    remove_gear_git_mirror "$gear_name" "$git_url"
}


#
# main():
#
while getopts 'd' OPTION
do
    case $OPTION in
        d) set -x
        ;;
        ?) print_help
        ;;
    esac
done


[ $# -gt 3 ] || print_help

source /etc/stickshift/stickshift-node.conf
source ${CARTRIDGE_BASE_PATH}/abstract/info/lib/util
source ${CARTRIDGE_BASE_PATH}/abstract/info/lib/git

setup_configure "$1" $2 $3

import_env_vars

CART_NAME=haproxy
CART_VERSION=1.4
CART_INFO_DIR=${CARTRIDGE_BASE_PATH}/${CART_NAME}-${CART_VERSION}/info
export GIT_SSH=${CART_INFO_DIR}/bin/ssh
export GIT_DIR=${OPENSHIFT_HOMEDIR}/git/${OPENSHIFT_GEAR_NAME}.git
export HAPROXY_GIT_URL=ssh://${OPENSHIFT_GEAR_UUID}@${OPENSHIFT_GEAR_DNS}/~/git/${OPENSHIFT_GEAR_NAME}.git

declare -A curr_gears

#  Remove the first 3 args and process all the remaining args of the form
#  key=value. The values are the git urls for each gear.
kvargs=$(echo "${@:4}" | tr -d "\n" )
for arg in $kvargs; do
    url=$(echo "$arg" | cut -f 2 -d '=' | tr -d "'")
    gear_name=gear-$(echo "$url" | cut -f 2 -d '@' | cut -f 1 -d '.')
    curr_gears[$gear_name]="$url"
    register_gear "$gear_name" "$url"  ||  :
done

# Get a list of all the git mirror gears and remove the gears which are not
# in the current set.
for gear_name in $(get_gear_git_mirrors); do
    if [ -z "${curr_gears[$gear_name]}" ]; then
        unregister_gear "$gear_name" $(get_gear_git_url "$gear_name")
    fi
done
