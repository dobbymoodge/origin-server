#!/bin/bash

# Set a newly added gear's git url to the list of mirrors we need to push too.
CART_DIR=/usr/libexec/li/cartridges
CART_NAME=haproxy
CART_VERSION=1.4
CART_INFO_DIR=$CART_DIR/$CART_NAME-$CART_VERSION/info
DNS_CHECK_TIMEOUT=30

# Exit on any errors
set -e

function print_help {
    echo "Usage: $0 app-name namespace uuid"
    echo "Start a running application"

    echo "$0 $@" | logger -p local0.notice -t libra_haproxy_set_git_url
    exit 1
}


function check_gear_dns_availability() {
    gear_dns_name=$(echo $1 | cut -f 2 -d '@' | cut -f 1 -d '/')
    timeout=${2:-$DNS_CHECK_TIMEOUT}
    i=0
    while [ $i -lt $timeout ]; do
        if dig CNAME $gear_dns_name | grep "ANSWER SECTION" 2>&1 > /dev/null; then
            return 0
        fi

        i=$((i + 1))
        sleep 1
    done

    return 1
}


function setup_git_repo_from_framework() {
    checkout_dir_name=app-framework-gear

    #  Ensure framework gear is available.
    check_gear_dns_availability "$1" $DNS_CHECK_TIMEOUT  ||  sleep 10

    pushd "$GIT_DIR" > /dev/null
    git clone --bare $1 /tmp/$checkout_dir_name
    rm -rf * 2> /dev/null  ||  :
    mv -f /tmp/$checkout_dir_name/[^h]* ./ 2> /dev/null  ||  :
    git remote add all-gears "file://$GIT_DIR"
    popd > /dev/null
}


function register_gear() {
    [ $# -lt 2 ]  &&  return 1

    name=$1
    git_url=$2

    # Generate registry entry of the form: gear-${gear_name}=${gear_git_url}
    entry="gear-$name=$git_url"
    gear_registry=$OPENSHIFT_APP_DIR/conf/gear-registry.git

    #  Check if its the first framework gear and if so setup the haproxy
    #  git repo from there.
    [ -s "$gear_registry" ]  ||  setup_git_repo_from_framework "$git_url"

    #  Add to the gear git registry if entry doesn't exist.
    if ! grep "$entry" $gear_registry 2>&1 > /dev/null; then
        echo "$entry" >> $gear_registry
        return 0
    fi

    return 1
}


while getopts 'd' OPTION
do
    case $OPTION in
        d) set -x
        ;;
        ?) print_help
        ;;
    esac
done


[ $# -gt 3 ] || print_help

# Import Environment Variables
for f in ~/.env/*; do
    source $f
done

export GIT_SSH=$CART_INFO_DIR/bin/ssh
export GIT_DIR=${OPENSHIFT_HOMEDIR}/git/${OPENSHIFT_APP_NAME}.git

#  Remove the first 3 args and process all the remaining args of the form
#  key=value. The values are the git urls for each gear.
kvargs=$(echo "${@:4}" | tr -d "\n" )
for arg in $kvargs; do
    url=$(echo "$arg" | cut -f 2 -d '=' | tr -d "'")
    gear_name=$(echo "$url" | cut -f 2 -d '@' | cut -f 1 -d '.')
    if register_gear "$gear_name" "$url"; then
        #
        # FIXME: This maybe inefficient if we have jenkins as we will do builds
        #        on every gear. rsync is more efficient if each framework has a
        #        gear sync - as what to sync varies by framework - do a git push
        #        for now.
        #

        pushd "$GIT_DIR" > /dev/null
        git remote add gear-$gear_name $url
        git remote set-url --add --push all-gears $url

        # Need two git "mirrored" pushes as the first push updates us with the
        # newly added gear-$gear_name.
        git push --mirror gear-$gear_name  ||  :
        git push --mirror gear-$gear_name  ||  :
        popd > /dev/null
    fi
done

