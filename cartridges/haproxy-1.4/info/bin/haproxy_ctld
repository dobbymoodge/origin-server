#!/usr/bin/ruby

require 'socket'
require 'logger'
require 'getoptlong'

@check_interval=3

class Haproxy_attr
    attr_accessor :pxname,:svname,:qcur,:qmax,:scur,:smax,:slim,:stot,:bin,:bout,:dreq,:dresp,:ereq,:econ,:eresp,:wretr,:wredis,:status,:weight,:act,:bck,:chkfail,:chkremove,:lastchg,:removetime,:qlimit,:pid,:iid,:sid,:throttle,:lbtot,:tracked,:type,:rate,:rate_lim,:rate_max,:check_status,:check_code,:check_duration,:hrsp_1xx,:hrsp_2xx,:hrsp_3xx,:hrsp_4xx,:hrsp_5xx,:hrsp_other,:hanafail,:req_rate,:req_rate_max,:req_tot,:cli_abrt,:srv_abrt

    def initialize(line)
        (@pxname,@svname,@qcur,@qmax,@scur,@smax,@slim,@stot,@bin,@bout,@dreq,@dresp,@ereq,@econ,@eresp,@wretr,@wredis,@status,@weight,@act,@bck,@chkfail,@chkremove,@lastchg,@removetime,@qlimit,@pid,@iid,@sid,@throttle,@lbtot,@tracked,@type,@rate,@rate_lim,@rate_max,@check_status,@check_code,@check_duration,@hrsp_1xx,@hrsp_2xx,@hrsp_3xx,@hrsp_4xx,@hrsp_5xx,@hrsp_other,@hanafail,@req_rate,@req_rate_max,@req_tot,@cli_abrt,@srv_abrt) = line.split(',')
    end
end

class Haproxy
    #ha=Haproxy.new("/tmp/stats")
    #gear_namespace=ENV['OPENSHIFT_GEAR_DNS'].split('.')[0].split('-')[1]
    #gear_count = ha.stats['express'].count - 3.0 # Remove backend, frontend and 'filler'
    #sessions = ha.stats['express']['BACKEND'].scur.to_f
    #sessions_per_gear = sessions / gear_count
    #session_capacity_pct = (sessions_per_gear / @max_sessions_per_gear ) * 100

    def initialize(stats_sock="/tmp/stats")
        @stats_sock=stats_sock
        @last_scale_up_time=Time.now
        @flap_protection_time_seconds = 120 # number of seconds to ignore gear remove events since last up event
        @remove_count_threshold = 3
        @remove_count = 0
        self.refresh
        @log.info("Starting haproxy_ctld")
        self.print_gear_stats
    end

    def refresh(stats_sock="/tmp/stats")
        @socket = UNIXSocket.open(@stats_sock)
        @socket.puts("show stat\n") 
        @max_sessions_per_gear=10.0
        @gear_remove_pct = 49.9
        @gear_up_pct = 90.0
        @log = Logger.new("#{ENV['OPENSHIFT_LOG_DIR']}/scale_events.log")

        @status={}
        while(line = @socket.gets) do
            pxname=line.split(',')[0]
            svname=line.split(',')[1]
            @status[pxname] = {} unless @status[pxname]
            @status[pxname][svname] = Haproxy_attr.new(line)
        end
        @socket.close
        @gear_namespace = ENV['OPENSHIFT_GEAR_DNS'].split('.')[0].split('-')[1]
        @gear_count = self.stats['express'].count - 3
        @sessions = self.stats['express']['BACKEND'].scur.to_i
        @sessions_per_gear = @sessions / @gear_count
        @session_capacity_pct = @session_capacity_pct = (@sessions_per_gear / @max_sessions_per_gear ) * 100

    end

    def gear_namespace()
        @gear_namespace
    end

    def last_scale_up_time()
        @last_scale_up_time
    end

    def last_scale_up_time_seconds()
        seconds = Time.now - @last_scale_up_time
        seconds.to_i
    end

    def seconds_left_til_remove()
        seconds = @flap_protection_time_seconds - self.last_scale_up_time_seconds
        seconds.to_i
    end

    def gear_count()
        @gear_count
    end

    def sessions()
        @sessions
    end

    def sessions_per_gear()
        @sessions_per_gear
    end

    def session_capacity_pct()
        @session_capacity_pct
    end

    def add_gear
        @last_scale_up_time = Time.now
        @log.info("GEAR_UP - capacity: #{self.session_capacity_pct}% gear_count: #{self.gear_count} sessions: #{self.sessions} up_thresh: #{@gear_up_pct}%")
        `add-gear -l mmcgrath@redhat.com -p ' ' -n #{self.gear_namespace}  -h localhost -a #{ENV['OPENSHIFT_GEAR_NAME']}`
        self.print_gear_stats
    end

    def remove_gear
        @log.info("GEAR_DOWN - capacity: #{self.session_capacity_pct}% gear_count: #{self.gear_count} sessions: #{self.sessions} remove_thresh: #{@gear_remove_pct}%")
        `remove-gear -l mmcgrath@redhat.com -p ' ' -n #{self.gear_namespace} -h localhost -a #{ENV['OPENSHIFT_GEAR_NAME']}`
        self.print_gear_stats
    end

    def print_gear_stats
        if self.seconds_left_til_remove > 0
            seconds_left = self.seconds_left_til_remove
        else
            seconds_left = 0
        end
        @log.debug("GEAR_INFO - capacity: #{session_capacity_pct}% gear_count: #{gear_count} sessions: #{sessions} up/remove_thresh: #{@gear_up_pct}%/#{@gear_remove_pct}% sec_left_til_remove: #{seconds_left} gear_remove_thresh: #{@remove_count}/#{@remove_count_threshold}")
    end

    def check_capacity(debug=nil)
        # check_capacity tracks the following information for determing whether
        # or not to increase or decrease a gear
        #
        # @session_capacity_pct (%full considering total number of gears and
        #       current sessions
        # @gear_up_pct - When capacity is larger then gear_up_pct, add a gear
        # @gear_remove_pct - When capacity is less then gear_remove_pct, remove a
        #       gear
        # @gear_count - The number of gears (don't remove a gear when there's
        #       only one left.
        # @last_scale_up_time_seconds - how long it's been since we last scaled
        #       up
        # @flap_protection_time_seconds - The number of seconds to wait until
        #       triggering a gear_remove event
        # @remove_count - Number of consecutive remove_gear requests
        # @remove_count_threshold - when remove_count meets remove_count_threshold
        #       actually issue a remove_gear


        # If active capacity is greater then gear_up pct. Add a gear
        if @session_capacity_pct >= @gear_up_pct
            @remove_count = 0
            self.add_gear
        elsif @session_capacity_pct < @gear_remove_pct and @gear_count > 1
            # If active capacity is less then gear remove percentage
            # *AND* the last gear up happened longer then
            # ago @flap_protection_time_seconds
            # *AND* remove_count is larger then the remove_count_threshold
            # Gear remove.

            @remove_count += 1 if @remove_count < 3

            if self.last_scale_up_time_seconds.to_i > @flap_protection_time_seconds
                if @remove_count >= @remove_count_threshold
                    self.remove_gear
                    @remove_count = 0
                else
                    self.print_gear_stats if debug
                end
            else
                self.print_gear_stats if debug
            end
        else
            @remove_count = 0
            self.print_gear_stats if debug
        end
    end


    def stats()
        @status
    end

    def scur()
        @scur
    end

end

def p_usage
    puts <<USAGE

Usage: #{$0}
Control scaling features for this application.  Has two operating modes, auto
and manual.  Manual scaling options will run requested action and exit, auto
scaling options will stay running in the foreground.

  -h|--help         Display this help menu

Manual scaling options:
  -u|--up           Trigger a gear_up event and add an additional gear
  -d|--down         Trigger a gear_remove event and remove a gear
  --debug           Puts logger into debug mode

Auto scaling options:
  -a|--auto         Enable auto-scale
  --debug           Puts logger into debug mode

Notes:
1. To start/stop auto scaling in daemon mode run:
    haproxy_watcher (start|stop|restart|run|)
USAGE
    exit 255
end

begin
    opts = GetoptLong.new(
        ["--up", "-u", GetoptLong::NO_ARGUMENT],
        ["--down", "-d", GetoptLong::NO_ARGUMENT],
        ["--auto", "-a", GetoptLong::NO_ARGUMENT],
        ["--debug", GetoptLong::NO_ARGUMENT],
        ["--help",  "-h", GetoptLong::NO_ARGUMENT]
    )
    opt = {}
    opts.each do |o, a|
        opt[o[2..-1]] = a.to_s
    end
rescue Exception => e
  p_usage
end


if opt['up']
    ha=Haproxy.new("/tmp/stats")
   ha.add_gear
   exit 0
elsif opt['down']
    ha=Haproxy.new("/tmp/stats")
    ha.remove_gear
    exit 0
end

ha=Haproxy.new("/tmp/stats")
while true
    ha.refresh()
    ha.check_capacity(opt['debug'])
    sleep @check_interval
end
